
import * as version from './version.mjs';
import { UInt5, WitnessVersion } from './structs/CommonBase.mjs';

const imports: any = {};
imports.env = {};

var js_objs: Array<WeakRef<object>> = [];
var js_invoke: Function;
var getRandomValues: Function;

imports.wasi_snapshot_preview1 = {
	"fd_write": (fd: number, iovec_array_ptr: number, iovec_array_len: number, bytes_written_ptr: number) => {
		// This should generally only be used to print panic messages
		const ptr_len_view = new Uint32Array(wasm.memory.buffer, iovec_array_ptr, iovec_array_len * 2);
		var bytes_written = 0;
		for (var i = 0; i < iovec_array_len; i++) {
			const bytes_view = new Uint8Array(wasm.memory.buffer, ptr_len_view[i*2], ptr_len_view[i*2+1]);
			console.log("[fd " + fd + "]: " + String.fromCharCode(...bytes_view));
			bytes_written += ptr_len_view[i*2+1]!;
		}
		const written_view = new Uint32Array(wasm.memory.buffer, bytes_written_ptr, 1);
		written_view[0] = bytes_written;
		return 0;
	},
	"fd_close": (_fd: number) => {
		// This is not generally called, but may be referenced in debug builds
		console.log("wasi_snapshot_preview1:fd_close");
		return 58; // Not Supported
	},
	"fd_seek": (_fd: number, _offset: bigint, _whence: number, _new_offset: number) => {
		// This is not generally called, but may be referenced in debug builds
		console.log("wasi_snapshot_preview1:fd_seek");
		return 58; // Not Supported
	},
	"random_get": (buf_ptr: number, buf_len: number) => {
		const buf = new Uint8Array(wasm.memory.buffer, buf_ptr, buf_len);
		getRandomValues(buf);
		return 0;
	},
	"environ_sizes_get": (environ_var_count_ptr: number, environ_len_ptr: number) => {
		// This is called before fd_write to format + print panic messages
		const out_count_view = new Uint32Array(wasm.memory.buffer, environ_var_count_ptr, 1);
		out_count_view[0] = 0;
		const out_len_view = new Uint32Array(wasm.memory.buffer, environ_len_ptr, 1);
		out_len_view[0] = 0;
		return 0;
	},
	"environ_get": (_environ_ptr: number, _environ_buf_ptr: number) => {
		// This is called before fd_write to format + print panic messages,
		// but only if we have variables in environ_sizes_get, so shouldn't ever actually happen!
		console.log("wasi_snapshot_preview1:environ_get");
		return 58; // Note supported - we said there were 0 environment entries!
	},
	"proc_exit" : () => {
		console.log("wasi_snapshot_preview1:proc_exit");
	},
};

var wasm: any = null;
let isWasmInitialized: boolean = false;

async function finishInitializeWasm(wasmInstance: WebAssembly.Instance) {
	if (typeof crypto === "undefined") {
		var crypto_import = (await import('crypto')).webcrypto;
		getRandomValues = crypto_import.getRandomValues.bind(crypto_import);
	} else {
		getRandomValues = crypto.getRandomValues.bind(crypto);
	}

	wasm = wasmInstance.exports;
	if (!wasm.test_bigint_pass_deadbeef0badf00d(BigInt("0xdeadbeef0badf00d"))) {
		throw new Error("Currently need BigInt-as-u64 support, try ----experimental-wasm-bigint");
	}

	if (decodeString(wasm.TS_get_lib_version_string()) !== version.get_ldk_java_bindings_version())
		throw new Error("Compiled LDK library and LDK class files do not match");
	// Fetching the LDK versions from C also checks that the header and binaries match
	const c_bindings_ver: number = wasm.TS_get_ldk_c_bindings_version();
	const ldk_ver: number = wasm.TS_get_ldk_version();
	if (c_bindings_ver == 0)
		throw new Error("LDK version did not match the header we built against");
	if (ldk_ver == 0)
		throw new Error("LDK C bindings version did not match the header we built against");
	const c_bindings_version: string = decodeString(c_bindings_ver)
	const ldk_version: string = decodeString(ldk_ver);
	console.log("Loaded LDK-Java Bindings with LDK " + ldk_version + " and LDK-C-Bindings " + c_bindings_version);

	isWasmInitialized = true;
}

const fn_list = ["uuuuuu", "buuuuu", "bbuuuu", "bbbuuu", "bbbbuu", "bbbbbu",
	"bbbbbb", "ubuubu", "ubuuuu", "ubbuuu", "uubuuu", "uububu", "ububuu"];

/* @internal */
export async function initializeWasmFromUint8Array(wasmBinary: Uint8Array) {
	for (const fn of fn_list) { imports.env["js_invoke_function_" + fn] = js_invoke; }
	const { instance: wasmInstance } = await WebAssembly.instantiate(wasmBinary, imports);
	await finishInitializeWasm(wasmInstance);
}

/* @internal */
export async function initializeWasmFetch(uri: string) {
	for (const fn of fn_list) { imports.env["js_invoke_function_" + fn] = js_invoke; }
	const stream = fetch(uri);
	const { instance: wasmInstance } = await WebAssembly.instantiateStreaming(stream, imports);
	await finishInitializeWasm(wasmInstance);
}
// WASM CODEC

/* @internal */
export function uint5ArrToBytes(inputArray: Array<UInt5>): Uint8Array {
	const arr = new Uint8Array(inputArray.length);
	for (var i = 0; i < inputArray.length; i++) {
		arr[i] = inputArray[i]!.getVal();
	}
	return arr;
}

/* @internal */
export function WitnessVersionArrToBytes(inputArray: Array<WitnessVersion>): Uint8Array {
	const arr = new Uint8Array(inputArray.length);
	for (var i = 0; i < inputArray.length; i++) {
		arr[i] = inputArray[i]!.getVal();
	}
	return arr;
}



/* @internal */
export function encodeUint128 (inputVal: bigint): number {
	if (inputVal >= 0x10000000000000000000000000000000n) throw "U128s cannot exceed 128 bits";
	const cArrayPointer = wasm.TS_malloc(16 + 8);
	const arrayLengthView = new BigUint64Array(wasm.memory.buffer, cArrayPointer, 1);
	arrayLengthView[0] = BigInt(16);
	const arrayMemoryView = new Uint8Array(wasm.memory.buffer, cArrayPointer + 8, 16);
	for (var i = 0; i < 16; i++) arrayMemoryView[i] = Number((inputVal >> BigInt(i)*8n) & 0xffn);
	return cArrayPointer;
}
/* @internal */
export function encodeUint8Array (inputArray: Uint8Array|null): number {
	if (inputArray == null) return 0;
	const cArrayPointer = wasm.TS_malloc(inputArray.length + 8);
	const arrayLengthView = new BigUint64Array(wasm.memory.buffer, cArrayPointer, 1);
	arrayLengthView[0] = BigInt(inputArray.length);
	const arrayMemoryView = new Uint8Array(wasm.memory.buffer, cArrayPointer + 8, inputArray.length);
	arrayMemoryView.set(inputArray);
	return cArrayPointer;
}
/* @internal */
export function encodeUint16Array (inputArray: Uint16Array|Array<number>|null): number {
	if (inputArray == null) return 0;
	const cArrayPointer = wasm.TS_malloc((inputArray.length + 4) * 2);
	const arrayLengthView = new BigUint64Array(wasm.memory.buffer, cArrayPointer, 1);
	arrayLengthView[0] = BigInt(inputArray.length);
	const arrayMemoryView = new Uint16Array(wasm.memory.buffer, cArrayPointer + 8, inputArray.length);
	arrayMemoryView.set(inputArray);
	return cArrayPointer;
}
/* @internal */
export function encodeUint32Array (inputArray: Uint32Array|Array<number>|null): number {
	if (inputArray == null) return 0;
	const cArrayPointer = wasm.TS_malloc((inputArray.length + 2) * 4);
	const arrayLengthView = new BigUint64Array(wasm.memory.buffer, cArrayPointer, 1);
	arrayLengthView[0] = BigInt(inputArray.length);
	const arrayMemoryView = new Uint32Array(wasm.memory.buffer, cArrayPointer + 8, inputArray.length);
	arrayMemoryView.set(inputArray);
	return cArrayPointer;
}
/* @internal */
export function encodeUint64Array (inputArray: BigUint64Array|Array<bigint>|null): number {
	if (inputArray == null) return 0;
	const cArrayPointer = wasm.TS_malloc((inputArray.length + 1) * 8);
	const arrayMemoryView = new BigUint64Array(wasm.memory.buffer, cArrayPointer, inputArray.length + 1);
	arrayMemoryView[0] = BigInt(inputArray.length);
	arrayMemoryView.set(inputArray, 1);
	return cArrayPointer;
}

/* @internal */
export function check_arr_len(arr: Uint8Array|null, len: number): Uint8Array|null {
	if (arr !== null && arr.length != len) { throw new Error("Expected array of length " + len + " got " + arr.length); }
	return arr;
}

/* @internal */
export function check_16_arr_len(arr: Uint16Array|null, len: number): Uint16Array|null {
	if (arr !== null && arr.length != len) { throw new Error("Expected array of length " + len + " got " + arr.length); }
	return arr;
}

/* @internal */
export function getArrayLength(arrayPointer: number): number {
	const arraySizeViewer = new BigUint64Array(wasm.memory.buffer, arrayPointer, 1);
	const len = arraySizeViewer[0]!;
	if (len >= (2n ** 32n)) throw new Error("Bogus Array Size");
	return Number(len % (2n ** 32n));
}
/* @internal */
export function decodeUint128 (arrayPointer: number, free = true): bigint {
	const arraySize = getArrayLength(arrayPointer);
	if (arraySize != 16) throw "Need 16 bytes for a uint128";
	const actualArrayViewer = new Uint8Array(wasm.memory.buffer, arrayPointer + 8, arraySize);
	var val = 0n;
	for (var i = 0; i < 16; i++) {
		val <<= 8n;
		val |= BigInt(actualArrayViewer[i]!);
	}
	if (free) {
		wasm.TS_free(arrayPointer);
	}
	return val;
}
/* @internal */
export function decodeUint8Array (arrayPointer: number, free = true): Uint8Array {
	const arraySize = getArrayLength(arrayPointer);
	const actualArrayViewer = new Uint8Array(wasm.memory.buffer, arrayPointer + 8, arraySize);
	// Clone the contents, TODO: In the future we should wrap the Viewer in a class that
	// will free the underlying memory when it becomes unreachable instead of copying here.
	// Note that doing so may have edge-case interactions with memory resizing (invalidating the buffer).
	const actualArray = actualArrayViewer.slice(0, arraySize);
	if (free) {
		wasm.TS_free(arrayPointer);
	}
	return actualArray;
}
/* @internal */
export function decodeUint16Array (arrayPointer: number, free = true): Uint16Array {
	const arraySize = getArrayLength(arrayPointer);
	const actualArrayViewer = new Uint16Array(wasm.memory.buffer, arrayPointer + 8, arraySize);
	// Clone the contents, TODO: In the future we should wrap the Viewer in a class that
	// will free the underlying memory when it becomes unreachable instead of copying here.
	// Note that doing so may have edge-case interactions with memory resizing (invalidating the buffer).
	const actualArray = actualArrayViewer.slice(0, arraySize);
	if (free) {
		wasm.TS_free(arrayPointer);
	}
	return actualArray;
}
/* @internal */
export function decodeUint64Array (arrayPointer: number, free = true): bigint[] {
	const arraySize = getArrayLength(arrayPointer);
	const actualArrayViewer = new BigUint64Array(
		wasm.memory.buffer, // value
		arrayPointer + 8, // offset (ignoring length bytes)
		arraySize // uint32 count
	);
	// Clone the contents, TODO: In the future we should wrap the Viewer in a class that
	// will free the underlying memory when it becomes unreachable instead of copying here.
	const actualArray = new Array(arraySize);
	for (var i = 0; i < arraySize; i++) actualArray[i] = actualArrayViewer[i];
	if (free) {
		wasm.TS_free(arrayPointer);
	}
	return actualArray;
}

export function freeWasmMemory(pointer: number) { wasm.TS_free(pointer); }

/* @internal */
export function getU64ArrayElem(arrayPointer: number, idx: number): bigint {
	const actualArrayViewer = new BigUint64Array(wasm.memory.buffer, arrayPointer + 8, idx + 1);
	return actualArrayViewer[idx]!;
}

/* @internal */
export function getU32ArrayElem(arrayPointer: number, idx: number): number {
	const actualArrayViewer = new Uint32Array(wasm.memory.buffer, arrayPointer + 8, idx + 1);
	return actualArrayViewer[idx]!;
}

/* @internal */
export function getU8ArrayElem(arrayPointer: number, idx: number): number {
	const actualArrayViewer = new Uint8Array(wasm.memory.buffer, arrayPointer + 8, idx + 1);
	return actualArrayViewer[idx]!;
}


/* @internal */
export function encodeString(str: string): number {
	const charArray = new TextEncoder().encode(str);
	return encodeUint8Array(charArray);
}

/* @internal */
export function decodeString(stringPointer: number, free = true): string {
	const arraySize = getArrayLength(stringPointer);
	const memoryView = new Uint8Array(wasm.memory.buffer, stringPointer + 8, arraySize);
	const result = new TextDecoder("utf-8").decode(memoryView);

	if (free) {
		wasm.TS_free(stringPointer);
	}

	return result;
}

/* @internal */ export function getRemainingAllocationCount(): number { return 0; }
/* @internal */ export function debugPrintRemainingAllocs() { }

/**
 * Errors that may occur when converting a [`RawBolt11Invoice`] to a [`Bolt11Invoice`]. They relate to
 * the requirements sections in BOLT #11
 */
export enum Bolt11SemanticError {
	/**
	 * The invoice is missing the mandatory payment hash
	 */
	LDKBolt11SemanticError_NoPaymentHash,
	/**
	 * The invoice has multiple payment hashes which isn't allowed
	 */
	LDKBolt11SemanticError_MultiplePaymentHashes,
	/**
	 * No description or description hash are part of the invoice
	 */
	LDKBolt11SemanticError_NoDescription,
	/**
	 * The invoice contains multiple descriptions and/or description hashes which isn't allowed
	 */
	LDKBolt11SemanticError_MultipleDescriptions,
	/**
	 * The invoice is missing the mandatory payment secret, which all modern lightning nodes
	should provide.
	 */
	LDKBolt11SemanticError_NoPaymentSecret,
	/**
	 * The invoice contains multiple payment secrets
	 */
	LDKBolt11SemanticError_MultiplePaymentSecrets,
	/**
	 * The invoice's features are invalid
	 */
	LDKBolt11SemanticError_InvalidFeatures,
	/**
	 * The recovery id doesn't fit the signature/pub key
	 */
	LDKBolt11SemanticError_InvalidRecoveryId,
	/**
	 * The invoice's signature is invalid
	 */
	LDKBolt11SemanticError_InvalidSignature,
	/**
	 * The invoice's amount was not a whole number of millisatoshis
	 */
	LDKBolt11SemanticError_ImpreciseAmount,
	
}

/**
 * Error when interpreting a TLV stream as a specific type.
 */
export enum Bolt12SemanticError {
	/**
	 * The current [`std::time::SystemTime`] is past the offer or invoice's expiration.
	 */
	LDKBolt12SemanticError_AlreadyExpired,
	/**
	 * The provided chain hash does not correspond to a supported chain.
	 */
	LDKBolt12SemanticError_UnsupportedChain,
	/**
	 * A chain was provided but was not expected.
	 */
	LDKBolt12SemanticError_UnexpectedChain,
	/**
	 * An amount was expected but was missing.
	 */
	LDKBolt12SemanticError_MissingAmount,
	/**
	 * The amount exceeded the total bitcoin supply.
	 */
	LDKBolt12SemanticError_InvalidAmount,
	/**
	 * An amount was provided but was not sufficient in value.
	 */
	LDKBolt12SemanticError_InsufficientAmount,
	/**
	 * An amount was provided but was not expected.
	 */
	LDKBolt12SemanticError_UnexpectedAmount,
	/**
	 * A currency was provided that is not supported.
	 */
	LDKBolt12SemanticError_UnsupportedCurrency,
	/**
	 * A feature was required but is unknown.
	 */
	LDKBolt12SemanticError_UnknownRequiredFeatures,
	/**
	 * Features were provided but were not expected.
	 */
	LDKBolt12SemanticError_UnexpectedFeatures,
	/**
	 * A required description was not provided.
	 */
	LDKBolt12SemanticError_MissingDescription,
	/**
	 * A signing pubkey was not provided.
	 */
	LDKBolt12SemanticError_MissingSigningPubkey,
	/**
	 * A signing pubkey was provided but a different one was expected.
	 */
	LDKBolt12SemanticError_InvalidSigningPubkey,
	/**
	 * A signing pubkey was provided but was not expected.
	 */
	LDKBolt12SemanticError_UnexpectedSigningPubkey,
	/**
	 * A quantity was expected but was missing.
	 */
	LDKBolt12SemanticError_MissingQuantity,
	/**
	 * An unsupported quantity was provided.
	 */
	LDKBolt12SemanticError_InvalidQuantity,
	/**
	 * A quantity or quantity bounds was provided but was not expected.
	 */
	LDKBolt12SemanticError_UnexpectedQuantity,
	/**
	 * Metadata could not be used to verify the offers message.
	 */
	LDKBolt12SemanticError_InvalidMetadata,
	/**
	 * Metadata was provided but was not expected.
	 */
	LDKBolt12SemanticError_UnexpectedMetadata,
	/**
	 * Payer metadata was expected but was missing.
	 */
	LDKBolt12SemanticError_MissingPayerMetadata,
	/**
	 * A payer id was expected but was missing.
	 */
	LDKBolt12SemanticError_MissingPayerId,
	/**
	 * Blinded paths were expected but were missing.
	 */
	LDKBolt12SemanticError_MissingPaths,
	/**
	 * The blinded payinfo given does not match the number of blinded path hops.
	 */
	LDKBolt12SemanticError_InvalidPayInfo,
	/**
	 * An invoice creation time was expected but was missing.
	 */
	LDKBolt12SemanticError_MissingCreationTime,
	/**
	 * An invoice payment hash was expected but was missing.
	 */
	LDKBolt12SemanticError_MissingPaymentHash,
	/**
	 * A signature was expected but was missing.
	 */
	LDKBolt12SemanticError_MissingSignature,
	
}

/**
 * An enum which can either contain a  or not
 */
export enum COption_NoneZ {
	/**
	 * When we're in this state, this COption_NoneZ contains a
	 */
	LDKCOption_NoneZ_Some,
	/**
	 * When we're in this state, this COption_NoneZ contains nothing
	 */
	LDKCOption_NoneZ_None,
	
}

/**
 * An enum representing the status of a channel monitor update persistence.
 */
export enum ChannelMonitorUpdateStatus {
	/**
	 * The update has been durably persisted and all copies of the relevant [`ChannelMonitor`]
	have been updated.
	
	This includes performing any `fsync()` calls required to ensure the update is guaranteed to
	be available on restart even if the application crashes.
	 */
	LDKChannelMonitorUpdateStatus_Completed,
	/**
	 * Used to indicate a temporary failure (eg connection to a watchtower or remote backup of
	our state failed, but is expected to succeed at some point in the future).
	
	Such a failure will \"freeze\" a channel, preventing us from revoking old states or
	submitting new commitment transactions to the counterparty. Once the update(s) which failed
	have been successfully applied, a [`MonitorEvent::Completed`] can be used to restore the
	channel to an operational state.
	
	Note that a given [`ChannelManager`] will *never* re-generate a [`ChannelMonitorUpdate`].
	If you return this error you must ensure that it is written to disk safely before writing
	the latest [`ChannelManager`] state, or you should return [`PermanentFailure`] instead.
	
	Even when a channel has been \"frozen\", updates to the [`ChannelMonitor`] can continue to
	occur (e.g. if an inbound HTLC which we forwarded was claimed upstream, resulting in us
	attempting to claim it on this channel) and those updates must still be persisted.
	
	No updates to the channel will be made which could invalidate other [`ChannelMonitor`]s
	until a [`MonitorEvent::Completed`] is provided, even if you return no error on a later
	monitor update for the same channel.
	
	For deployments where a copy of ChannelMonitors and other local state are backed up in a
	remote location (with local copies persisted immediately), it is anticipated that all
	updates will return [`InProgress`] until the remote copies could be updated.
	
	[`PermanentFailure`]: ChannelMonitorUpdateStatus::PermanentFailure
	[`InProgress`]: ChannelMonitorUpdateStatus::InProgress
	[`ChannelManager`]: crate::ln::channelmanager::ChannelManager
	 */
	LDKChannelMonitorUpdateStatus_InProgress,
	/**
	 * Used to indicate no further channel monitor updates will be allowed (likely a disk failure
	or a remote copy of this [`ChannelMonitor`] is no longer reachable and thus not updatable).
	
	When this is returned, [`ChannelManager`] will force-close the channel but *not* broadcast
	our current commitment transaction. This avoids a dangerous case where a local disk failure
	(e.g. the Linux-default remounting of the disk as read-only) causes [`PermanentFailure`]s
	for all monitor updates. If we were to broadcast our latest commitment transaction and then
	restart, we could end up reading a previous [`ChannelMonitor`] and [`ChannelManager`],
	revoking our now-broadcasted state before seeing it confirm and losing all our funds.
	
	Note that this is somewhat of a tradeoff - if the disk is really gone and we may have lost
	the data permanently, we really should broadcast immediately. If the data can be recovered
	with manual intervention, we'd rather close the channel, rejecting future updates to it,
	and broadcast the latest state only if we have HTLCs to claim which are timing out (which
	we do as long as blocks are connected).
	
	In order to broadcast the latest local commitment transaction, you'll need to call
	[`ChannelMonitor::get_latest_holder_commitment_txn`] and broadcast the resulting
	transactions once you've safely ensured no further channel updates can be generated by your
	[`ChannelManager`].
	
	Note that at least one final [`ChannelMonitorUpdate`] may still be provided, which must
	still be processed by a running [`ChannelMonitor`]. This final update will mark the
	[`ChannelMonitor`] as finalized, ensuring no further updates (e.g. revocation of the latest
	commitment transaction) are allowed.
	
	Note that even if you return a [`PermanentFailure`] due to unavailability of secondary
	[`ChannelMonitor`] copies, you should still make an attempt to store the update where
	possible to ensure you can claim HTLC outputs on the latest commitment transaction
	broadcasted later.
	
	In case of distributed watchtowers deployment, the new version must be written to disk, as
	state may have been stored but rejected due to a block forcing a commitment broadcast. This
	storage is used to claim outputs of rejected state confirmed onchain by another watchtower,
	lagging behind on block processing.
	
	[`PermanentFailure`]: ChannelMonitorUpdateStatus::PermanentFailure
	[`ChannelManager`]: crate::ln::channelmanager::ChannelManager
	 */
	LDKChannelMonitorUpdateStatus_PermanentFailure,
	
}

/**
 * Further information on the details of the channel shutdown.
 * Upon channels being forced closed (i.e. commitment transaction confirmation detected
 * by `ChainMonitor`), ChannelShutdownState will be set to `ShutdownComplete` or
 * the channel will be removed shortly.
 * Also note, that in normal operation, peers could disconnect at any of these states
 * and require peer re-connection before making progress onto other states
 */
export enum ChannelShutdownState {
	/**
	 * Channel has not sent or received a shutdown message.
	 */
	LDKChannelShutdownState_NotShuttingDown,
	/**
	 * Local node has sent a shutdown message for this channel.
	 */
	LDKChannelShutdownState_ShutdownInitiated,
	/**
	 * Shutdown message exchanges have concluded and the channels are in the midst of
	resolving all existing open HTLCs before closing can continue.
	 */
	LDKChannelShutdownState_ResolvingHTLCs,
	/**
	 * All HTLCs have been resolved, nodes are currently negotiating channel close onchain fee rates.
	 */
	LDKChannelShutdownState_NegotiatingClosingFee,
	/**
	 * We've successfully negotiated a closing_signed dance. At this point `ChannelManager` is about
	to drop the channel.
	 */
	LDKChannelShutdownState_ShutdownComplete,
	
}

/**
 * An enum that represents the priority at which we want a transaction to confirm used for feerate
 * estimation.
 */
export enum ConfirmationTarget {
	/**
	 * We'd like a transaction to confirm in the future, but don't want to commit most of the fees
	required to do so yet. The remaining fees will come via a Child-Pays-For-Parent (CPFP) fee
	bump of the transaction.
	
	The feerate returned should be the absolute minimum feerate required to enter most node
	mempools across the network. Note that if you are not able to obtain this feerate estimate,
	you should likely use the furthest-out estimate allowed by your fee estimator.
	 */
	LDKConfirmationTarget_MempoolMinimum,
	/**
	 * We are happy with a transaction confirming slowly, at least within a day or so worth of
	blocks.
	 */
	LDKConfirmationTarget_Background,
	/**
	 * We'd like a transaction to confirm without major delayed, i.e., within the next 12-24 blocks.
	 */
	LDKConfirmationTarget_Normal,
	/**
	 * We'd like a transaction to confirm in the next few blocks.
	 */
	LDKConfirmationTarget_HighPriority,
	
}

/**
 * Errors that may occur when constructing a new [`RawBolt11Invoice`] or [`Bolt11Invoice`]
 */
export enum CreationError {
	/**
	 * The supplied description string was longer than 639 __bytes__ (see [`Description::new`])
	 */
	LDKCreationError_DescriptionTooLong,
	/**
	 * The specified route has too many hops and can't be encoded
	 */
	LDKCreationError_RouteTooLong,
	/**
	 * The Unix timestamp of the supplied date is less than zero or greater than 35-bits
	 */
	LDKCreationError_TimestampOutOfBounds,
	/**
	 * The supplied millisatoshi amount was greater than the total bitcoin supply.
	 */
	LDKCreationError_InvalidAmount,
	/**
	 * Route hints were required for this invoice and were missing. Applies to
	[phantom invoices].
	
	[phantom invoices]: crate::utils::create_phantom_invoice
	 */
	LDKCreationError_MissingRouteHints,
	/**
	 * The provided `min_final_cltv_expiry_delta` was less than [`MIN_FINAL_CLTV_EXPIRY_DELTA`].
	
	[`MIN_FINAL_CLTV_EXPIRY_DELTA`]: lightning::ln::channelmanager::MIN_FINAL_CLTV_EXPIRY_DELTA
	 */
	LDKCreationError_MinFinalCltvExpiryDeltaTooShort,
	
}

/**
 * Enum representing the crypto currencies (or networks) supported by this library
 */
export enum Currency {
	/**
	 * Bitcoin mainnet
	 */
	LDKCurrency_Bitcoin,
	/**
	 * Bitcoin testnet
	 */
	LDKCurrency_BitcoinTestnet,
	/**
	 * Bitcoin regtest
	 */
	LDKCurrency_Regtest,
	/**
	 * Bitcoin simnet
	 */
	LDKCurrency_Simnet,
	/**
	 * Bitcoin signet
	 */
	LDKCurrency_Signet,
	
}

/**
 * This enum is used to specify which error data to send to peers when failing back an HTLC
 * using [`ChannelManager::fail_htlc_backwards_with_reason`].
 * 
 * For more info on failure codes, see <https://github.com/lightning/bolts/blob/master/04-onion-routing.md#failure-messages>.
 */
export enum FailureCode {
	/**
	 * We had a temporary error processing the payment. Useful if no other error codes fit
	and you want to indicate that the payer may want to retry.
	 */
	LDKFailureCode_TemporaryNodeFailure,
	/**
	 * We have a required feature which was not in this onion. For example, you may require
	some additional metadata that was not provided with this payment.
	 */
	LDKFailureCode_RequiredNodeFeatureMissing,
	/**
	 * You may wish to use this when a `payment_preimage` is unknown, or the CLTV expiry of
	the HTLC is too close to the current block height for safe handling.
	Using this failure code in [`ChannelManager::fail_htlc_backwards_with_reason`] is
	equivalent to calling [`ChannelManager::fail_htlc_backwards`].
	 */
	LDKFailureCode_IncorrectOrUnknownPaymentDetails,
	
}

/**
 * Describes the type of HTLC claim as determined by analyzing the witness.
 */
export enum HTLCClaim {
	/**
	 * Claims an offered output on a commitment transaction through the timeout path.
	 */
	LDKHTLCClaim_OfferedTimeout,
	/**
	 * Claims an offered output on a commitment transaction through the success path.
	 */
	LDKHTLCClaim_OfferedPreimage,
	/**
	 * Claims an accepted output on a commitment transaction through the timeout path.
	 */
	LDKHTLCClaim_AcceptedTimeout,
	/**
	 * Claims an accepted output on a commitment transaction through the success path.
	 */
	LDKHTLCClaim_AcceptedPreimage,
	/**
	 * Claims an offered/accepted output on a commitment transaction through the revocation path.
	 */
	LDKHTLCClaim_Revocation,
	
}

/**
 * Represents an IO Error. Note that some information is lost in the conversion from Rust.
 */
export enum IOError {
		LDKIOError_NotFound,
		LDKIOError_PermissionDenied,
		LDKIOError_ConnectionRefused,
		LDKIOError_ConnectionReset,
		LDKIOError_ConnectionAborted,
		LDKIOError_NotConnected,
		LDKIOError_AddrInUse,
		LDKIOError_AddrNotAvailable,
		LDKIOError_BrokenPipe,
		LDKIOError_AlreadyExists,
		LDKIOError_WouldBlock,
		LDKIOError_InvalidInput,
		LDKIOError_InvalidData,
		LDKIOError_TimedOut,
		LDKIOError_WriteZero,
		LDKIOError_Interrupted,
		LDKIOError_Other,
		LDKIOError_UnexpectedEof,
	
}

/**
 * An enum representing the available verbosity levels of the logger.
 */
export enum Level {
	/**
	 * Designates extremely verbose information, including gossip-induced messages
	 */
	LDKLevel_Gossip,
	/**
	 * Designates very low priority, often extremely verbose, information
	 */
	LDKLevel_Trace,
	/**
	 * Designates lower priority information
	 */
	LDKLevel_Debug,
	/**
	 * Designates useful information
	 */
	LDKLevel_Info,
	/**
	 * Designates hazardous situations
	 */
	LDKLevel_Warn,
	/**
	 * Designates very serious errors
	 */
	LDKLevel_Error,
	
}

/**
 * An enum representing the possible Bitcoin or test networks which we can run on
 */
export enum Network {
	/**
	 * The main Bitcoin blockchain.
	 */
	LDKNetwork_Bitcoin,
	/**
	 * The testnet3 blockchain.
	 */
	LDKNetwork_Testnet,
	/**
	 * A local test blockchain.
	 */
	LDKNetwork_Regtest,
	/**
	 * A blockchain on which blocks are signed instead of mined.
	 */
	LDKNetwork_Signet,
	
}

/**
 * The reason the payment failed. Used in [`Event::PaymentFailed`].
 */
export enum PaymentFailureReason {
	/**
	 * The intended recipient rejected our payment.
	 */
	LDKPaymentFailureReason_RecipientRejected,
	/**
	 * The user chose to abandon this payment by calling [`ChannelManager::abandon_payment`].
	
	[`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
	 */
	LDKPaymentFailureReason_UserAbandoned,
	/**
	 * We exhausted all of our retry attempts while trying to send the payment, or we
	exhausted the [`Retry::Timeout`] if the user set one. If at any point a retry
	attempt failed while being forwarded along the path, an [`Event::PaymentPathFailed`] will
	have come before this.
	
	[`Retry::Timeout`]: crate::ln::channelmanager::Retry::Timeout
	 */
	LDKPaymentFailureReason_RetriesExhausted,
	/**
	 * The payment expired while retrying, based on the provided
	[`PaymentParameters::expiry_time`].
	
	[`PaymentParameters::expiry_time`]: crate::routing::router::PaymentParameters::expiry_time
	 */
	LDKPaymentFailureReason_PaymentExpired,
	/**
	 * We failed to find a route while retrying the payment.
	 */
	LDKPaymentFailureReason_RouteNotFound,
	/**
	 * This error should generally never happen. This likely means that there is a problem with
	your router.
	 */
	LDKPaymentFailureReason_UnexpectedError,
	
}

/**
 * Specifies the recipient of an invoice.
 * 
 * This indicates to [`NodeSigner::sign_invoice`] what node secret key should be used to sign
 * the invoice.
 */
export enum Recipient {
	/**
	 * The invoice should be signed with the local node secret key.
	 */
	LDKRecipient_Node,
	/**
	 * The invoice should be signed with the phantom node secret key. This secret key must be the
	same for all nodes participating in the [phantom node payment].
	
	[phantom node payment]: PhantomKeysManager
	 */
	LDKRecipient_PhantomNode,
	
}

/**
 * Indicates an immediate error on [`ChannelManager::send_payment`]. Further errors may be
 * surfaced later via [`Event::PaymentPathFailed`] and [`Event::PaymentFailed`].
 * 
 * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
 * [`Event::PaymentPathFailed`]: crate::events::Event::PaymentPathFailed
 * [`Event::PaymentFailed`]: crate::events::Event::PaymentFailed
 */
export enum RetryableSendFailure {
	/**
	 * The provided [`PaymentParameters::expiry_time`] indicated that the payment has expired. Note
	that this error is *not* caused by [`Retry::Timeout`].
	
	[`PaymentParameters::expiry_time`]: crate::routing::router::PaymentParameters::expiry_time
	 */
	LDKRetryableSendFailure_PaymentExpired,
	/**
	 * We were unable to find a route to the destination.
	 */
	LDKRetryableSendFailure_RouteNotFound,
	/**
	 * Indicates that a payment for the provided [`PaymentId`] is already in-flight and has not
	yet completed (i.e. generated an [`Event::PaymentSent`] or [`Event::PaymentFailed`]).
	
	[`PaymentId`]: crate::ln::channelmanager::PaymentId
	[`Event::PaymentSent`]: crate::events::Event::PaymentSent
	[`Event::PaymentFailed`]: crate::events::Event::PaymentFailed
	 */
	LDKRetryableSendFailure_DuplicatePayment,
	
}

/**
 * Represents an error returned from libsecp256k1 during validation of some secp256k1 data
 */
export enum Secp256k1Error {
	/**
	 * Signature failed verification
	 */
	LDKSecp256k1Error_IncorrectSignature,
	/**
	 * Badly sized message ("messages" are actually fixed-sized digests; see the MESSAGE_SIZE constant)
	 */
	LDKSecp256k1Error_InvalidMessage,
	/**
	 * Bad public key
	 */
	LDKSecp256k1Error_InvalidPublicKey,
	/**
	 * Bad signature
	 */
	LDKSecp256k1Error_InvalidSignature,
	/**
	 * Bad secret key
	 */
	LDKSecp256k1Error_InvalidSecretKey,
	/**
	 * Bad shared secret.
	 */
	LDKSecp256k1Error_InvalidSharedSecret,
	/**
	 * Bad recovery id
	 */
	LDKSecp256k1Error_InvalidRecoveryId,
	/**
	 * Invalid tweak for add_assign or mul_assign
	 */
	LDKSecp256k1Error_InvalidTweak,
	/**
	 * Didn't pass enough memory to context creation with preallocated memory
	 */
	LDKSecp256k1Error_NotEnoughMemory,
	/**
	 * Bad set of public keys.
	 */
	LDKSecp256k1Error_InvalidPublicKeySum,
	/**
	 * The only valid parity values are 0 or 1.
	 */
	LDKSecp256k1Error_InvalidParityValue,
	
}

/**
 * SI prefixes for the human readable part
 */
export enum SiPrefix {
	/**
	 * 10^-3
	 */
	LDKSiPrefix_Milli,
	/**
	 * 10^-6
	 */
	LDKSiPrefix_Micro,
	/**
	 * 10^-9
	 */
	LDKSiPrefix_Nano,
	/**
	 * 10^-12
	 */
	LDKSiPrefix_Pico,
	
}

/**
 * An error when accessing the chain via [`UtxoLookup`].
 */
export enum UtxoLookupError {
	/**
	 * The requested chain is unknown.
	 */
	LDKUtxoLookupError_UnknownChain,
	/**
	 * The requested transaction doesn't exist or hasn't confirmed.
	 */
	LDKUtxoLookupError_UnknownTx,
	
}
	// struct LDKThirtyTwoBytes BigEndianScalar_get_bytes (struct LDKBigEndianScalar* thing)
/* @internal */
export function BigEndianScalar_get_bytes(thing: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BigEndianScalar_get_bytes(thing);
	return nativeResponseValue;
}
	// static void BigEndianScalar_free (struct LDKBigEndianScalar thing)
/* @internal */
export function BigEndianScalar_free(thing: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BigEndianScalar_free(thing);
	// debug statements here
}
/* @internal */
export class LDKBech32Error {
	protected constructor() {}
}
/* @internal */
export function LDKBech32Error_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBech32Error_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBech32Error_InvalidChar_get_invalid_char(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBech32Error_InvalidChar_get_invalid_char(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBech32Error_InvalidData_get_invalid_data(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBech32Error_InvalidData_get_invalid_data(ptr);
	return nativeResponseValue;
}
	// struct LDKWitness TxIn_get_witness (struct LDKTxIn* thing)
/* @internal */
export function TxIn_get_witness(thing: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxIn_get_witness(thing);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z TxIn_get_script_sig (struct LDKTxIn* thing)
/* @internal */
export function TxIn_get_script_sig(thing: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxIn_get_script_sig(thing);
	return nativeResponseValue;
}
	// LDKThirtyTwoBytes TxIn_get_previous_txid (struct LDKTxIn* thing)
/* @internal */
export function TxIn_get_previous_txid(thing: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxIn_get_previous_txid(thing);
	return nativeResponseValue;
}
	// uint32_t TxIn_get_previous_vout (struct LDKTxIn* thing)
/* @internal */
export function TxIn_get_previous_vout(thing: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxIn_get_previous_vout(thing);
	return nativeResponseValue;
}
	// uint32_t TxIn_get_sequence (struct LDKTxIn* thing)
/* @internal */
export function TxIn_get_sequence(thing: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxIn_get_sequence(thing);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z TxOut_get_script_pubkey (struct LDKTxOut* thing)
/* @internal */
export function TxOut_get_script_pubkey(thing: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxOut_get_script_pubkey(thing);
	return nativeResponseValue;
}
	// uint64_t TxOut_get_value (struct LDKTxOut* thing)
/* @internal */
export function TxOut_get_value(thing: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxOut_get_value(thing);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_DurationZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_DurationZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_DurationZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_DurationZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_DurationZ_Some_get_some(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_u64Z {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_u64Z_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_u64Z_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_u64Z_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_u64Z_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKRefund CResult_RefundBolt12ParseErrorZ_get_ok(LDKCResult_RefundBolt12ParseErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RefundBolt12ParseErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RefundBolt12ParseErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKBolt12ParseError CResult_RefundBolt12ParseErrorZ_get_err(LDKCResult_RefundBolt12ParseErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RefundBolt12ParseErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RefundBolt12ParseErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKAPIError {
	protected constructor() {}
}
/* @internal */
export function LDKAPIError_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKAPIError_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKAPIError_APIMisuseError_get_err(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKAPIError_APIMisuseError_get_err(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKAPIError_FeeRateTooHigh_get_err(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKAPIError_FeeRateTooHigh_get_err(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKAPIError_FeeRateTooHigh_get_feerate(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKAPIError_FeeRateTooHigh_get_feerate(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKAPIError_InvalidRoute_get_err(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKAPIError_InvalidRoute_get_err(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKAPIError_ChannelUnavailable_get_err(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKAPIError_ChannelUnavailable_get_err(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKAPIError_IncompatibleShutdownScript_get_script(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKAPIError_IncompatibleShutdownScript_get_script(ptr);
	return nativeResponseValue;
}
	// void CResult_NoneAPIErrorZ_get_ok(LDKCResult_NoneAPIErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneAPIErrorZ_get_ok(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_get_ok(owner);
	// debug statements here
}
	// struct LDKAPIError CResult_NoneAPIErrorZ_get_err(LDKCResult_NoneAPIErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneAPIErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_PaymentSecretZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_PaymentSecretZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_PaymentSecretZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_PaymentSecretZ_Some_get_some(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_PaymentSecretZ_Some_get_some(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_CVec_u8ZZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_CVec_u8ZZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_CVec_u8ZZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_CVec_u8ZZ_Some_get_some(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_CVec_u8ZZ_Some_get_some(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKDecodeError {
	protected constructor() {}
}
/* @internal */
export function LDKDecodeError_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKDecodeError_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKDecodeError_Io_get_io(ptr: bigint): IOError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKDecodeError_Io_get_io(ptr);
	return nativeResponseValue;
}
	// struct LDKRecipientOnionFields CResult_RecipientOnionFieldsDecodeErrorZ_get_ok(LDKCResult_RecipientOnionFieldsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RecipientOnionFieldsDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecipientOnionFieldsDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_RecipientOnionFieldsDecodeErrorZ_get_err(LDKCResult_RecipientOnionFieldsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RecipientOnionFieldsDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecipientOnionFieldsDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKOffersMessage {
	protected constructor() {}
}
/* @internal */
export function LDKOffersMessage_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKOffersMessage_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKOffersMessage_InvoiceRequest_get_invoice_request(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKOffersMessage_InvoiceRequest_get_invoice_request(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKOffersMessage_Invoice_get_invoice(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKOffersMessage_Invoice_get_invoice(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKOffersMessage_InvoiceError_get_invoice_error(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKOffersMessage_InvoiceError_get_invoice_error(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_OffersMessageZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_OffersMessageZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_OffersMessageZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_OffersMessageZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_OffersMessageZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKOffersMessage CResult_OffersMessageDecodeErrorZ_get_ok(LDKCResult_OffersMessageDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OffersMessageDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OffersMessageDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_OffersMessageDecodeErrorZ_get_err(LDKCResult_OffersMessageDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OffersMessageDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OffersMessageDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_HTLCClaimZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_HTLCClaimZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_HTLCClaimZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_HTLCClaimZ_Some_get_some(ptr: bigint): HTLCClaim {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_HTLCClaimZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// void CResult_NoneNoneZ_get_ok(LDKCResult_NoneNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneNoneZ_get_ok(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_get_ok(owner);
	// debug statements here
}
	// void CResult_NoneNoneZ_get_err(LDKCResult_NoneNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKCounterpartyCommitmentSecrets CResult_CounterpartyCommitmentSecretsDecodeErrorZ_get_ok(LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CounterpartyCommitmentSecretsDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyCommitmentSecretsDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_CounterpartyCommitmentSecretsDecodeErrorZ_get_err(LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CounterpartyCommitmentSecretsDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyCommitmentSecretsDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTxCreationKeys CResult_TxCreationKeysDecodeErrorZ_get_ok(LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxCreationKeysDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_TxCreationKeysDecodeErrorZ_get_err(LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxCreationKeysDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelPublicKeys CResult_ChannelPublicKeysDecodeErrorZ_get_ok(LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelPublicKeysDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelPublicKeysDecodeErrorZ_get_err(LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelPublicKeysDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_u32Z {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_u32Z_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_u32Z_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_u32Z_Some_get_some(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_u32Z_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKHTLCOutputInCommitment CResult_HTLCOutputInCommitmentDecodeErrorZ_get_ok(LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_HTLCOutputInCommitmentDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_HTLCOutputInCommitmentDecodeErrorZ_get_err(LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_HTLCOutputInCommitmentDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_PaymentPreimageZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_PaymentPreimageZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_PaymentPreimageZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_PaymentPreimageZ_Some_get_some(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_PaymentPreimageZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCounterpartyChannelTransactionParameters CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_ok(LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_err(LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelTransactionParameters CResult_ChannelTransactionParametersDecodeErrorZ_get_ok(LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelTransactionParametersDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelTransactionParametersDecodeErrorZ_get_err(LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelTransactionParametersDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKHolderCommitmentTransaction CResult_HolderCommitmentTransactionDecodeErrorZ_get_ok(LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_HolderCommitmentTransactionDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_HolderCommitmentTransactionDecodeErrorZ_get_err(LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_HolderCommitmentTransactionDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKBuiltCommitmentTransaction CResult_BuiltCommitmentTransactionDecodeErrorZ_get_ok(LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BuiltCommitmentTransactionDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_BuiltCommitmentTransactionDecodeErrorZ_get_err(LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BuiltCommitmentTransactionDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTrustedClosingTransaction CResult_TrustedClosingTransactionNoneZ_get_ok(LDKCResult_TrustedClosingTransactionNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TrustedClosingTransactionNoneZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_TrustedClosingTransactionNoneZ_get_err(LDKCResult_TrustedClosingTransactionNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TrustedClosingTransactionNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKCommitmentTransaction CResult_CommitmentTransactionDecodeErrorZ_get_ok(LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CommitmentTransactionDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_CommitmentTransactionDecodeErrorZ_get_err(LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CommitmentTransactionDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTrustedCommitmentTransaction CResult_TrustedCommitmentTransactionNoneZ_get_ok(LDKCResult_TrustedCommitmentTransactionNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TrustedCommitmentTransactionNoneZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_TrustedCommitmentTransactionNoneZ_get_err(LDKCResult_TrustedCommitmentTransactionNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TrustedCommitmentTransactionNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKCVec_SignatureZ CResult_CVec_SignatureZNoneZ_get_ok(LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CVec_SignatureZNoneZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_CVec_SignatureZNoneZ_get_err(LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CVec_SignatureZNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKShutdownScript CResult_ShutdownScriptDecodeErrorZ_get_ok(LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ShutdownScriptDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ShutdownScriptDecodeErrorZ_get_err(LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ShutdownScriptDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKShutdownScript CResult_ShutdownScriptInvalidShutdownScriptZ_get_ok(LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ShutdownScriptInvalidShutdownScriptZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKInvalidShutdownScript CResult_ShutdownScriptInvalidShutdownScriptZ_get_err(LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ShutdownScriptInvalidShutdownScriptZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKBlindedPayInfo CResult_BlindedPayInfoDecodeErrorZ_get_ok(LDKCResult_BlindedPayInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BlindedPayInfoDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPayInfoDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_BlindedPayInfoDecodeErrorZ_get_err(LDKCResult_BlindedPayInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BlindedPayInfoDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPayInfoDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKDelayedPaymentOutputDescriptor CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_ok(LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_err(LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKStaticPaymentOutputDescriptor CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_ok(LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_err(LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKSpendableOutputDescriptor {
	protected constructor() {}
}
/* @internal */
export function LDKSpendableOutputDescriptor_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKSpendableOutputDescriptor_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKSpendableOutputDescriptor_StaticOutput_get_outpoint(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKSpendableOutputDescriptor_StaticOutput_get_outpoint(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKSpendableOutputDescriptor_StaticOutput_get_output(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKSpendableOutputDescriptor_StaticOutput_get_output(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKSpendableOutputDescriptor_DelayedPaymentOutput_get_delayed_payment_output(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKSpendableOutputDescriptor_DelayedPaymentOutput_get_delayed_payment_output(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKSpendableOutputDescriptor_StaticPaymentOutput_get_static_payment_output(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKSpendableOutputDescriptor_StaticPaymentOutput_get_static_payment_output(ptr);
	return nativeResponseValue;
}
	// struct LDKSpendableOutputDescriptor CResult_SpendableOutputDescriptorDecodeErrorZ_get_ok(LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SpendableOutputDescriptorDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_SpendableOutputDescriptorDecodeErrorZ_get_err(LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SpendableOutputDescriptorDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_PackedLockTimeZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_PackedLockTimeZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_PackedLockTimeZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_PackedLockTimeZ_Some_get_some(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_PackedLockTimeZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z C2Tuple_PartiallySignedTransactionusizeZ_get_a(LDKC2Tuple_PartiallySignedTransactionusizeZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_PartiallySignedTransactionusizeZ_get_a(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PartiallySignedTransactionusizeZ_get_a(owner);
	return nativeResponseValue;
}
	// uintptr_t C2Tuple_PartiallySignedTransactionusizeZ_get_b(LDKC2Tuple_PartiallySignedTransactionusizeZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_PartiallySignedTransactionusizeZ_get_b(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PartiallySignedTransactionusizeZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PartiallySignedTransactionusizeZ CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_get_ok(LDKCResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_get_err(LDKCResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKSignature C2Tuple_SignatureCVec_SignatureZZ_get_a(LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_SignatureCVec_SignatureZZ_get_a(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKCVec_SignatureZ C2Tuple_SignatureCVec_SignatureZZ_get_b(LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_SignatureCVec_SignatureZZ_get_b(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_SignatureCVec_SignatureZZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_ok(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_err(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKSignature CResult_SignatureNoneZ_get_ok(LDKCResult_SignatureNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SignatureNoneZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_SignatureNoneZ_get_err(LDKCResult_SignatureNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SignatureNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKPublicKey CResult_PublicKeyNoneZ_get_ok(LDKCResult_PublicKeyNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PublicKeyNoneZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_PublicKeyNoneZ_get_err(LDKCResult_PublicKeyNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PublicKeyNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyNoneZ_get_err(owner);
	// debug statements here
}
/* @internal */
export class LDKCOption_ScalarZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_ScalarZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_ScalarZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_ScalarZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_ScalarZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes CResult_SharedSecretNoneZ_get_ok(LDKCResult_SharedSecretNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SharedSecretNoneZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SharedSecretNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_SharedSecretNoneZ_get_err(LDKCResult_SharedSecretNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SharedSecretNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SharedSecretNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKRecoverableSignature CResult_RecoverableSignatureNoneZ_get_ok(LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RecoverableSignatureNoneZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_RecoverableSignatureNoneZ_get_err(LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RecoverableSignatureNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_get_err(owner);
	// debug statements here
}
/* @internal */
export interface LDKChannelSigner {
	get_per_commitment_point (idx: bigint): number;
	release_commitment_secret (idx: bigint): number;
	validate_holder_commitment (holder_tx: bigint, preimages: number): bigint;
	channel_keys_id (): number;
	provide_channel_parameters (channel_parameters: bigint): void;
}

/* @internal */
export function LDKChannelSigner_new(impl: LDKChannelSigner, pubkeys: bigint): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKChannelSigner_new(i, pubkeys), i];
}
	// LDKPublicKey ChannelSigner_get_per_commitment_point LDKChannelSigner *NONNULL_PTR this_arg, uint64_t idx
/* @internal */
export function ChannelSigner_get_per_commitment_point(this_arg: bigint, idx: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelSigner_get_per_commitment_point(this_arg, idx);
	return nativeResponseValue;
}
	// LDKThirtyTwoBytes ChannelSigner_release_commitment_secret LDKChannelSigner *NONNULL_PTR this_arg, uint64_t idx
/* @internal */
export function ChannelSigner_release_commitment_secret(this_arg: bigint, idx: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelSigner_release_commitment_secret(this_arg, idx);
	return nativeResponseValue;
}
	// LDKCResult_NoneNoneZ ChannelSigner_validate_holder_commitment LDKChannelSigner *NONNULL_PTR this_arg, const struct LDKHolderCommitmentTransaction *NONNULL_PTR holder_tx, struct LDKCVec_PaymentPreimageZ preimages
/* @internal */
export function ChannelSigner_validate_holder_commitment(this_arg: bigint, holder_tx: bigint, preimages: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelSigner_validate_holder_commitment(this_arg, holder_tx, preimages);
	return nativeResponseValue;
}
	// LDKThirtyTwoBytes ChannelSigner_channel_keys_id LDKChannelSigner *NONNULL_PTR this_arg
/* @internal */
export function ChannelSigner_channel_keys_id(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelSigner_channel_keys_id(this_arg);
	return nativeResponseValue;
}
	// void ChannelSigner_provide_channel_parameters LDKChannelSigner *NONNULL_PTR this_arg, const struct LDKChannelTransactionParameters *NONNULL_PTR channel_parameters
/* @internal */
export function ChannelSigner_provide_channel_parameters(this_arg: bigint, channel_parameters: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelSigner_provide_channel_parameters(this_arg, channel_parameters);
	// debug statements here
}
	// LDKChannelPublicKeys ChannelSigner_get_pubkeys LDKChannelSigner *NONNULL_PTR this_arg
/* @internal */
export function ChannelSigner_get_pubkeys(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelSigner_get_pubkeys(this_arg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKEcdsaChannelSigner {
	sign_counterparty_commitment (commitment_tx: bigint, preimages: number): bigint;
	validate_counterparty_revocation (idx: bigint, secret: number): bigint;
	sign_holder_commitment_and_htlcs (commitment_tx: bigint): bigint;
	sign_justice_revoked_output (justice_tx: number, input: number, amount: bigint, per_commitment_key: number): bigint;
	sign_justice_revoked_htlc (justice_tx: number, input: number, amount: bigint, per_commitment_key: number, htlc: bigint): bigint;
	sign_holder_htlc_transaction (htlc_tx: number, input: number, htlc_descriptor: bigint): bigint;
	sign_counterparty_htlc_transaction (htlc_tx: number, input: number, amount: bigint, per_commitment_point: number, htlc: bigint): bigint;
	sign_closing_transaction (closing_tx: bigint): bigint;
	sign_holder_anchor_input (anchor_tx: number, input: number): bigint;
	sign_channel_announcement_with_funding_key (msg: bigint): bigint;
}

/* @internal */
export function LDKEcdsaChannelSigner_new(impl: LDKEcdsaChannelSigner, ChannelSigner: number, pubkeys: bigint): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKEcdsaChannelSigner_new(i, ChannelSigner, pubkeys), i];
}
	// LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ EcdsaChannelSigner_sign_counterparty_commitment LDKEcdsaChannelSigner *NONNULL_PTR this_arg, const struct LDKCommitmentTransaction *NONNULL_PTR commitment_tx, struct LDKCVec_PaymentPreimageZ preimages
/* @internal */
export function EcdsaChannelSigner_sign_counterparty_commitment(this_arg: bigint, commitment_tx: bigint, preimages: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EcdsaChannelSigner_sign_counterparty_commitment(this_arg, commitment_tx, preimages);
	return nativeResponseValue;
}
	// LDKCResult_NoneNoneZ EcdsaChannelSigner_validate_counterparty_revocation LDKEcdsaChannelSigner *NONNULL_PTR this_arg, uint64_t idx, const uint8_t (*secret)[32]
/* @internal */
export function EcdsaChannelSigner_validate_counterparty_revocation(this_arg: bigint, idx: bigint, secret: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EcdsaChannelSigner_validate_counterparty_revocation(this_arg, idx, secret);
	return nativeResponseValue;
}
	// LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ EcdsaChannelSigner_sign_holder_commitment_and_htlcs LDKEcdsaChannelSigner *NONNULL_PTR this_arg, const struct LDKHolderCommitmentTransaction *NONNULL_PTR commitment_tx
/* @internal */
export function EcdsaChannelSigner_sign_holder_commitment_and_htlcs(this_arg: bigint, commitment_tx: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EcdsaChannelSigner_sign_holder_commitment_and_htlcs(this_arg, commitment_tx);
	return nativeResponseValue;
}
	// LDKCResult_SignatureNoneZ EcdsaChannelSigner_sign_justice_revoked_output LDKEcdsaChannelSigner *NONNULL_PTR this_arg, struct LDKTransaction justice_tx, uintptr_t input, uint64_t amount, const uint8_t (*per_commitment_key)[32]
/* @internal */
export function EcdsaChannelSigner_sign_justice_revoked_output(this_arg: bigint, justice_tx: number, input: number, amount: bigint, per_commitment_key: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EcdsaChannelSigner_sign_justice_revoked_output(this_arg, justice_tx, input, amount, per_commitment_key);
	return nativeResponseValue;
}
	// LDKCResult_SignatureNoneZ EcdsaChannelSigner_sign_justice_revoked_htlc LDKEcdsaChannelSigner *NONNULL_PTR this_arg, struct LDKTransaction justice_tx, uintptr_t input, uint64_t amount, const uint8_t (*per_commitment_key)[32], const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc
/* @internal */
export function EcdsaChannelSigner_sign_justice_revoked_htlc(this_arg: bigint, justice_tx: number, input: number, amount: bigint, per_commitment_key: number, htlc: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EcdsaChannelSigner_sign_justice_revoked_htlc(this_arg, justice_tx, input, amount, per_commitment_key, htlc);
	return nativeResponseValue;
}
	// LDKCResult_SignatureNoneZ EcdsaChannelSigner_sign_holder_htlc_transaction LDKEcdsaChannelSigner *NONNULL_PTR this_arg, struct LDKTransaction htlc_tx, uintptr_t input, const struct LDKHTLCDescriptor *NONNULL_PTR htlc_descriptor
/* @internal */
export function EcdsaChannelSigner_sign_holder_htlc_transaction(this_arg: bigint, htlc_tx: number, input: number, htlc_descriptor: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EcdsaChannelSigner_sign_holder_htlc_transaction(this_arg, htlc_tx, input, htlc_descriptor);
	return nativeResponseValue;
}
	// LDKCResult_SignatureNoneZ EcdsaChannelSigner_sign_counterparty_htlc_transaction LDKEcdsaChannelSigner *NONNULL_PTR this_arg, struct LDKTransaction htlc_tx, uintptr_t input, uint64_t amount, struct LDKPublicKey per_commitment_point, const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc
/* @internal */
export function EcdsaChannelSigner_sign_counterparty_htlc_transaction(this_arg: bigint, htlc_tx: number, input: number, amount: bigint, per_commitment_point: number, htlc: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EcdsaChannelSigner_sign_counterparty_htlc_transaction(this_arg, htlc_tx, input, amount, per_commitment_point, htlc);
	return nativeResponseValue;
}
	// LDKCResult_SignatureNoneZ EcdsaChannelSigner_sign_closing_transaction LDKEcdsaChannelSigner *NONNULL_PTR this_arg, const struct LDKClosingTransaction *NONNULL_PTR closing_tx
/* @internal */
export function EcdsaChannelSigner_sign_closing_transaction(this_arg: bigint, closing_tx: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EcdsaChannelSigner_sign_closing_transaction(this_arg, closing_tx);
	return nativeResponseValue;
}
	// LDKCResult_SignatureNoneZ EcdsaChannelSigner_sign_holder_anchor_input LDKEcdsaChannelSigner *NONNULL_PTR this_arg, struct LDKTransaction anchor_tx, uintptr_t input
/* @internal */
export function EcdsaChannelSigner_sign_holder_anchor_input(this_arg: bigint, anchor_tx: number, input: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EcdsaChannelSigner_sign_holder_anchor_input(this_arg, anchor_tx, input);
	return nativeResponseValue;
}
	// LDKCResult_SignatureNoneZ EcdsaChannelSigner_sign_channel_announcement_with_funding_key LDKEcdsaChannelSigner *NONNULL_PTR this_arg, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR msg
/* @internal */
export function EcdsaChannelSigner_sign_channel_announcement_with_funding_key(this_arg: bigint, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EcdsaChannelSigner_sign_channel_announcement_with_funding_key(this_arg, msg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKWriteableEcdsaChannelSigner {
	write (): number;
}

/* @internal */
export function LDKWriteableEcdsaChannelSigner_new(impl: LDKWriteableEcdsaChannelSigner, EcdsaChannelSigner: number, ChannelSigner: number, pubkeys: bigint): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKWriteableEcdsaChannelSigner_new(i, EcdsaChannelSigner, ChannelSigner, pubkeys), i];
}
	// LDKCVec_u8Z WriteableEcdsaChannelSigner_write LDKWriteableEcdsaChannelSigner *NONNULL_PTR this_arg
/* @internal */
export function WriteableEcdsaChannelSigner_write(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WriteableEcdsaChannelSigner_write(this_arg);
	return nativeResponseValue;
}
	// struct LDKWriteableEcdsaChannelSigner CResult_WriteableEcdsaChannelSignerDecodeErrorZ_get_ok(LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_WriteableEcdsaChannelSignerDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WriteableEcdsaChannelSignerDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_WriteableEcdsaChannelSignerDecodeErrorZ_get_err(LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_WriteableEcdsaChannelSignerDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WriteableEcdsaChannelSignerDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z CResult_ScriptNoneZ_get_ok(LDKCResult_ScriptNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ScriptNoneZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScriptNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_ScriptNoneZ_get_err(LDKCResult_ScriptNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ScriptNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScriptNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKShutdownScript CResult_ShutdownScriptNoneZ_get_ok(LDKCResult_ShutdownScriptNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ShutdownScriptNoneZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_ShutdownScriptNoneZ_get_err(LDKCResult_ShutdownScriptNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ShutdownScriptNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKCVec_CVec_u8ZZ CResult_CVec_CVec_u8ZZNoneZ_get_ok(LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CVec_CVec_u8ZZNoneZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_CVec_CVec_u8ZZNoneZ_get_err(LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CVec_CVec_u8ZZNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKInMemorySigner CResult_InMemorySignerDecodeErrorZ_get_ok(LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InMemorySignerDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_InMemorySignerDecodeErrorZ_get_err(LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InMemorySignerDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z CResult_PartiallySignedTransactionNoneZ_get_ok(LDKCResult_PartiallySignedTransactionNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PartiallySignedTransactionNoneZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PartiallySignedTransactionNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_PartiallySignedTransactionNoneZ_get_err(LDKCResult_PartiallySignedTransactionNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PartiallySignedTransactionNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PartiallySignedTransactionNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKTransaction CResult_TransactionNoneZ_get_ok(LDKCResult_TransactionNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TransactionNoneZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_TransactionNoneZ_get_err(LDKCResult_TransactionNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TransactionNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKRoute CResult_RouteLightningErrorZ_get_ok(LDKCResult_RouteLightningErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteLightningErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKLightningError CResult_RouteLightningErrorZ_get_err(LDKCResult_RouteLightningErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteLightningErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKInFlightHtlcs CResult_InFlightHtlcsDecodeErrorZ_get_ok(LDKCResult_InFlightHtlcsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InFlightHtlcsDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InFlightHtlcsDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_InFlightHtlcsDecodeErrorZ_get_err(LDKCResult_InFlightHtlcsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InFlightHtlcsDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InFlightHtlcsDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKRouteHop CResult_RouteHopDecodeErrorZ_get_ok(LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteHopDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_RouteHopDecodeErrorZ_get_err(LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteHopDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKBlindedTail CResult_BlindedTailDecodeErrorZ_get_ok(LDKCResult_BlindedTailDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BlindedTailDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedTailDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_BlindedTailDecodeErrorZ_get_err(LDKCResult_BlindedTailDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BlindedTailDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedTailDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKRoute CResult_RouteDecodeErrorZ_get_ok(LDKCResult_RouteDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_RouteDecodeErrorZ_get_err(LDKCResult_RouteDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKRouteParameters CResult_RouteParametersDecodeErrorZ_get_ok(LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteParametersDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_RouteParametersDecodeErrorZ_get_err(LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteParametersDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKPaymentParameters CResult_PaymentParametersDecodeErrorZ_get_ok(LDKCResult_PaymentParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentParametersDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentParametersDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_PaymentParametersDecodeErrorZ_get_err(LDKCResult_PaymentParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentParametersDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentParametersDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKBlindedPayInfo C2Tuple_BlindedPayInfoBlindedPathZ_get_a(LDKC2Tuple_BlindedPayInfoBlindedPathZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_BlindedPayInfoBlindedPathZ_get_a(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlindedPayInfoBlindedPathZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKBlindedPath C2Tuple_BlindedPayInfoBlindedPathZ_get_b(LDKC2Tuple_BlindedPayInfoBlindedPathZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_BlindedPayInfoBlindedPathZ_get_b(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlindedPayInfoBlindedPathZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKRouteHint CResult_RouteHintDecodeErrorZ_get_ok(LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteHintDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_RouteHintDecodeErrorZ_get_err(LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteHintDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKRouteHintHop CResult_RouteHintHopDecodeErrorZ_get_ok(LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteHintHopDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_RouteHintHopDecodeErrorZ_get_err(LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteHintHopDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// uintptr_t C2Tuple_usizeTransactionZ_get_a(LDKC2Tuple_usizeTransactionZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_usizeTransactionZ_get_a(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKTransaction C2Tuple_usizeTransactionZ_get_b(LDKC2Tuple_usizeTransactionZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_usizeTransactionZ_get_b(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_get_b(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_BlockHashZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_BlockHashZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_BlockHashZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_BlockHashZ_Some_get_some(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_BlockHashZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C2Tuple_TxidCOption_BlockHashZZ_get_a(LDKC2Tuple_TxidCOption_BlockHashZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_TxidCOption_BlockHashZZ_get_a(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCOption_BlockHashZZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKCOption_BlockHashZ C2Tuple_TxidCOption_BlockHashZZ_get_b(LDKC2Tuple_TxidCOption_BlockHashZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_TxidCOption_BlockHashZZ_get_b(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCOption_BlockHashZZ_get_b(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKMonitorEvent {
	protected constructor() {}
}
/* @internal */
export function LDKMonitorEvent_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMonitorEvent_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMonitorEvent_HTLCEvent_get_htlc_event(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMonitorEvent_HTLCEvent_get_htlc_event(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMonitorEvent_CommitmentTxConfirmed_get_commitment_tx_confirmed(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMonitorEvent_CommitmentTxConfirmed_get_commitment_tx_confirmed(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMonitorEvent_Completed_get_funding_txo(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMonitorEvent_Completed_get_funding_txo(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMonitorEvent_Completed_get_monitor_update_id(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMonitorEvent_Completed_get_monitor_update_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMonitorEvent_UpdateFailed_get_update_failed(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMonitorEvent_UpdateFailed_get_update_failed(ptr);
	return nativeResponseValue;
}
	// struct LDKOutPoint C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_get_a(LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ *NONNULL_PTR owner);
/* @internal */
export function C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_get_a(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKCVec_MonitorEventZ C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_get_b(LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ *NONNULL_PTR owner);
/* @internal */
export function C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_get_b(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKPublicKey C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_get_c(LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ *NONNULL_PTR owner);
/* @internal */
export function C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_get_c(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_get_c(owner);
	return nativeResponseValue;
}
	// struct LDKFixedPenaltyScorer CResult_FixedPenaltyScorerDecodeErrorZ_get_ok(LDKCResult_FixedPenaltyScorerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_FixedPenaltyScorerDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FixedPenaltyScorerDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_FixedPenaltyScorerDecodeErrorZ_get_err(LDKCResult_FixedPenaltyScorerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_FixedPenaltyScorerDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FixedPenaltyScorerDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// uint64_t C2Tuple_u64u64Z_get_a(LDKC2Tuple_u64u64Z *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_u64u64Z_get_a(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u64u64Z_get_a(owner);
	return nativeResponseValue;
}
	// uint64_t C2Tuple_u64u64Z_get_b(LDKC2Tuple_u64u64Z *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_u64u64Z_get_b(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u64u64Z_get_b(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_C2Tuple_u64u64ZZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_C2Tuple_u64u64ZZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_C2Tuple_u64u64ZZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_C2Tuple_u64u64ZZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_C2Tuple_u64u64ZZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKEightU16s C2Tuple_Z_get_a(LDKC2Tuple_Z *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_Z_get_a(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_Z_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKEightU16s C2Tuple_Z_get_b(LDKC2Tuple_Z *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_Z_get_b(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_Z_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKEightU16s C2Tuple__u168_u168Z_get_a(LDKC2Tuple__u168_u168Z *NONNULL_PTR owner);
/* @internal */
export function C2Tuple__u168_u168Z_get_a(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple__u168_u168Z_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKEightU16s C2Tuple__u168_u168Z_get_b(LDKC2Tuple__u168_u168Z *NONNULL_PTR owner);
/* @internal */
export function C2Tuple__u168_u168Z_get_b(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple__u168_u168Z_get_b(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_C2Tuple_EightU16sEightU16sZZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_C2Tuple_EightU16sEightU16sZZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_C2Tuple_EightU16sEightU16sZZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_C2Tuple_EightU16sEightU16sZZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_C2Tuple_EightU16sEightU16sZZ_Some_get_some(ptr);
	return nativeResponseValue;
}
/* @internal */
export interface LDKLogger {
	log (record: bigint): void;
}

/* @internal */
export function LDKLogger_new(impl: LDKLogger): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKLogger_new(i), i];
}
	// struct LDKProbabilisticScorer CResult_ProbabilisticScorerDecodeErrorZ_get_ok(LDKCResult_ProbabilisticScorerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ProbabilisticScorerDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ProbabilisticScorerDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ProbabilisticScorerDecodeErrorZ_get_err(LDKCResult_ProbabilisticScorerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ProbabilisticScorerDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ProbabilisticScorerDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKInitFeatures CResult_InitFeaturesDecodeErrorZ_get_ok(LDKCResult_InitFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InitFeaturesDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_InitFeaturesDecodeErrorZ_get_err(LDKCResult_InitFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InitFeaturesDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelFeatures CResult_ChannelFeaturesDecodeErrorZ_get_ok(LDKCResult_ChannelFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelFeaturesDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelFeaturesDecodeErrorZ_get_err(LDKCResult_ChannelFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelFeaturesDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKNodeFeatures CResult_NodeFeaturesDecodeErrorZ_get_ok(LDKCResult_NodeFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeFeaturesDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_NodeFeaturesDecodeErrorZ_get_err(LDKCResult_NodeFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeFeaturesDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKBolt11InvoiceFeatures CResult_Bolt11InvoiceFeaturesDecodeErrorZ_get_ok(LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_Bolt11InvoiceFeaturesDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceFeaturesDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_Bolt11InvoiceFeaturesDecodeErrorZ_get_err(LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_Bolt11InvoiceFeaturesDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceFeaturesDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKBolt12InvoiceFeatures CResult_Bolt12InvoiceFeaturesDecodeErrorZ_get_ok(LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_Bolt12InvoiceFeaturesDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt12InvoiceFeaturesDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_Bolt12InvoiceFeaturesDecodeErrorZ_get_err(LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_Bolt12InvoiceFeaturesDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt12InvoiceFeaturesDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKBlindedHopFeatures CResult_BlindedHopFeaturesDecodeErrorZ_get_ok(LDKCResult_BlindedHopFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BlindedHopFeaturesDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedHopFeaturesDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_BlindedHopFeaturesDecodeErrorZ_get_err(LDKCResult_BlindedHopFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BlindedHopFeaturesDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedHopFeaturesDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelTypeFeatures CResult_ChannelTypeFeaturesDecodeErrorZ_get_ok(LDKCResult_ChannelTypeFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelTypeFeaturesDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelTypeFeaturesDecodeErrorZ_get_err(LDKCResult_ChannelTypeFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelTypeFeaturesDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKPaymentPurpose {
	protected constructor() {}
}
/* @internal */
export function LDKPaymentPurpose_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentPurpose_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentPurpose_InvoicePayment_get_payment_preimage(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentPurpose_InvoicePayment_get_payment_preimage(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentPurpose_InvoicePayment_get_payment_secret(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentPurpose_InvoicePayment_get_payment_secret(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentPurpose_SpontaneousPayment_get_spontaneous_payment(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentPurpose_SpontaneousPayment_get_spontaneous_payment(ptr);
	return nativeResponseValue;
}
	// struct LDKPaymentPurpose CResult_PaymentPurposeDecodeErrorZ_get_ok(LDKCResult_PaymentPurposeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentPurposeDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPurposeDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_PaymentPurposeDecodeErrorZ_get_err(LDKCResult_PaymentPurposeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentPurposeDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPurposeDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKNetworkUpdate {
	protected constructor() {}
}
/* @internal */
export function LDKNetworkUpdate_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetworkUpdate_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetworkUpdate_ChannelUpdateMessage_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetworkUpdate_ChannelUpdateMessage_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetworkUpdate_ChannelFailure_get_short_channel_id(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetworkUpdate_ChannelFailure_get_short_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetworkUpdate_ChannelFailure_get_is_permanent(ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetworkUpdate_ChannelFailure_get_is_permanent(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetworkUpdate_NodeFailure_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetworkUpdate_NodeFailure_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetworkUpdate_NodeFailure_get_is_permanent(ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetworkUpdate_NodeFailure_get_is_permanent(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_NetworkUpdateZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_NetworkUpdateZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_NetworkUpdateZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_NetworkUpdateZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_NetworkUpdateZ_Some_get_some(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKPathFailure {
	protected constructor() {}
}
/* @internal */
export function LDKPathFailure_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPathFailure_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPathFailure_InitialSend_get_err(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPathFailure_InitialSend_get_err(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPathFailure_OnPath_get_network_update(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPathFailure_OnPath_get_network_update(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_PathFailureZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_PathFailureZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_PathFailureZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_PathFailureZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_PathFailureZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCOption_PathFailureZ CResult_COption_PathFailureZDecodeErrorZ_get_ok(LDKCResult_COption_PathFailureZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_PathFailureZDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_PathFailureZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_COption_PathFailureZDecodeErrorZ_get_err(LDKCResult_COption_PathFailureZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_PathFailureZDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_PathFailureZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKClosureReason {
	protected constructor() {}
}
/* @internal */
export function LDKClosureReason_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKClosureReason_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKClosureReason_CounterpartyForceClosed_get_peer_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKClosureReason_CounterpartyForceClosed_get_peer_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKClosureReason_ProcessingError_get_err(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKClosureReason_ProcessingError_get_err(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_ClosureReasonZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_ClosureReasonZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_ClosureReasonZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_ClosureReasonZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_ClosureReasonZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCOption_ClosureReasonZ CResult_COption_ClosureReasonZDecodeErrorZ_get_ok(LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_ClosureReasonZDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_COption_ClosureReasonZDecodeErrorZ_get_err(LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_ClosureReasonZDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKHTLCDestination {
	protected constructor() {}
}
/* @internal */
export function LDKHTLCDestination_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKHTLCDestination_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKHTLCDestination_NextHopChannel_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKHTLCDestination_NextHopChannel_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKHTLCDestination_NextHopChannel_get_channel_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKHTLCDestination_NextHopChannel_get_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKHTLCDestination_UnknownNextHop_get_requested_forward_scid(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKHTLCDestination_UnknownNextHop_get_requested_forward_scid(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKHTLCDestination_InvalidForward_get_requested_forward_scid(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKHTLCDestination_InvalidForward_get_requested_forward_scid(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKHTLCDestination_FailedPayment_get_payment_hash(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKHTLCDestination_FailedPayment_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_HTLCDestinationZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_HTLCDestinationZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_HTLCDestinationZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_HTLCDestinationZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_HTLCDestinationZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCOption_HTLCDestinationZ CResult_COption_HTLCDestinationZDecodeErrorZ_get_ok(LDKCResult_COption_HTLCDestinationZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_HTLCDestinationZDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_HTLCDestinationZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_COption_HTLCDestinationZDecodeErrorZ_get_err(LDKCResult_COption_HTLCDestinationZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_HTLCDestinationZDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_HTLCDestinationZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// enum LDKPaymentFailureReason CResult_PaymentFailureReasonDecodeErrorZ_get_ok(LDKCResult_PaymentFailureReasonDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentFailureReasonDecodeErrorZ_get_ok(owner: bigint): PaymentFailureReason {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentFailureReasonDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_PaymentFailureReasonDecodeErrorZ_get_err(LDKCResult_PaymentFailureReasonDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentFailureReasonDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentFailureReasonDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_u128Z {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_u128Z_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_u128Z_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_u128Z_Some_get_some(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_u128Z_Some_get_some(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_PaymentIdZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_PaymentIdZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_PaymentIdZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_PaymentIdZ_Some_get_some(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_PaymentIdZ_Some_get_some(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_PaymentFailureReasonZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_PaymentFailureReasonZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_PaymentFailureReasonZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_PaymentFailureReasonZ_Some_get_some(ptr: bigint): PaymentFailureReason {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_PaymentFailureReasonZ_Some_get_some(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_PaymentHashZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_PaymentHashZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_PaymentHashZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_PaymentHashZ_Some_get_some(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_PaymentHashZ_Some_get_some(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKBumpTransactionEvent {
	protected constructor() {}
}
/* @internal */
export function LDKBumpTransactionEvent_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBumpTransactionEvent_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBumpTransactionEvent_ChannelClose_get_claim_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBumpTransactionEvent_ChannelClose_get_claim_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBumpTransactionEvent_ChannelClose_get_package_target_feerate_sat_per_1000_weight(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBumpTransactionEvent_ChannelClose_get_package_target_feerate_sat_per_1000_weight(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBumpTransactionEvent_ChannelClose_get_commitment_tx(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBumpTransactionEvent_ChannelClose_get_commitment_tx(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBumpTransactionEvent_ChannelClose_get_commitment_tx_fee_satoshis(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBumpTransactionEvent_ChannelClose_get_commitment_tx_fee_satoshis(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBumpTransactionEvent_ChannelClose_get_anchor_descriptor(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBumpTransactionEvent_ChannelClose_get_anchor_descriptor(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBumpTransactionEvent_ChannelClose_get_pending_htlcs(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBumpTransactionEvent_ChannelClose_get_pending_htlcs(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBumpTransactionEvent_HTLCResolution_get_claim_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBumpTransactionEvent_HTLCResolution_get_claim_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBumpTransactionEvent_HTLCResolution_get_target_feerate_sat_per_1000_weight(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBumpTransactionEvent_HTLCResolution_get_target_feerate_sat_per_1000_weight(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBumpTransactionEvent_HTLCResolution_get_htlc_descriptors(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBumpTransactionEvent_HTLCResolution_get_htlc_descriptors(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBumpTransactionEvent_HTLCResolution_get_tx_lock_time(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBumpTransactionEvent_HTLCResolution_get_tx_lock_time(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKEvent {
	protected constructor() {}
}
/* @internal */
export function LDKEvent_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_FundingGenerationReady_get_temporary_channel_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_FundingGenerationReady_get_temporary_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_FundingGenerationReady_get_counterparty_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_FundingGenerationReady_get_counterparty_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_FundingGenerationReady_get_channel_value_satoshis(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_FundingGenerationReady_get_channel_value_satoshis(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_FundingGenerationReady_get_output_script(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_FundingGenerationReady_get_output_script(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_FundingGenerationReady_get_user_channel_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_FundingGenerationReady_get_user_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentClaimable_get_receiver_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentClaimable_get_receiver_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentClaimable_get_payment_hash(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentClaimable_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentClaimable_get_onion_fields(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentClaimable_get_onion_fields(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentClaimable_get_amount_msat(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentClaimable_get_amount_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentClaimable_get_counterparty_skimmed_fee_msat(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentClaimable_get_counterparty_skimmed_fee_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentClaimable_get_purpose(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentClaimable_get_purpose(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentClaimable_get_via_channel_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentClaimable_get_via_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentClaimable_get_via_user_channel_id(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentClaimable_get_via_user_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentClaimable_get_claim_deadline(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentClaimable_get_claim_deadline(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentClaimed_get_receiver_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentClaimed_get_receiver_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentClaimed_get_payment_hash(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentClaimed_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentClaimed_get_amount_msat(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentClaimed_get_amount_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentClaimed_get_purpose(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentClaimed_get_purpose(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentSent_get_payment_id(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentSent_get_payment_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentSent_get_payment_preimage(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentSent_get_payment_preimage(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentSent_get_payment_hash(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentSent_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentSent_get_fee_paid_msat(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentSent_get_fee_paid_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentFailed_get_payment_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentFailed_get_payment_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentFailed_get_payment_hash(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentFailed_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentFailed_get_reason(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentFailed_get_reason(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathSuccessful_get_payment_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathSuccessful_get_payment_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathSuccessful_get_payment_hash(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathSuccessful_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathSuccessful_get_path(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathSuccessful_get_path(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathFailed_get_payment_id(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_payment_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathFailed_get_payment_hash(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathFailed_get_payment_failed_permanently(ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_payment_failed_permanently(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathFailed_get_failure(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_failure(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathFailed_get_path(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_path(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathFailed_get_short_channel_id(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_short_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ProbeSuccessful_get_payment_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ProbeSuccessful_get_payment_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ProbeSuccessful_get_payment_hash(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ProbeSuccessful_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ProbeSuccessful_get_path(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ProbeSuccessful_get_path(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ProbeFailed_get_payment_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ProbeFailed_get_payment_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ProbeFailed_get_payment_hash(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ProbeFailed_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ProbeFailed_get_path(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ProbeFailed_get_path(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ProbeFailed_get_short_channel_id(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ProbeFailed_get_short_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PendingHTLCsForwardable_get_time_forwardable(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PendingHTLCsForwardable_get_time_forwardable(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_HTLCIntercepted_get_intercept_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_HTLCIntercepted_get_intercept_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_HTLCIntercepted_get_requested_next_hop_scid(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_HTLCIntercepted_get_requested_next_hop_scid(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_HTLCIntercepted_get_payment_hash(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_HTLCIntercepted_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_HTLCIntercepted_get_inbound_amount_msat(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_HTLCIntercepted_get_inbound_amount_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_HTLCIntercepted_get_expected_outbound_amount_msat(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_HTLCIntercepted_get_expected_outbound_amount_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_SpendableOutputs_get_outputs(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_SpendableOutputs_get_outputs(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentForwarded_get_prev_channel_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentForwarded_get_prev_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentForwarded_get_next_channel_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentForwarded_get_next_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentForwarded_get_fee_earned_msat(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentForwarded_get_fee_earned_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentForwarded_get_claim_from_onchain_tx(ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentForwarded_get_claim_from_onchain_tx(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentForwarded_get_outbound_amount_forwarded_msat(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentForwarded_get_outbound_amount_forwarded_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ChannelPending_get_channel_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ChannelPending_get_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ChannelPending_get_user_channel_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ChannelPending_get_user_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ChannelPending_get_former_temporary_channel_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ChannelPending_get_former_temporary_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ChannelPending_get_counterparty_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ChannelPending_get_counterparty_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ChannelPending_get_funding_txo(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ChannelPending_get_funding_txo(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ChannelReady_get_channel_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ChannelReady_get_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ChannelReady_get_user_channel_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ChannelReady_get_user_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ChannelReady_get_counterparty_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ChannelReady_get_counterparty_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ChannelReady_get_channel_type(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ChannelReady_get_channel_type(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ChannelClosed_get_channel_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ChannelClosed_get_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ChannelClosed_get_user_channel_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ChannelClosed_get_user_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ChannelClosed_get_reason(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ChannelClosed_get_reason(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_DiscardFunding_get_channel_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_DiscardFunding_get_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_DiscardFunding_get_transaction(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_DiscardFunding_get_transaction(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_OpenChannelRequest_get_temporary_channel_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_OpenChannelRequest_get_temporary_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_OpenChannelRequest_get_counterparty_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_OpenChannelRequest_get_counterparty_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_OpenChannelRequest_get_funding_satoshis(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_OpenChannelRequest_get_funding_satoshis(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_OpenChannelRequest_get_push_msat(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_OpenChannelRequest_get_push_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_OpenChannelRequest_get_channel_type(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_OpenChannelRequest_get_channel_type(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_HTLCHandlingFailed_get_prev_channel_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_HTLCHandlingFailed_get_prev_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_HTLCHandlingFailed_get_failed_next_destination(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_HTLCHandlingFailed_get_failed_next_destination(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_BumpTransaction_get_bump_transaction(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_BumpTransaction_get_bump_transaction(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_EventZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_EventZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_EventZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_EventZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_EventZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCOption_EventZ CResult_COption_EventZDecodeErrorZ_get_ok(LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_EventZDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_COption_EventZDecodeErrorZ_get_err(LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_EventZDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKErrorAction {
	protected constructor() {}
}
/* @internal */
export function LDKErrorAction_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKErrorAction_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKErrorAction_DisconnectPeer_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKErrorAction_DisconnectPeer_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKErrorAction_DisconnectPeerWithWarning_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKErrorAction_DisconnectPeerWithWarning_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKErrorAction_IgnoreAndLog_get_ignore_and_log(ptr: bigint): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKErrorAction_IgnoreAndLog_get_ignore_and_log(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKErrorAction_SendErrorMessage_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKErrorAction_SendErrorMessage_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKErrorAction_SendWarningMessage_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKErrorAction_SendWarningMessage_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKErrorAction_SendWarningMessage_get_log_level(ptr: bigint): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKErrorAction_SendWarningMessage_get_log_level(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKMessageSendEvent {
	protected constructor() {}
}
/* @internal */
export function LDKMessageSendEvent_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendAcceptChannel_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendAcceptChannel_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendAcceptChannel_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendAcceptChannel_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendAcceptChannelV2_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendAcceptChannelV2_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendAcceptChannelV2_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendAcceptChannelV2_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendOpenChannel_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendOpenChannel_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendOpenChannel_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendOpenChannel_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendOpenChannelV2_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendOpenChannelV2_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendOpenChannelV2_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendOpenChannelV2_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendFundingCreated_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendFundingCreated_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendFundingCreated_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendFundingCreated_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendFundingSigned_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendFundingSigned_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendFundingSigned_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendFundingSigned_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxAddInput_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxAddInput_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxAddInput_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxAddInput_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxAddOutput_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxAddOutput_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxAddOutput_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxAddOutput_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxRemoveInput_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxRemoveInput_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxRemoveInput_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxRemoveInput_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxRemoveOutput_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxRemoveOutput_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxRemoveOutput_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxRemoveOutput_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxComplete_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxComplete_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxComplete_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxComplete_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxSignatures_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxSignatures_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxSignatures_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxSignatures_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxInitRbf_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxInitRbf_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxInitRbf_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxInitRbf_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxAckRbf_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxAckRbf_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxAckRbf_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxAckRbf_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxAbort_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxAbort_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendTxAbort_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendTxAbort_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendChannelReady_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelReady_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendChannelReady_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelReady_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendAnnouncementSignatures_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendAnnouncementSignatures_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendAnnouncementSignatures_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendAnnouncementSignatures_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_UpdateHTLCs_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_UpdateHTLCs_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_UpdateHTLCs_get_updates(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_UpdateHTLCs_get_updates(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendRevokeAndACK_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendRevokeAndACK_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendRevokeAndACK_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendRevokeAndACK_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendClosingSigned_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendClosingSigned_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendClosingSigned_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendClosingSigned_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendShutdown_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendShutdown_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendShutdown_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendShutdown_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendChannelReestablish_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelReestablish_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendChannelReestablish_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelReestablish_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendChannelAnnouncement_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelAnnouncement_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendChannelAnnouncement_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelAnnouncement_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendChannelAnnouncement_get_update_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelAnnouncement_get_update_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_BroadcastChannelAnnouncement_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_BroadcastChannelAnnouncement_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_BroadcastChannelAnnouncement_get_update_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_BroadcastChannelAnnouncement_get_update_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_BroadcastChannelUpdate_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_BroadcastChannelUpdate_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_BroadcastNodeAnnouncement_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_BroadcastNodeAnnouncement_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendChannelUpdate_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelUpdate_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendChannelUpdate_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelUpdate_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_HandleError_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_HandleError_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_HandleError_get_action(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_HandleError_get_action(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendChannelRangeQuery_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelRangeQuery_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendChannelRangeQuery_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelRangeQuery_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendShortIdsQuery_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendShortIdsQuery_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendShortIdsQuery_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendShortIdsQuery_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendReplyChannelRange_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendReplyChannelRange_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendReplyChannelRange_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendReplyChannelRange_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendGossipTimestampFilter_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendGossipTimestampFilter_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendGossipTimestampFilter_get_msg(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendGossipTimestampFilter_get_msg(ptr);
	return nativeResponseValue;
}
	// struct LDKOffer CResult_OfferBolt12ParseErrorZ_get_ok(LDKCResult_OfferBolt12ParseErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OfferBolt12ParseErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OfferBolt12ParseErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKBolt12ParseError CResult_OfferBolt12ParseErrorZ_get_err(LDKCResult_OfferBolt12ParseErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OfferBolt12ParseErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OfferBolt12ParseErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKPublicKey CResult_PublicKeyErrorZ_get_ok(LDKCResult_PublicKeyErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PublicKeyErrorZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKSecp256k1Error CResult_PublicKeyErrorZ_get_err(LDKCResult_PublicKeyErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PublicKeyErrorZ_get_err(owner: bigint): Secp256k1Error {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKNodeId CResult_NodeIdDecodeErrorZ_get_ok(LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeIdDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_NodeIdDecodeErrorZ_get_err(LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeIdDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKCOption_NetworkUpdateZ CResult_COption_NetworkUpdateZDecodeErrorZ_get_ok(LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_NetworkUpdateZDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_COption_NetworkUpdateZDecodeErrorZ_get_err(LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_NetworkUpdateZDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTxOut CResult_TxOutUtxoLookupErrorZ_get_ok(LDKCResult_TxOutUtxoLookupErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxOutUtxoLookupErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxOutUtxoLookupErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKUtxoLookupError CResult_TxOutUtxoLookupErrorZ_get_err(LDKCResult_TxOutUtxoLookupErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxOutUtxoLookupErrorZ_get_err(owner: bigint): UtxoLookupError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxOutUtxoLookupErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKUtxoResult {
	protected constructor() {}
}
/* @internal */
export function LDKUtxoResult_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKUtxoResult_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKUtxoResult_Sync_get_sync(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKUtxoResult_Sync_get_sync(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKUtxoResult_Async_get_async(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKUtxoResult_Async_get_async(ptr);
	return nativeResponseValue;
}
/* @internal */
export interface LDKUtxoLookup {
	get_utxo (genesis_hash: number, short_channel_id: bigint): bigint;
}

/* @internal */
export function LDKUtxoLookup_new(impl: LDKUtxoLookup): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKUtxoLookup_new(i), i];
}
	// LDKUtxoResult UtxoLookup_get_utxo LDKUtxoLookup *NONNULL_PTR this_arg, const uint8_t (*genesis_hash)[32], uint64_t short_channel_id
/* @internal */
export function UtxoLookup_get_utxo(this_arg: bigint, genesis_hash: number, short_channel_id: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UtxoLookup_get_utxo(this_arg, genesis_hash, short_channel_id);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_UtxoLookupZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_UtxoLookupZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_UtxoLookupZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_UtxoLookupZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_UtxoLookupZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// void CResult_NoneLightningErrorZ_get_ok(LDKCResult_NoneLightningErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneLightningErrorZ_get_ok(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_get_ok(owner);
	// debug statements here
}
	// struct LDKLightningError CResult_NoneLightningErrorZ_get_err(LDKCResult_NoneLightningErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneLightningErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// bool CResult_boolLightningErrorZ_get_ok(LDKCResult_boolLightningErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_boolLightningErrorZ_get_ok(owner: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKLightningError CResult_boolLightningErrorZ_get_err(LDKCResult_boolLightningErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_boolLightningErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelAnnouncement C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_a(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR owner);
/* @internal */
export function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_a(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKChannelUpdate C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_b(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR owner);
/* @internal */
export function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_b(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKChannelUpdate C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_c(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR owner);
/* @internal */
export function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_c(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_c(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKChannelUpdateInfo CResult_ChannelUpdateInfoDecodeErrorZ_get_ok(LDKCResult_ChannelUpdateInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelUpdateInfoDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateInfoDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelUpdateInfoDecodeErrorZ_get_err(LDKCResult_ChannelUpdateInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelUpdateInfoDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateInfoDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelInfo CResult_ChannelInfoDecodeErrorZ_get_ok(LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelInfoDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelInfoDecodeErrorZ_get_err(LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelInfoDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKRoutingFees CResult_RoutingFeesDecodeErrorZ_get_ok(LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RoutingFeesDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_RoutingFeesDecodeErrorZ_get_err(LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RoutingFeesDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKNetAddress {
	protected constructor() {}
}
/* @internal */
export function LDKNetAddress_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_IPv4_get_addr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_IPv4_get_addr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_IPv4_get_port(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_IPv4_get_port(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_IPv6_get_addr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_IPv6_get_addr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_IPv6_get_port(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_IPv6_get_port(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_OnionV2_get_onion_v2(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_OnionV2_get_onion_v2(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_OnionV3_get_ed25519_pubkey(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_OnionV3_get_ed25519_pubkey(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_OnionV3_get_checksum(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_OnionV3_get_checksum(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_OnionV3_get_version(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_OnionV3_get_version(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_OnionV3_get_port(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_OnionV3_get_port(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_Hostname_get_hostname(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_Hostname_get_hostname(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_Hostname_get_port(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_Hostname_get_port(ptr);
	return nativeResponseValue;
}
	// struct LDKNodeAnnouncementInfo CResult_NodeAnnouncementInfoDecodeErrorZ_get_ok(LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeAnnouncementInfoDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_NodeAnnouncementInfoDecodeErrorZ_get_err(LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeAnnouncementInfoDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKNodeAlias CResult_NodeAliasDecodeErrorZ_get_ok(LDKCResult_NodeAliasDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeAliasDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAliasDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_NodeAliasDecodeErrorZ_get_err(LDKCResult_NodeAliasDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeAliasDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAliasDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKNodeInfo CResult_NodeInfoDecodeErrorZ_get_ok(LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeInfoDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_NodeInfoDecodeErrorZ_get_err(LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeInfoDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKNetworkGraph CResult_NetworkGraphDecodeErrorZ_get_ok(LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NetworkGraphDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_NetworkGraphDecodeErrorZ_get_err(LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NetworkGraphDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_CVec_NetAddressZZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_CVec_NetAddressZZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_CVec_NetAddressZZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_CVec_NetAddressZZ_Some_get_some(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_CVec_NetAddressZZ_Some_get_some(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_TxOutZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_TxOutZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_TxOutZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_TxOutZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_TxOutZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCoinSelection CResult_CoinSelectionNoneZ_get_ok(LDKCResult_CoinSelectionNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CoinSelectionNoneZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CoinSelectionNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_CoinSelectionNoneZ_get_err(LDKCResult_CoinSelectionNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CoinSelectionNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CoinSelectionNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKCVec_UtxoZ CResult_CVec_UtxoZNoneZ_get_ok(LDKCResult_CVec_UtxoZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CVec_UtxoZNoneZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_UtxoZNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_CVec_UtxoZNoneZ_get_err(LDKCResult_CVec_UtxoZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CVec_UtxoZNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_UtxoZNoneZ_get_err(owner);
	// debug statements here
}
/* @internal */
export class LDKCOption_u16Z {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_u16Z_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_u16Z_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_u16Z_Some_get_some(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_u16Z_Some_get_some(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_ChannelShutdownStateZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_ChannelShutdownStateZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_ChannelShutdownStateZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_ChannelShutdownStateZ_Some_get_some(ptr: bigint): ChannelShutdownState {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_ChannelShutdownStateZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes CResult__u832APIErrorZ_get_ok(LDKCResult__u832APIErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult__u832APIErrorZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKAPIError CResult__u832APIErrorZ_get_err(LDKCResult__u832APIErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult__u832APIErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKRecentPaymentDetails {
	protected constructor() {}
}
/* @internal */
export function LDKRecentPaymentDetails_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKRecentPaymentDetails_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKRecentPaymentDetails_Pending_get_payment_hash(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKRecentPaymentDetails_Pending_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKRecentPaymentDetails_Pending_get_total_msat(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKRecentPaymentDetails_Pending_get_total_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKRecentPaymentDetails_Fulfilled_get_payment_hash(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKRecentPaymentDetails_Fulfilled_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKRecentPaymentDetails_Abandoned_get_payment_hash(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKRecentPaymentDetails_Abandoned_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKPaymentSendFailure {
	protected constructor() {}
}
/* @internal */
export function LDKPaymentSendFailure_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentSendFailure_ParameterError_get_parameter_error(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_ParameterError_get_parameter_error(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentSendFailure_PathParameterError_get_path_parameter_error(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_PathParameterError_get_path_parameter_error(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentSendFailure_AllFailedResendSafe_get_all_failed_resend_safe(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_AllFailedResendSafe_get_all_failed_resend_safe(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentSendFailure_PartialFailure_get_results(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_PartialFailure_get_results(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentSendFailure_PartialFailure_get_failed_paths_retry(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_PartialFailure_get_failed_paths_retry(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentSendFailure_PartialFailure_get_payment_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_PartialFailure_get_payment_id(ptr);
	return nativeResponseValue;
}
	// void CResult_NonePaymentSendFailureZ_get_ok(LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NonePaymentSendFailureZ_get_ok(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_get_ok(owner);
	// debug statements here
}
	// struct LDKPaymentSendFailure CResult_NonePaymentSendFailureZ_get_err(LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NonePaymentSendFailureZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_get_err(owner);
	return nativeResponseValue;
}
	// void CResult_NoneRetryableSendFailureZ_get_ok(LDKCResult_NoneRetryableSendFailureZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneRetryableSendFailureZ_get_ok(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneRetryableSendFailureZ_get_ok(owner);
	// debug statements here
}
	// enum LDKRetryableSendFailure CResult_NoneRetryableSendFailureZ_get_err(LDKCResult_NoneRetryableSendFailureZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneRetryableSendFailureZ_get_err(owner: bigint): RetryableSendFailure {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneRetryableSendFailureZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes CResult_PaymentHashPaymentSendFailureZ_get_ok(LDKCResult_PaymentHashPaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentHashPaymentSendFailureZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentHashPaymentSendFailureZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKPaymentSendFailure CResult_PaymentHashPaymentSendFailureZ_get_err(LDKCResult_PaymentHashPaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentHashPaymentSendFailureZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentHashPaymentSendFailureZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes CResult_PaymentHashRetryableSendFailureZ_get_ok(LDKCResult_PaymentHashRetryableSendFailureZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentHashRetryableSendFailureZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentHashRetryableSendFailureZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKRetryableSendFailure CResult_PaymentHashRetryableSendFailureZ_get_err(LDKCResult_PaymentHashRetryableSendFailureZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentHashRetryableSendFailureZ_get_err(owner: bigint): RetryableSendFailure {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentHashRetryableSendFailureZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C2Tuple_PaymentHashPaymentIdZ_get_a(LDKC2Tuple_PaymentHashPaymentIdZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_PaymentHashPaymentIdZ_get_a(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C2Tuple_PaymentHashPaymentIdZ_get_b(LDKC2Tuple_PaymentHashPaymentIdZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_PaymentHashPaymentIdZ_get_b(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PaymentHashPaymentIdZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_ok(LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKPaymentSendFailure CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_err(LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C2Tuple_PaymentHashPaymentSecretZ_get_a(LDKC2Tuple_PaymentHashPaymentSecretZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_PaymentHashPaymentSecretZ_get_a(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C2Tuple_PaymentHashPaymentSecretZ_get_b(LDKC2Tuple_PaymentHashPaymentSecretZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_PaymentHashPaymentSecretZ_get_b(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PaymentHashPaymentSecretZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_ok(LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_err(LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKThirtyTwoBytes CResult_PaymentSecretNoneZ_get_ok(LDKCResult_PaymentSecretNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentSecretNoneZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_PaymentSecretNoneZ_get_err(LDKCResult_PaymentSecretNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentSecretNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKThirtyTwoBytes CResult_PaymentPreimageAPIErrorZ_get_ok(LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentPreimageAPIErrorZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKAPIError CResult_PaymentPreimageAPIErrorZ_get_err(LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentPreimageAPIErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_CVec_ChainHashZZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_CVec_ChainHashZZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_CVec_ChainHashZZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_CVec_ChainHashZZ_Some_get_some(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_CVec_ChainHashZZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCounterpartyForwardingInfo CResult_CounterpartyForwardingInfoDecodeErrorZ_get_ok(LDKCResult_CounterpartyForwardingInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CounterpartyForwardingInfoDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyForwardingInfoDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_CounterpartyForwardingInfoDecodeErrorZ_get_err(LDKCResult_CounterpartyForwardingInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CounterpartyForwardingInfoDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyForwardingInfoDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelCounterparty CResult_ChannelCounterpartyDecodeErrorZ_get_ok(LDKCResult_ChannelCounterpartyDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelCounterpartyDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelCounterpartyDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelCounterpartyDecodeErrorZ_get_err(LDKCResult_ChannelCounterpartyDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelCounterpartyDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelCounterpartyDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelDetails CResult_ChannelDetailsDecodeErrorZ_get_ok(LDKCResult_ChannelDetailsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelDetailsDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelDetailsDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelDetailsDecodeErrorZ_get_err(LDKCResult_ChannelDetailsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelDetailsDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelDetailsDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKPhantomRouteHints CResult_PhantomRouteHintsDecodeErrorZ_get_ok(LDKCResult_PhantomRouteHintsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PhantomRouteHintsDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PhantomRouteHintsDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_PhantomRouteHintsDecodeErrorZ_get_err(LDKCResult_PhantomRouteHintsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PhantomRouteHintsDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PhantomRouteHintsDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// enum LDKChannelShutdownState CResult_ChannelShutdownStateDecodeErrorZ_get_ok(LDKCResult_ChannelShutdownStateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelShutdownStateDecodeErrorZ_get_ok(owner: bigint): ChannelShutdownState {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelShutdownStateDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelShutdownStateDecodeErrorZ_get_err(LDKCResult_ChannelShutdownStateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelShutdownStateDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelShutdownStateDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export interface LDKWatch {
	watch_channel (funding_txo: bigint, monitor: bigint): ChannelMonitorUpdateStatus;
	update_channel (funding_txo: bigint, update: bigint): ChannelMonitorUpdateStatus;
	release_pending_monitor_events (): number;
}

/* @internal */
export function LDKWatch_new(impl: LDKWatch): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKWatch_new(i), i];
}
	// LDKChannelMonitorUpdateStatus Watch_watch_channel LDKWatch *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo, struct LDKChannelMonitor monitor
/* @internal */
export function Watch_watch_channel(this_arg: bigint, funding_txo: bigint, monitor: bigint): ChannelMonitorUpdateStatus {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Watch_watch_channel(this_arg, funding_txo, monitor);
	return nativeResponseValue;
}
	// LDKChannelMonitorUpdateStatus Watch_update_channel LDKWatch *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo, const struct LDKChannelMonitorUpdate *NONNULL_PTR update
/* @internal */
export function Watch_update_channel(this_arg: bigint, funding_txo: bigint, update: bigint): ChannelMonitorUpdateStatus {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Watch_update_channel(this_arg, funding_txo, update);
	return nativeResponseValue;
}
	// LDKCVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ Watch_release_pending_monitor_events LDKWatch *NONNULL_PTR this_arg
/* @internal */
export function Watch_release_pending_monitor_events(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Watch_release_pending_monitor_events(this_arg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKBroadcasterInterface {
	broadcast_transactions (txs: number): void;
}

/* @internal */
export function LDKBroadcasterInterface_new(impl: LDKBroadcasterInterface): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKBroadcasterInterface_new(i), i];
}
	// void BroadcasterInterface_broadcast_transactions LDKBroadcasterInterface *NONNULL_PTR this_arg, struct LDKCVec_TransactionZ txs
/* @internal */
export function BroadcasterInterface_broadcast_transactions(this_arg: bigint, txs: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BroadcasterInterface_broadcast_transactions(this_arg, txs);
	// debug statements here
}
/* @internal */
export interface LDKEntropySource {
	get_secure_random_bytes (): number;
}

/* @internal */
export function LDKEntropySource_new(impl: LDKEntropySource): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKEntropySource_new(i), i];
}
	// LDKThirtyTwoBytes EntropySource_get_secure_random_bytes LDKEntropySource *NONNULL_PTR this_arg
/* @internal */
export function EntropySource_get_secure_random_bytes(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EntropySource_get_secure_random_bytes(this_arg);
	return nativeResponseValue;
}
/* @internal */
export class LDKUnsignedGossipMessage {
	protected constructor() {}
}
/* @internal */
export function LDKUnsignedGossipMessage_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKUnsignedGossipMessage_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKUnsignedGossipMessage_ChannelAnnouncement_get_channel_announcement(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKUnsignedGossipMessage_ChannelAnnouncement_get_channel_announcement(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKUnsignedGossipMessage_ChannelUpdate_get_channel_update(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKUnsignedGossipMessage_ChannelUpdate_get_channel_update(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKUnsignedGossipMessage_NodeAnnouncement_get_node_announcement(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKUnsignedGossipMessage_NodeAnnouncement_get_node_announcement(ptr);
	return nativeResponseValue;
}
/* @internal */
export interface LDKNodeSigner {
	get_inbound_payment_key_material (): number;
	get_node_id (recipient: Recipient): bigint;
	ecdh (recipient: Recipient, other_key: number, tweak: bigint): bigint;
	sign_invoice (hrp_bytes: number, invoice_data: number, recipient: Recipient): bigint;
	sign_gossip_message (msg: bigint): bigint;
}

/* @internal */
export function LDKNodeSigner_new(impl: LDKNodeSigner): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKNodeSigner_new(i), i];
}
	// LDKThirtyTwoBytes NodeSigner_get_inbound_payment_key_material LDKNodeSigner *NONNULL_PTR this_arg
/* @internal */
export function NodeSigner_get_inbound_payment_key_material(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeSigner_get_inbound_payment_key_material(this_arg);
	return nativeResponseValue;
}
	// LDKCResult_PublicKeyNoneZ NodeSigner_get_node_id LDKNodeSigner *NONNULL_PTR this_arg, enum LDKRecipient recipient
/* @internal */
export function NodeSigner_get_node_id(this_arg: bigint, recipient: Recipient): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeSigner_get_node_id(this_arg, recipient);
	return nativeResponseValue;
}
	// LDKCResult_SharedSecretNoneZ NodeSigner_ecdh LDKNodeSigner *NONNULL_PTR this_arg, enum LDKRecipient recipient, struct LDKPublicKey other_key, struct LDKCOption_ScalarZ tweak
/* @internal */
export function NodeSigner_ecdh(this_arg: bigint, recipient: Recipient, other_key: number, tweak: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeSigner_ecdh(this_arg, recipient, other_key, tweak);
	return nativeResponseValue;
}
	// LDKCResult_RecoverableSignatureNoneZ NodeSigner_sign_invoice LDKNodeSigner *NONNULL_PTR this_arg, struct LDKu8slice hrp_bytes, struct LDKCVec_U5Z invoice_data, enum LDKRecipient recipient
/* @internal */
export function NodeSigner_sign_invoice(this_arg: bigint, hrp_bytes: number, invoice_data: number, recipient: Recipient): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeSigner_sign_invoice(this_arg, hrp_bytes, invoice_data, recipient);
	return nativeResponseValue;
}
	// LDKCResult_SignatureNoneZ NodeSigner_sign_gossip_message LDKNodeSigner *NONNULL_PTR this_arg, struct LDKUnsignedGossipMessage msg
/* @internal */
export function NodeSigner_sign_gossip_message(this_arg: bigint, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeSigner_sign_gossip_message(this_arg, msg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKSignerProvider {
	generate_channel_keys_id (inbound: boolean, channel_value_satoshis: bigint, user_channel_id: number): number;
	derive_channel_signer (channel_value_satoshis: bigint, channel_keys_id: number): bigint;
	read_chan_signer (reader: number): bigint;
	get_destination_script (): bigint;
	get_shutdown_scriptpubkey (): bigint;
}

/* @internal */
export function LDKSignerProvider_new(impl: LDKSignerProvider): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKSignerProvider_new(i), i];
}
	// LDKThirtyTwoBytes SignerProvider_generate_channel_keys_id LDKSignerProvider *NONNULL_PTR this_arg, bool inbound, uint64_t channel_value_satoshis, struct LDKU128 user_channel_id
/* @internal */
export function SignerProvider_generate_channel_keys_id(this_arg: bigint, inbound: boolean, channel_value_satoshis: bigint, user_channel_id: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignerProvider_generate_channel_keys_id(this_arg, inbound, channel_value_satoshis, user_channel_id);
	return nativeResponseValue;
}
	// LDKWriteableEcdsaChannelSigner SignerProvider_derive_channel_signer LDKSignerProvider *NONNULL_PTR this_arg, uint64_t channel_value_satoshis, struct LDKThirtyTwoBytes channel_keys_id
/* @internal */
export function SignerProvider_derive_channel_signer(this_arg: bigint, channel_value_satoshis: bigint, channel_keys_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignerProvider_derive_channel_signer(this_arg, channel_value_satoshis, channel_keys_id);
	return nativeResponseValue;
}
	// LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ SignerProvider_read_chan_signer LDKSignerProvider *NONNULL_PTR this_arg, struct LDKu8slice reader
/* @internal */
export function SignerProvider_read_chan_signer(this_arg: bigint, reader: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignerProvider_read_chan_signer(this_arg, reader);
	return nativeResponseValue;
}
	// LDKCResult_ScriptNoneZ SignerProvider_get_destination_script LDKSignerProvider *NONNULL_PTR this_arg
/* @internal */
export function SignerProvider_get_destination_script(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignerProvider_get_destination_script(this_arg);
	return nativeResponseValue;
}
	// LDKCResult_ShutdownScriptNoneZ SignerProvider_get_shutdown_scriptpubkey LDKSignerProvider *NONNULL_PTR this_arg
/* @internal */
export function SignerProvider_get_shutdown_scriptpubkey(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignerProvider_get_shutdown_scriptpubkey(this_arg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKFeeEstimator {
	get_est_sat_per_1000_weight (confirmation_target: ConfirmationTarget): number;
}

/* @internal */
export function LDKFeeEstimator_new(impl: LDKFeeEstimator): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKFeeEstimator_new(i), i];
}
	// uint32_t FeeEstimator_get_est_sat_per_1000_weight LDKFeeEstimator *NONNULL_PTR this_arg, enum LDKConfirmationTarget confirmation_target
/* @internal */
export function FeeEstimator_get_est_sat_per_1000_weight(this_arg: bigint, confirmation_target: ConfirmationTarget): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FeeEstimator_get_est_sat_per_1000_weight(this_arg, confirmation_target);
	return nativeResponseValue;
}
/* @internal */
export interface LDKRouter {
	find_route (payer: number, route_params: bigint, first_hops: number, inflight_htlcs: bigint): bigint;
	find_route_with_id (payer: number, route_params: bigint, first_hops: number, inflight_htlcs: bigint, _payment_hash: number, _payment_id: number): bigint;
}

/* @internal */
export function LDKRouter_new(impl: LDKRouter): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKRouter_new(i), i];
}
	// LDKCResult_RouteLightningErrorZ Router_find_route LDKRouter *NONNULL_PTR this_arg, struct LDKPublicKey payer, const struct LDKRouteParameters *NONNULL_PTR route_params, struct LDKCVec_ChannelDetailsZ *first_hops, struct LDKInFlightHtlcs inflight_htlcs
/* @internal */
export function Router_find_route(this_arg: bigint, payer: number, route_params: bigint, first_hops: number, inflight_htlcs: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Router_find_route(this_arg, payer, route_params, first_hops, inflight_htlcs);
	return nativeResponseValue;
}
	// LDKCResult_RouteLightningErrorZ Router_find_route_with_id LDKRouter *NONNULL_PTR this_arg, struct LDKPublicKey payer, const struct LDKRouteParameters *NONNULL_PTR route_params, struct LDKCVec_ChannelDetailsZ *first_hops, struct LDKInFlightHtlcs inflight_htlcs, struct LDKThirtyTwoBytes _payment_hash, struct LDKThirtyTwoBytes _payment_id
/* @internal */
export function Router_find_route_with_id(this_arg: bigint, payer: number, route_params: bigint, first_hops: number, inflight_htlcs: bigint, _payment_hash: number, _payment_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Router_find_route_with_id(this_arg, payer, route_params, first_hops, inflight_htlcs, _payment_hash, _payment_id);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C2Tuple_BlockHashChannelManagerZ_get_a(LDKC2Tuple_BlockHashChannelManagerZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_BlockHashChannelManagerZ_get_a(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelManagerZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKChannelManager C2Tuple_BlockHashChannelManagerZ_get_b(LDKC2Tuple_BlockHashChannelManagerZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_BlockHashChannelManagerZ_get_b(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelManagerZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_BlockHashChannelManagerZ *CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_ok(LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_err(LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKMaxDustHTLCExposure {
	protected constructor() {}
}
/* @internal */
export function LDKMaxDustHTLCExposure_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMaxDustHTLCExposure_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMaxDustHTLCExposure_FixedLimitMsat_get_fixed_limit_msat(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMaxDustHTLCExposure_FixedLimitMsat_get_fixed_limit_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMaxDustHTLCExposure_FeeRateMultiplier_get_fee_rate_multiplier(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMaxDustHTLCExposure_FeeRateMultiplier_get_fee_rate_multiplier(ptr);
	return nativeResponseValue;
}
	// struct LDKMaxDustHTLCExposure CResult_MaxDustHTLCExposureDecodeErrorZ_get_ok(LDKCResult_MaxDustHTLCExposureDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_MaxDustHTLCExposureDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_MaxDustHTLCExposureDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_MaxDustHTLCExposureDecodeErrorZ_get_err(LDKCResult_MaxDustHTLCExposureDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_MaxDustHTLCExposureDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_MaxDustHTLCExposureDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelConfig CResult_ChannelConfigDecodeErrorZ_get_ok(LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelConfigDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelConfigDecodeErrorZ_get_err(LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelConfigDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_MaxDustHTLCExposureZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_MaxDustHTLCExposureZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_MaxDustHTLCExposureZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_MaxDustHTLCExposureZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_MaxDustHTLCExposureZ_Some_get_some(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_APIErrorZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_APIErrorZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_APIErrorZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_APIErrorZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_APIErrorZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCOption_APIErrorZ CResult_COption_APIErrorZDecodeErrorZ_get_ok(LDKCResult_COption_APIErrorZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_APIErrorZDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_APIErrorZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_COption_APIErrorZDecodeErrorZ_get_err(LDKCResult_COption_APIErrorZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_APIErrorZDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_APIErrorZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKBigSize CResult_BigSizeDecodeErrorZ_get_ok(LDKCResult_BigSizeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BigSizeDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BigSizeDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_BigSizeDecodeErrorZ_get_err(LDKCResult_BigSizeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BigSizeDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BigSizeDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKHostname CResult_HostnameDecodeErrorZ_get_ok(LDKCResult_HostnameDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_HostnameDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HostnameDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_HostnameDecodeErrorZ_get_err(LDKCResult_HostnameDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_HostnameDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HostnameDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTransactionU16LenLimited CResult_TransactionU16LenLimitedNoneZ_get_ok(LDKCResult_TransactionU16LenLimitedNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TransactionU16LenLimitedNoneZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionU16LenLimitedNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_TransactionU16LenLimitedNoneZ_get_err(LDKCResult_TransactionU16LenLimitedNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TransactionU16LenLimitedNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionU16LenLimitedNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKTransactionU16LenLimited CResult_TransactionU16LenLimitedDecodeErrorZ_get_ok(LDKCResult_TransactionU16LenLimitedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TransactionU16LenLimitedDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionU16LenLimitedDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_TransactionU16LenLimitedDecodeErrorZ_get_err(LDKCResult_TransactionU16LenLimitedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TransactionU16LenLimitedDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionU16LenLimitedDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKUntrustedString CResult_UntrustedStringDecodeErrorZ_get_ok(LDKCResult_UntrustedStringDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UntrustedStringDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UntrustedStringDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_UntrustedStringDecodeErrorZ_get_err(LDKCResult_UntrustedStringDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UntrustedStringDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UntrustedStringDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKOutPoint CResult_OutPointDecodeErrorZ_get_ok(LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OutPointDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_OutPointDecodeErrorZ_get_err(LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OutPointDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export interface LDKType {
	type_id (): number;
	debug_str (): number;
	write (): number;
}

/* @internal */
export function LDKType_new(impl: LDKType): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKType_new(i), i];
}
	// uint16_t Type_type_id LDKType *NONNULL_PTR this_arg
/* @internal */
export function Type_type_id(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Type_type_id(this_arg);
	return nativeResponseValue;
}
	// LDKStr Type_debug_str LDKType *NONNULL_PTR this_arg
/* @internal */
export function Type_debug_str(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Type_debug_str(this_arg);
	return nativeResponseValue;
}
	// LDKCVec_u8Z Type_write LDKType *NONNULL_PTR this_arg
/* @internal */
export function Type_write(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Type_write(this_arg);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_TypeZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_TypeZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_TypeZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_TypeZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_TypeZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCOption_TypeZ CResult_COption_TypeZDecodeErrorZ_get_ok(LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_TypeZDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_COption_TypeZDecodeErrorZ_get_err(LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_TypeZDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKPaymentError {
	protected constructor() {}
}
/* @internal */
export function LDKPaymentError_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentError_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentError_Invoice_get_invoice(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentError_Invoice_get_invoice(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentError_Sending_get_sending(ptr: bigint): RetryableSendFailure {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentError_Sending_get_sending(ptr);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes CResult_PaymentIdPaymentErrorZ_get_ok(LDKCResult_PaymentIdPaymentErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentIdPaymentErrorZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKPaymentError CResult_PaymentIdPaymentErrorZ_get_err(LDKCResult_PaymentIdPaymentErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentIdPaymentErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// void CResult_NonePaymentErrorZ_get_ok(LDKCResult_NonePaymentErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NonePaymentErrorZ_get_ok(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentErrorZ_get_ok(owner);
	// debug statements here
}
	// struct LDKPaymentError CResult_NonePaymentErrorZ_get_err(LDKCResult_NonePaymentErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NonePaymentErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKStr CResult_StringErrorZ_get_ok(LDKCResult_StringErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_StringErrorZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StringErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKSecp256k1Error CResult_StringErrorZ_get_err(LDKCResult_StringErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_StringErrorZ_get_err(owner: bigint): Secp256k1Error {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StringErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelMonitorUpdate CResult_ChannelMonitorUpdateDecodeErrorZ_get_ok(LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelMonitorUpdateDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelMonitorUpdateDecodeErrorZ_get_err(LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelMonitorUpdateDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_MonitorEventZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_MonitorEventZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_MonitorEventZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_MonitorEventZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_MonitorEventZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCOption_MonitorEventZ CResult_COption_MonitorEventZDecodeErrorZ_get_ok(LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_MonitorEventZDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_COption_MonitorEventZDecodeErrorZ_get_err(LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_MonitorEventZDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKHTLCUpdate CResult_HTLCUpdateDecodeErrorZ_get_ok(LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_HTLCUpdateDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_HTLCUpdateDecodeErrorZ_get_err(LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_HTLCUpdateDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKOutPoint C2Tuple_OutPointScriptZ_get_a(LDKC2Tuple_OutPointScriptZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_OutPointScriptZ_get_a(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointScriptZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z C2Tuple_OutPointScriptZ_get_b(LDKC2Tuple_OutPointScriptZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_OutPointScriptZ_get_b(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointScriptZ_get_b(owner);
	return nativeResponseValue;
}
	// uint32_t C2Tuple_u32ScriptZ_get_a(LDKC2Tuple_u32ScriptZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_u32ScriptZ_get_a(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32ScriptZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z C2Tuple_u32ScriptZ_get_b(LDKC2Tuple_u32ScriptZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_u32ScriptZ_get_b(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32ScriptZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_a(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_a(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKCVec_C2Tuple_u32ScriptZZ C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_b(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_b(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_b(owner);
	return nativeResponseValue;
}
	// uint32_t C2Tuple_u32TxOutZ_get_a(LDKC2Tuple_u32TxOutZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_u32TxOutZ_get_a(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKTxOut C2Tuple_u32TxOutZ_get_b(LDKC2Tuple_u32TxOutZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_u32TxOutZ_get_b(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_a(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_a(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKCVec_C2Tuple_u32TxOutZZ C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_b(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_b(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_b(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKBalance {
	protected constructor() {}
}
/* @internal */
export function LDKBalance_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_ClaimableOnChannelClose_get_amount_satoshis(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_ClaimableOnChannelClose_get_amount_satoshis(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_ClaimableAwaitingConfirmations_get_amount_satoshis(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_ClaimableAwaitingConfirmations_get_amount_satoshis(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_ClaimableAwaitingConfirmations_get_confirmation_height(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_ClaimableAwaitingConfirmations_get_confirmation_height(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_ContentiousClaimable_get_amount_satoshis(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_ContentiousClaimable_get_amount_satoshis(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_ContentiousClaimable_get_timeout_height(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_ContentiousClaimable_get_timeout_height(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_ContentiousClaimable_get_payment_hash(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_ContentiousClaimable_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_ContentiousClaimable_get_payment_preimage(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_ContentiousClaimable_get_payment_preimage(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_MaybeTimeoutClaimableHTLC_get_amount_satoshis(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_MaybeTimeoutClaimableHTLC_get_amount_satoshis(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_MaybeTimeoutClaimableHTLC_get_claimable_height(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_MaybeTimeoutClaimableHTLC_get_claimable_height(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_MaybeTimeoutClaimableHTLC_get_payment_hash(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_MaybeTimeoutClaimableHTLC_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_MaybePreimageClaimableHTLC_get_amount_satoshis(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_MaybePreimageClaimableHTLC_get_amount_satoshis(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_MaybePreimageClaimableHTLC_get_expiry_height(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_MaybePreimageClaimableHTLC_get_expiry_height(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_MaybePreimageClaimableHTLC_get_payment_hash(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_MaybePreimageClaimableHTLC_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_CounterpartyRevokedOutputClaimable_get_amount_satoshis(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_CounterpartyRevokedOutputClaimable_get_amount_satoshis(ptr);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C2Tuple_BlockHashChannelMonitorZ_get_a(LDKC2Tuple_BlockHashChannelMonitorZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_BlockHashChannelMonitorZ_get_a(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKChannelMonitor C2Tuple_BlockHashChannelMonitorZ_get_b(LDKC2Tuple_BlockHashChannelMonitorZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_BlockHashChannelMonitorZ_get_b(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_BlockHashChannelMonitorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_ok(LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_err(LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKPublicKey C2Tuple_PublicKeyTypeZ_get_a(LDKC2Tuple_PublicKeyTypeZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_PublicKeyTypeZ_get_a(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKType C2Tuple_PublicKeyTypeZ_get_b(LDKC2Tuple_PublicKeyTypeZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_PublicKeyTypeZ_get_b(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_get_b(owner);
	return nativeResponseValue;
}
/* @internal */
export interface LDKCustomOnionMessageContents {
	tlv_type (): bigint;
	write (): number;
}

/* @internal */
export function LDKCustomOnionMessageContents_new(impl: LDKCustomOnionMessageContents): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKCustomOnionMessageContents_new(i), i];
}
	// uint64_t CustomOnionMessageContents_tlv_type LDKCustomOnionMessageContents *NONNULL_PTR this_arg
/* @internal */
export function CustomOnionMessageContents_tlv_type(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomOnionMessageContents_tlv_type(this_arg);
	return nativeResponseValue;
}
	// LDKCVec_u8Z CustomOnionMessageContents_write LDKCustomOnionMessageContents *NONNULL_PTR this_arg
/* @internal */
export function CustomOnionMessageContents_write(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomOnionMessageContents_write(this_arg);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_CustomOnionMessageContentsZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_CustomOnionMessageContentsZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_CustomOnionMessageContentsZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_CustomOnionMessageContentsZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_CustomOnionMessageContentsZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCOption_CustomOnionMessageContentsZ CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_get_ok(LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_get_err(LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_NetAddressZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_NetAddressZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_NetAddressZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_NetAddressZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_NetAddressZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKPublicKey C2Tuple_PublicKeyCOption_NetAddressZZ_get_a(LDKC2Tuple_PublicKeyCOption_NetAddressZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_PublicKeyCOption_NetAddressZZ_get_a(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyCOption_NetAddressZZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKCOption_NetAddressZ C2Tuple_PublicKeyCOption_NetAddressZZ_get_b(LDKC2Tuple_PublicKeyCOption_NetAddressZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_PublicKeyCOption_NetAddressZZ_get_b(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyCOption_NetAddressZZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z CResult_CVec_u8ZPeerHandleErrorZ_get_ok(LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CVec_u8ZPeerHandleErrorZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKPeerHandleError CResult_CVec_u8ZPeerHandleErrorZ_get_err(LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CVec_u8ZPeerHandleErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// void CResult_NonePeerHandleErrorZ_get_ok(LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NonePeerHandleErrorZ_get_ok(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_get_ok(owner);
	// debug statements here
}
	// struct LDKPeerHandleError CResult_NonePeerHandleErrorZ_get_err(LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NonePeerHandleErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// bool CResult_boolPeerHandleErrorZ_get_ok(LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_boolPeerHandleErrorZ_get_ok(owner: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKPeerHandleError CResult_boolPeerHandleErrorZ_get_err(LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_boolPeerHandleErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKOnionMessagePath CResult_OnionMessagePathNoneZ_get_ok(LDKCResult_OnionMessagePathNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OnionMessagePathNoneZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OnionMessagePathNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_OnionMessagePathNoneZ_get_err(LDKCResult_OnionMessagePathNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OnionMessagePathNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OnionMessagePathNoneZ_get_err(owner);
	// debug statements here
}
/* @internal */
export class LDKSendError {
	protected constructor() {}
}
/* @internal */
export function LDKSendError_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKSendError_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKSendError_Secp256k1_get_secp256k1(ptr: bigint): Secp256k1Error {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKSendError_Secp256k1_get_secp256k1(ptr);
	return nativeResponseValue;
}
	// void CResult_NoneSendErrorZ_get_ok(LDKCResult_NoneSendErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneSendErrorZ_get_ok(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneSendErrorZ_get_ok(owner);
	// debug statements here
}
	// struct LDKSendError CResult_NoneSendErrorZ_get_err(LDKCResult_NoneSendErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneSendErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneSendErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKBlindedPath CResult_BlindedPathNoneZ_get_ok(LDKCResult_BlindedPathNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BlindedPathNoneZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPathNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_BlindedPathNoneZ_get_err(LDKCResult_BlindedPathNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BlindedPathNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPathNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKBlindedPath CResult_BlindedPathDecodeErrorZ_get_ok(LDKCResult_BlindedPathDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BlindedPathDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPathDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_BlindedPathDecodeErrorZ_get_err(LDKCResult_BlindedPathDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BlindedPathDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPathDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKBlindedHop CResult_BlindedHopDecodeErrorZ_get_ok(LDKCResult_BlindedHopDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BlindedHopDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedHopDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_BlindedHopDecodeErrorZ_get_err(LDKCResult_BlindedHopDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BlindedHopDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedHopDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKGraphSyncError {
	protected constructor() {}
}
/* @internal */
export function LDKGraphSyncError_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKGraphSyncError_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKGraphSyncError_DecodeError_get_decode_error(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKGraphSyncError_DecodeError_get_decode_error(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKGraphSyncError_LightningError_get_lightning_error(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKGraphSyncError_LightningError_get_lightning_error(ptr);
	return nativeResponseValue;
}
	// uint32_t CResult_u32GraphSyncErrorZ_get_ok(LDKCResult_u32GraphSyncErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_u32GraphSyncErrorZ_get_ok(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_u32GraphSyncErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKGraphSyncError CResult_u32GraphSyncErrorZ_get_err(LDKCResult_u32GraphSyncErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_u32GraphSyncErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_u32GraphSyncErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// void CResult_NoneErrorZ_get_ok(LDKCResult_NoneErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneErrorZ_get_ok(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneErrorZ_get_ok(owner);
	// debug statements here
}
	// enum LDKIOError CResult_NoneErrorZ_get_err(LDKCResult_NoneErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneErrorZ_get_err(owner: bigint): IOError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_ScriptZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_ScriptZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_ScriptZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_ScriptZ_Some_get_some(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_ScriptZ_Some_get_some(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_i64Z {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_i64Z_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_i64Z_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_i64Z_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_i64Z_Some_get_some(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_TxidZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_TxidZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_TxidZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_TxidZ_Some_get_some(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_TxidZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKNetAddress CResult_NetAddressDecodeErrorZ_get_ok(LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NetAddressDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_NetAddressDecodeErrorZ_get_err(LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NetAddressDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKAcceptChannel CResult_AcceptChannelDecodeErrorZ_get_ok(LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_AcceptChannelDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_AcceptChannelDecodeErrorZ_get_err(LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_AcceptChannelDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKAcceptChannelV2 CResult_AcceptChannelV2DecodeErrorZ_get_ok(LDKCResult_AcceptChannelV2DecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_AcceptChannelV2DecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelV2DecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_AcceptChannelV2DecodeErrorZ_get_err(LDKCResult_AcceptChannelV2DecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_AcceptChannelV2DecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelV2DecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTxAddInput CResult_TxAddInputDecodeErrorZ_get_ok(LDKCResult_TxAddInputDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxAddInputDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAddInputDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_TxAddInputDecodeErrorZ_get_err(LDKCResult_TxAddInputDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxAddInputDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAddInputDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTxAddOutput CResult_TxAddOutputDecodeErrorZ_get_ok(LDKCResult_TxAddOutputDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxAddOutputDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAddOutputDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_TxAddOutputDecodeErrorZ_get_err(LDKCResult_TxAddOutputDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxAddOutputDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAddOutputDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTxRemoveInput CResult_TxRemoveInputDecodeErrorZ_get_ok(LDKCResult_TxRemoveInputDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxRemoveInputDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxRemoveInputDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_TxRemoveInputDecodeErrorZ_get_err(LDKCResult_TxRemoveInputDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxRemoveInputDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxRemoveInputDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTxRemoveOutput CResult_TxRemoveOutputDecodeErrorZ_get_ok(LDKCResult_TxRemoveOutputDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxRemoveOutputDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxRemoveOutputDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_TxRemoveOutputDecodeErrorZ_get_err(LDKCResult_TxRemoveOutputDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxRemoveOutputDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxRemoveOutputDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTxComplete CResult_TxCompleteDecodeErrorZ_get_ok(LDKCResult_TxCompleteDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxCompleteDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCompleteDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_TxCompleteDecodeErrorZ_get_err(LDKCResult_TxCompleteDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxCompleteDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCompleteDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTxSignatures CResult_TxSignaturesDecodeErrorZ_get_ok(LDKCResult_TxSignaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxSignaturesDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxSignaturesDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_TxSignaturesDecodeErrorZ_get_err(LDKCResult_TxSignaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxSignaturesDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxSignaturesDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTxInitRbf CResult_TxInitRbfDecodeErrorZ_get_ok(LDKCResult_TxInitRbfDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxInitRbfDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxInitRbfDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_TxInitRbfDecodeErrorZ_get_err(LDKCResult_TxInitRbfDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxInitRbfDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxInitRbfDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTxAckRbf CResult_TxAckRbfDecodeErrorZ_get_ok(LDKCResult_TxAckRbfDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxAckRbfDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAckRbfDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_TxAckRbfDecodeErrorZ_get_err(LDKCResult_TxAckRbfDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxAckRbfDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAckRbfDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTxAbort CResult_TxAbortDecodeErrorZ_get_ok(LDKCResult_TxAbortDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxAbortDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAbortDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_TxAbortDecodeErrorZ_get_err(LDKCResult_TxAbortDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxAbortDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAbortDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKAnnouncementSignatures CResult_AnnouncementSignaturesDecodeErrorZ_get_ok(LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_AnnouncementSignaturesDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_AnnouncementSignaturesDecodeErrorZ_get_err(LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_AnnouncementSignaturesDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelReestablish CResult_ChannelReestablishDecodeErrorZ_get_ok(LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelReestablishDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelReestablishDecodeErrorZ_get_err(LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelReestablishDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKClosingSigned CResult_ClosingSignedDecodeErrorZ_get_ok(LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ClosingSignedDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ClosingSignedDecodeErrorZ_get_err(LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ClosingSignedDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKClosingSignedFeeRange CResult_ClosingSignedFeeRangeDecodeErrorZ_get_ok(LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ClosingSignedFeeRangeDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ClosingSignedFeeRangeDecodeErrorZ_get_err(LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ClosingSignedFeeRangeDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKCommitmentSigned CResult_CommitmentSignedDecodeErrorZ_get_ok(LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CommitmentSignedDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_CommitmentSignedDecodeErrorZ_get_err(LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CommitmentSignedDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKFundingCreated CResult_FundingCreatedDecodeErrorZ_get_ok(LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_FundingCreatedDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_FundingCreatedDecodeErrorZ_get_err(LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_FundingCreatedDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKFundingSigned CResult_FundingSignedDecodeErrorZ_get_ok(LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_FundingSignedDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_FundingSignedDecodeErrorZ_get_err(LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_FundingSignedDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelReady CResult_ChannelReadyDecodeErrorZ_get_ok(LDKCResult_ChannelReadyDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelReadyDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReadyDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelReadyDecodeErrorZ_get_err(LDKCResult_ChannelReadyDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelReadyDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReadyDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKInit CResult_InitDecodeErrorZ_get_ok(LDKCResult_InitDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InitDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_InitDecodeErrorZ_get_err(LDKCResult_InitDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InitDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKOpenChannel CResult_OpenChannelDecodeErrorZ_get_ok(LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OpenChannelDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_OpenChannelDecodeErrorZ_get_err(LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OpenChannelDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKOpenChannelV2 CResult_OpenChannelV2DecodeErrorZ_get_ok(LDKCResult_OpenChannelV2DecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OpenChannelV2DecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelV2DecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_OpenChannelV2DecodeErrorZ_get_err(LDKCResult_OpenChannelV2DecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OpenChannelV2DecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelV2DecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKRevokeAndACK CResult_RevokeAndACKDecodeErrorZ_get_ok(LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RevokeAndACKDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_RevokeAndACKDecodeErrorZ_get_err(LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RevokeAndACKDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKShutdown CResult_ShutdownDecodeErrorZ_get_ok(LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ShutdownDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ShutdownDecodeErrorZ_get_err(LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ShutdownDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKUpdateFailHTLC CResult_UpdateFailHTLCDecodeErrorZ_get_ok(LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateFailHTLCDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_UpdateFailHTLCDecodeErrorZ_get_err(LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateFailHTLCDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKUpdateFailMalformedHTLC CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_ok(LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_err(LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKUpdateFee CResult_UpdateFeeDecodeErrorZ_get_ok(LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateFeeDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_UpdateFeeDecodeErrorZ_get_err(LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateFeeDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKUpdateFulfillHTLC CResult_UpdateFulfillHTLCDecodeErrorZ_get_ok(LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateFulfillHTLCDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_UpdateFulfillHTLCDecodeErrorZ_get_err(LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateFulfillHTLCDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKUpdateAddHTLC CResult_UpdateAddHTLCDecodeErrorZ_get_ok(LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateAddHTLCDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_UpdateAddHTLCDecodeErrorZ_get_err(LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateAddHTLCDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKOnionMessage CResult_OnionMessageDecodeErrorZ_get_ok(LDKCResult_OnionMessageDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OnionMessageDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OnionMessageDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_OnionMessageDecodeErrorZ_get_err(LDKCResult_OnionMessageDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OnionMessageDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OnionMessageDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKPing CResult_PingDecodeErrorZ_get_ok(LDKCResult_PingDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PingDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_PingDecodeErrorZ_get_err(LDKCResult_PingDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PingDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKPong CResult_PongDecodeErrorZ_get_ok(LDKCResult_PongDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PongDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_PongDecodeErrorZ_get_err(LDKCResult_PongDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PongDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKUnsignedChannelAnnouncement CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_ok(LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_err(LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelAnnouncement CResult_ChannelAnnouncementDecodeErrorZ_get_ok(LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelAnnouncementDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelAnnouncementDecodeErrorZ_get_err(LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelAnnouncementDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKUnsignedChannelUpdate CResult_UnsignedChannelUpdateDecodeErrorZ_get_ok(LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UnsignedChannelUpdateDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_UnsignedChannelUpdateDecodeErrorZ_get_err(LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UnsignedChannelUpdateDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelUpdate CResult_ChannelUpdateDecodeErrorZ_get_ok(LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelUpdateDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelUpdateDecodeErrorZ_get_err(LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelUpdateDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKErrorMessage CResult_ErrorMessageDecodeErrorZ_get_ok(LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ErrorMessageDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ErrorMessageDecodeErrorZ_get_err(LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ErrorMessageDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKWarningMessage CResult_WarningMessageDecodeErrorZ_get_ok(LDKCResult_WarningMessageDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_WarningMessageDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WarningMessageDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_WarningMessageDecodeErrorZ_get_err(LDKCResult_WarningMessageDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_WarningMessageDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WarningMessageDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKUnsignedNodeAnnouncement CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_ok(LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_err(LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKNodeAnnouncement CResult_NodeAnnouncementDecodeErrorZ_get_ok(LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeAnnouncementDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_NodeAnnouncementDecodeErrorZ_get_err(LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeAnnouncementDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKQueryShortChannelIds CResult_QueryShortChannelIdsDecodeErrorZ_get_ok(LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_QueryShortChannelIdsDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_QueryShortChannelIdsDecodeErrorZ_get_err(LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_QueryShortChannelIdsDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKReplyShortChannelIdsEnd CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_ok(LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_err(LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKQueryChannelRange CResult_QueryChannelRangeDecodeErrorZ_get_ok(LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_QueryChannelRangeDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_QueryChannelRangeDecodeErrorZ_get_err(LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_QueryChannelRangeDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKReplyChannelRange CResult_ReplyChannelRangeDecodeErrorZ_get_ok(LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ReplyChannelRangeDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ReplyChannelRangeDecodeErrorZ_get_err(LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ReplyChannelRangeDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKGossipTimestampFilter CResult_GossipTimestampFilterDecodeErrorZ_get_ok(LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_GossipTimestampFilterDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_GossipTimestampFilterDecodeErrorZ_get_err(LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_GossipTimestampFilterDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_KeyPairZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_KeyPairZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_KeyPairZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_KeyPairZ_Some_get_some(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_KeyPairZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCOption_KeyPairZ CResult_COption_KeyPairZNoneZ_get_ok(LDKCResult_COption_KeyPairZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_KeyPairZNoneZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_KeyPairZNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_COption_KeyPairZNoneZ_get_err(LDKCResult_COption_KeyPairZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_KeyPairZNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_KeyPairZNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKInvoiceError CResult_InvoiceErrorDecodeErrorZ_get_ok(LDKCResult_InvoiceErrorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InvoiceErrorDecodeErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceErrorDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_InvoiceErrorDecodeErrorZ_get_err(LDKCResult_InvoiceErrorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InvoiceErrorDecodeErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceErrorDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export interface LDKFilter {
	register_tx (txid: number, script_pubkey: number): void;
	register_output (output: bigint): void;
}

/* @internal */
export function LDKFilter_new(impl: LDKFilter): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKFilter_new(i), i];
}
	// void Filter_register_tx LDKFilter *NONNULL_PTR this_arg, const uint8_t (*txid)[32], struct LDKu8slice script_pubkey
/* @internal */
export function Filter_register_tx(this_arg: bigint, txid: number, script_pubkey: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Filter_register_tx(this_arg, txid, script_pubkey);
	// debug statements here
}
	// void Filter_register_output LDKFilter *NONNULL_PTR this_arg, struct LDKWatchedOutput output
/* @internal */
export function Filter_register_output(this_arg: bigint, output: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Filter_register_output(this_arg, output);
	// debug statements here
}
/* @internal */
export class LDKCOption_FilterZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_FilterZ_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_FilterZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_FilterZ_Some_get_some(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_FilterZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKLockedChannelMonitor CResult_LockedChannelMonitorNoneZ_get_ok(LDKCResult_LockedChannelMonitorNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_LockedChannelMonitorNoneZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_LockedChannelMonitorNoneZ_get_err(LDKCResult_LockedChannelMonitorNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_LockedChannelMonitorNoneZ_get_err(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKOutPoint C2Tuple_OutPointCVec_MonitorUpdateIdZZ_get_a(LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_OutPointCVec_MonitorUpdateIdZZ_get_a(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointCVec_MonitorUpdateIdZZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKCVec_MonitorUpdateIdZ C2Tuple_OutPointCVec_MonitorUpdateIdZZ_get_b(LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_OutPointCVec_MonitorUpdateIdZZ_get_b(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointCVec_MonitorUpdateIdZZ_get_b(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKSignOrCreationError {
	protected constructor() {}
}
/* @internal */
export function LDKSignOrCreationError_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKSignOrCreationError_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKSignOrCreationError_CreationError_get_creation_error(ptr: bigint): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKSignOrCreationError_CreationError_get_creation_error(ptr);
	return nativeResponseValue;
}
	// struct LDKBolt11Invoice CResult_Bolt11InvoiceSignOrCreationErrorZ_get_ok(LDKCResult_Bolt11InvoiceSignOrCreationErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_Bolt11InvoiceSignOrCreationErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceSignOrCreationErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKSignOrCreationError CResult_Bolt11InvoiceSignOrCreationErrorZ_get_err(LDKCResult_Bolt11InvoiceSignOrCreationErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_Bolt11InvoiceSignOrCreationErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceSignOrCreationErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKBolt11ParseError {
	protected constructor() {}
}
/* @internal */
export function LDKBolt11ParseError_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBolt11ParseError_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBolt11ParseError_Bech32Error_get_bech32_error(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBolt11ParseError_Bech32Error_get_bech32_error(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBolt11ParseError_ParseAmountError_get_parse_amount_error(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBolt11ParseError_ParseAmountError_get_parse_amount_error(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBolt11ParseError_MalformedSignature_get_malformed_signature(ptr: bigint): Secp256k1Error {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBolt11ParseError_MalformedSignature_get_malformed_signature(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBolt11ParseError_DescriptionDecodeError_get_description_decode_error(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBolt11ParseError_DescriptionDecodeError_get_description_decode_error(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBolt11ParseError_InvalidSliceLength_get_invalid_slice_length(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBolt11ParseError_InvalidSliceLength_get_invalid_slice_length(ptr);
	return nativeResponseValue;
}
	// enum LDKSiPrefix CResult_SiPrefixBolt11ParseErrorZ_get_ok(LDKCResult_SiPrefixBolt11ParseErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SiPrefixBolt11ParseErrorZ_get_ok(owner: bigint): SiPrefix {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SiPrefixBolt11ParseErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError CResult_SiPrefixBolt11ParseErrorZ_get_err(LDKCResult_SiPrefixBolt11ParseErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SiPrefixBolt11ParseErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SiPrefixBolt11ParseErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKParseOrSemanticError {
	protected constructor() {}
}
/* @internal */
export function LDKParseOrSemanticError_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKParseOrSemanticError_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKParseOrSemanticError_ParseError_get_parse_error(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKParseOrSemanticError_ParseError_get_parse_error(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKParseOrSemanticError_SemanticError_get_semantic_error(ptr: bigint): Bolt11SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKParseOrSemanticError_SemanticError_get_semantic_error(ptr);
	return nativeResponseValue;
}
	// struct LDKBolt11Invoice CResult_Bolt11InvoiceParseOrSemanticErrorZ_get_ok(LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_Bolt11InvoiceParseOrSemanticErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceParseOrSemanticErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKParseOrSemanticError CResult_Bolt11InvoiceParseOrSemanticErrorZ_get_err(LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_Bolt11InvoiceParseOrSemanticErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceParseOrSemanticErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKSignedRawBolt11Invoice CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_get_ok(LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_get_err(LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_get_err(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKRawBolt11Invoice C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_get_a(LDKC3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ *NONNULL_PTR owner);
/* @internal */
export function C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_get_a(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_get_b(LDKC3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ *NONNULL_PTR owner);
/* @internal */
export function C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_get_b(owner: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKBolt11InvoiceSignature C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_get_c(LDKC3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ *NONNULL_PTR owner);
/* @internal */
export function C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_get_c(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_get_c(owner);
	return nativeResponseValue;
}
	// struct LDKPayeePubKey CResult_PayeePubKeyErrorZ_get_ok(LDKCResult_PayeePubKeyErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PayeePubKeyErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PayeePubKeyErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKSecp256k1Error CResult_PayeePubKeyErrorZ_get_err(LDKCResult_PayeePubKeyErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PayeePubKeyErrorZ_get_err(owner: bigint): Secp256k1Error {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PayeePubKeyErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKPositiveTimestamp CResult_PositiveTimestampCreationErrorZ_get_ok(LDKCResult_PositiveTimestampCreationErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PositiveTimestampCreationErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PositiveTimestampCreationErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKCreationError CResult_PositiveTimestampCreationErrorZ_get_err(LDKCResult_PositiveTimestampCreationErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PositiveTimestampCreationErrorZ_get_err(owner: bigint): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PositiveTimestampCreationErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// void CResult_NoneBolt11SemanticErrorZ_get_ok(LDKCResult_NoneBolt11SemanticErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneBolt11SemanticErrorZ_get_ok(owner: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneBolt11SemanticErrorZ_get_ok(owner);
	// debug statements here
}
	// enum LDKBolt11SemanticError CResult_NoneBolt11SemanticErrorZ_get_err(LDKCResult_NoneBolt11SemanticErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneBolt11SemanticErrorZ_get_err(owner: bigint): Bolt11SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneBolt11SemanticErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKBolt11Invoice CResult_Bolt11InvoiceBolt11SemanticErrorZ_get_ok(LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_Bolt11InvoiceBolt11SemanticErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceBolt11SemanticErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKBolt11SemanticError CResult_Bolt11InvoiceBolt11SemanticErrorZ_get_err(LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_Bolt11InvoiceBolt11SemanticErrorZ_get_err(owner: bigint): Bolt11SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceBolt11SemanticErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKDescription CResult_DescriptionCreationErrorZ_get_ok(LDKCResult_DescriptionCreationErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_DescriptionCreationErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DescriptionCreationErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKCreationError CResult_DescriptionCreationErrorZ_get_err(LDKCResult_DescriptionCreationErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_DescriptionCreationErrorZ_get_err(owner: bigint): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DescriptionCreationErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKPrivateRoute CResult_PrivateRouteCreationErrorZ_get_ok(LDKCResult_PrivateRouteCreationErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PrivateRouteCreationErrorZ_get_ok(owner: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PrivateRouteCreationErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKCreationError CResult_PrivateRouteCreationErrorZ_get_err(LDKCResult_PrivateRouteCreationErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PrivateRouteCreationErrorZ_get_err(owner: bigint): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PrivateRouteCreationErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export interface LDKScore {
	channel_penalty_msat (short_channel_id: bigint, source: bigint, target: bigint, usage: bigint, score_params: bigint): bigint;
	payment_path_failed (path: bigint, short_channel_id: bigint): void;
	payment_path_successful (path: bigint): void;
	probe_failed (path: bigint, short_channel_id: bigint): void;
	probe_successful (path: bigint): void;
	write (): number;
}

/* @internal */
export function LDKScore_new(impl: LDKScore): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKScore_new(i), i];
}
	// uint64_t Score_channel_penalty_msat LDKScore *NONNULL_PTR this_arg, uint64_t short_channel_id, const struct LDKNodeId *NONNULL_PTR source, const struct LDKNodeId *NONNULL_PTR target, struct LDKChannelUsage usage, const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR score_params
/* @internal */
export function Score_channel_penalty_msat(this_arg: bigint, short_channel_id: bigint, source: bigint, target: bigint, usage: bigint, score_params: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Score_channel_penalty_msat(this_arg, short_channel_id, source, target, usage, score_params);
	return nativeResponseValue;
}
	// void Score_payment_path_failed LDKScore *NONNULL_PTR this_arg, const struct LDKPath *NONNULL_PTR path, uint64_t short_channel_id
/* @internal */
export function Score_payment_path_failed(this_arg: bigint, path: bigint, short_channel_id: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Score_payment_path_failed(this_arg, path, short_channel_id);
	// debug statements here
}
	// void Score_payment_path_successful LDKScore *NONNULL_PTR this_arg, const struct LDKPath *NONNULL_PTR path
/* @internal */
export function Score_payment_path_successful(this_arg: bigint, path: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Score_payment_path_successful(this_arg, path);
	// debug statements here
}
	// void Score_probe_failed LDKScore *NONNULL_PTR this_arg, const struct LDKPath *NONNULL_PTR path, uint64_t short_channel_id
/* @internal */
export function Score_probe_failed(this_arg: bigint, path: bigint, short_channel_id: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Score_probe_failed(this_arg, path, short_channel_id);
	// debug statements here
}
	// void Score_probe_successful LDKScore *NONNULL_PTR this_arg, const struct LDKPath *NONNULL_PTR path
/* @internal */
export function Score_probe_successful(this_arg: bigint, path: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Score_probe_successful(this_arg, path);
	// debug statements here
}
	// LDKCVec_u8Z Score_write LDKScore *NONNULL_PTR this_arg
/* @internal */
export function Score_write(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Score_write(this_arg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKLockableScore {
	lock (): bigint;
}

/* @internal */
export function LDKLockableScore_new(impl: LDKLockableScore): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKLockableScore_new(i), i];
}
	// LDKScore LockableScore_lock LDKLockableScore *NONNULL_PTR this_arg
/* @internal */
export function LockableScore_lock(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LockableScore_lock(this_arg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKWriteableScore {
	write (): number;
}

/* @internal */
export function LDKWriteableScore_new(impl: LDKWriteableScore, LockableScore: number): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKWriteableScore_new(i, LockableScore), i];
}
	// LDKCVec_u8Z WriteableScore_write LDKWriteableScore *NONNULL_PTR this_arg
/* @internal */
export function WriteableScore_write(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WriteableScore_write(this_arg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKPersister {
	persist_manager (channel_manager: bigint): bigint;
	persist_graph (network_graph: bigint): bigint;
	persist_scorer (scorer: bigint): bigint;
}

/* @internal */
export function LDKPersister_new(impl: LDKPersister): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKPersister_new(i), i];
}
	// LDKCResult_NoneErrorZ Persister_persist_manager LDKPersister *NONNULL_PTR this_arg, const struct LDKChannelManager *NONNULL_PTR channel_manager
/* @internal */
export function Persister_persist_manager(this_arg: bigint, channel_manager: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Persister_persist_manager(this_arg, channel_manager);
	return nativeResponseValue;
}
	// LDKCResult_NoneErrorZ Persister_persist_graph LDKPersister *NONNULL_PTR this_arg, const struct LDKNetworkGraph *NONNULL_PTR network_graph
/* @internal */
export function Persister_persist_graph(this_arg: bigint, network_graph: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Persister_persist_graph(this_arg, network_graph);
	return nativeResponseValue;
}
	// LDKCResult_NoneErrorZ Persister_persist_scorer LDKPersister *NONNULL_PTR this_arg, const struct LDKWriteableScore *NONNULL_PTR scorer
/* @internal */
export function Persister_persist_scorer(this_arg: bigint, scorer: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Persister_persist_scorer(this_arg, scorer);
	return nativeResponseValue;
}
/* @internal */
export interface LDKFutureCallback {
	call (): void;
}

/* @internal */
export function LDKFutureCallback_new(impl: LDKFutureCallback): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKFutureCallback_new(i), i];
}
	// void FutureCallback_call LDKFutureCallback *NONNULL_PTR this_arg
/* @internal */
export function FutureCallback_call(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FutureCallback_call(this_arg);
	// debug statements here
}
/* @internal */
export interface LDKListen {
	filtered_block_connected (header: number, txdata: number, height: number): void;
	block_connected (block: number, height: number): void;
	block_disconnected (header: number, height: number): void;
}

/* @internal */
export function LDKListen_new(impl: LDKListen): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKListen_new(i), i];
}
	// void Listen_filtered_block_connected LDKListen *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height
/* @internal */
export function Listen_filtered_block_connected(this_arg: bigint, header: number, txdata: number, height: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Listen_filtered_block_connected(this_arg, header, txdata, height);
	// debug statements here
}
	// void Listen_block_connected LDKListen *NONNULL_PTR this_arg, struct LDKu8slice block, uint32_t height
/* @internal */
export function Listen_block_connected(this_arg: bigint, block: number, height: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Listen_block_connected(this_arg, block, height);
	// debug statements here
}
	// void Listen_block_disconnected LDKListen *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height
/* @internal */
export function Listen_block_disconnected(this_arg: bigint, header: number, height: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Listen_block_disconnected(this_arg, header, height);
	// debug statements here
}
/* @internal */
export interface LDKConfirm {
	transactions_confirmed (header: number, txdata: number, height: number): void;
	transaction_unconfirmed (txid: number): void;
	best_block_updated (header: number, height: number): void;
	get_relevant_txids (): number;
}

/* @internal */
export function LDKConfirm_new(impl: LDKConfirm): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKConfirm_new(i), i];
}
	// void Confirm_transactions_confirmed LDKConfirm *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height
/* @internal */
export function Confirm_transactions_confirmed(this_arg: bigint, header: number, txdata: number, height: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Confirm_transactions_confirmed(this_arg, header, txdata, height);
	// debug statements here
}
	// void Confirm_transaction_unconfirmed LDKConfirm *NONNULL_PTR this_arg, const uint8_t (*txid)[32]
/* @internal */
export function Confirm_transaction_unconfirmed(this_arg: bigint, txid: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Confirm_transaction_unconfirmed(this_arg, txid);
	// debug statements here
}
	// void Confirm_best_block_updated LDKConfirm *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height
/* @internal */
export function Confirm_best_block_updated(this_arg: bigint, header: number, height: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Confirm_best_block_updated(this_arg, header, height);
	// debug statements here
}
	// LDKCVec_C2Tuple_TxidCOption_BlockHashZZZ Confirm_get_relevant_txids LDKConfirm *NONNULL_PTR this_arg
/* @internal */
export function Confirm_get_relevant_txids(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Confirm_get_relevant_txids(this_arg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKPersist {
	persist_new_channel (channel_id: bigint, data: bigint, update_id: bigint): ChannelMonitorUpdateStatus;
	update_persisted_channel (channel_id: bigint, update: bigint, data: bigint, update_id: bigint): ChannelMonitorUpdateStatus;
}

/* @internal */
export function LDKPersist_new(impl: LDKPersist): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKPersist_new(i), i];
}
	// LDKChannelMonitorUpdateStatus Persist_persist_new_channel LDKPersist *NONNULL_PTR this_arg, struct LDKOutPoint channel_id, const struct LDKChannelMonitor *NONNULL_PTR data, struct LDKMonitorUpdateId update_id
/* @internal */
export function Persist_persist_new_channel(this_arg: bigint, channel_id: bigint, data: bigint, update_id: bigint): ChannelMonitorUpdateStatus {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Persist_persist_new_channel(this_arg, channel_id, data, update_id);
	return nativeResponseValue;
}
	// LDKChannelMonitorUpdateStatus Persist_update_persisted_channel LDKPersist *NONNULL_PTR this_arg, struct LDKOutPoint channel_id, struct LDKChannelMonitorUpdate update, const struct LDKChannelMonitor *NONNULL_PTR data, struct LDKMonitorUpdateId update_id
/* @internal */
export function Persist_update_persisted_channel(this_arg: bigint, channel_id: bigint, update: bigint, data: bigint, update_id: bigint): ChannelMonitorUpdateStatus {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Persist_update_persisted_channel(this_arg, channel_id, update, data, update_id);
	return nativeResponseValue;
}
/* @internal */
export interface LDKEventHandler {
	handle_event (event: bigint): void;
}

/* @internal */
export function LDKEventHandler_new(impl: LDKEventHandler): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKEventHandler_new(i), i];
}
	// void EventHandler_handle_event LDKEventHandler *NONNULL_PTR this_arg, struct LDKEvent event
/* @internal */
export function EventHandler_handle_event(this_arg: bigint, event: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EventHandler_handle_event(this_arg, event);
	// debug statements here
}
/* @internal */
export interface LDKEventsProvider {
	process_pending_events (handler: bigint): void;
}

/* @internal */
export function LDKEventsProvider_new(impl: LDKEventsProvider): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKEventsProvider_new(i), i];
}
	// void EventsProvider_process_pending_events LDKEventsProvider *NONNULL_PTR this_arg, struct LDKEventHandler handler
/* @internal */
export function EventsProvider_process_pending_events(this_arg: bigint, handler: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EventsProvider_process_pending_events(this_arg, handler);
	// debug statements here
}
/* @internal */
export class LDKRetry {
	protected constructor() {}
}
/* @internal */
export function LDKRetry_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKRetry_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKRetry_Attempts_get_attempts(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKRetry_Attempts_get_attempts(ptr);
	return nativeResponseValue;
}
/* @internal */
export interface LDKMessageSendEventsProvider {
	get_and_clear_pending_msg_events (): number;
}

/* @internal */
export function LDKMessageSendEventsProvider_new(impl: LDKMessageSendEventsProvider): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKMessageSendEventsProvider_new(i), i];
}
	// LDKCVec_MessageSendEventZ MessageSendEventsProvider_get_and_clear_pending_msg_events LDKMessageSendEventsProvider *NONNULL_PTR this_arg
/* @internal */
export function MessageSendEventsProvider_get_and_clear_pending_msg_events(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEventsProvider_get_and_clear_pending_msg_events(this_arg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKChannelMessageHandler {
	handle_open_channel (their_node_id: number, msg: bigint): void;
	handle_open_channel_v2 (their_node_id: number, msg: bigint): void;
	handle_accept_channel (their_node_id: number, msg: bigint): void;
	handle_accept_channel_v2 (their_node_id: number, msg: bigint): void;
	handle_funding_created (their_node_id: number, msg: bigint): void;
	handle_funding_signed (their_node_id: number, msg: bigint): void;
	handle_channel_ready (their_node_id: number, msg: bigint): void;
	handle_shutdown (their_node_id: number, msg: bigint): void;
	handle_closing_signed (their_node_id: number, msg: bigint): void;
	handle_tx_add_input (their_node_id: number, msg: bigint): void;
	handle_tx_add_output (their_node_id: number, msg: bigint): void;
	handle_tx_remove_input (their_node_id: number, msg: bigint): void;
	handle_tx_remove_output (their_node_id: number, msg: bigint): void;
	handle_tx_complete (their_node_id: number, msg: bigint): void;
	handle_tx_signatures (their_node_id: number, msg: bigint): void;
	handle_tx_init_rbf (their_node_id: number, msg: bigint): void;
	handle_tx_ack_rbf (their_node_id: number, msg: bigint): void;
	handle_tx_abort (their_node_id: number, msg: bigint): void;
	handle_update_add_htlc (their_node_id: number, msg: bigint): void;
	handle_update_fulfill_htlc (their_node_id: number, msg: bigint): void;
	handle_update_fail_htlc (their_node_id: number, msg: bigint): void;
	handle_update_fail_malformed_htlc (their_node_id: number, msg: bigint): void;
	handle_commitment_signed (their_node_id: number, msg: bigint): void;
	handle_revoke_and_ack (their_node_id: number, msg: bigint): void;
	handle_update_fee (their_node_id: number, msg: bigint): void;
	handle_announcement_signatures (their_node_id: number, msg: bigint): void;
	peer_disconnected (their_node_id: number): void;
	peer_connected (their_node_id: number, msg: bigint, inbound: boolean): bigint;
	handle_channel_reestablish (their_node_id: number, msg: bigint): void;
	handle_channel_update (their_node_id: number, msg: bigint): void;
	handle_error (their_node_id: number, msg: bigint): void;
	provided_node_features (): bigint;
	provided_init_features (their_node_id: number): bigint;
	get_genesis_hashes (): bigint;
}

/* @internal */
export function LDKChannelMessageHandler_new(impl: LDKChannelMessageHandler, MessageSendEventsProvider: number): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKChannelMessageHandler_new(i, MessageSendEventsProvider), i];
}
	// void ChannelMessageHandler_handle_open_channel LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKOpenChannel *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_open_channel(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_open_channel(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_open_channel_v2 LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKOpenChannelV2 *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_open_channel_v2(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_open_channel_v2(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_accept_channel LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKAcceptChannel *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_accept_channel(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_accept_channel(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_accept_channel_v2 LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKAcceptChannelV2 *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_accept_channel_v2(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_accept_channel_v2(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_funding_created LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingCreated *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_funding_created(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_funding_created(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_funding_signed LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingSigned *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_funding_signed(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_funding_signed(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_channel_ready LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelReady *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_channel_ready(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_channel_ready(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_shutdown LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKShutdown *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_shutdown(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_shutdown(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_closing_signed LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKClosingSigned *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_closing_signed(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_closing_signed(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_tx_add_input LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKTxAddInput *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_tx_add_input(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_tx_add_input(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_tx_add_output LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKTxAddOutput *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_tx_add_output(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_tx_add_output(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_tx_remove_input LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKTxRemoveInput *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_tx_remove_input(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_tx_remove_input(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_tx_remove_output LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKTxRemoveOutput *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_tx_remove_output(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_tx_remove_output(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_tx_complete LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKTxComplete *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_tx_complete(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_tx_complete(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_tx_signatures LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKTxSignatures *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_tx_signatures(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_tx_signatures(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_tx_init_rbf LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKTxInitRbf *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_tx_init_rbf(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_tx_init_rbf(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_tx_ack_rbf LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKTxAckRbf *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_tx_ack_rbf(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_tx_ack_rbf(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_tx_abort LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKTxAbort *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_tx_abort(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_tx_abort(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_update_add_htlc LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateAddHTLC *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_update_add_htlc(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_update_add_htlc(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_update_fulfill_htlc LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFulfillHTLC *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_update_fulfill_htlc(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_update_fulfill_htlc(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_update_fail_htlc LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFailHTLC *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_update_fail_htlc(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_update_fail_htlc(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_update_fail_malformed_htlc LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_update_fail_malformed_htlc(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_update_fail_malformed_htlc(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_commitment_signed LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKCommitmentSigned *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_commitment_signed(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_commitment_signed(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_revoke_and_ack LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKRevokeAndACK *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_revoke_and_ack(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_revoke_and_ack(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_update_fee LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFee *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_update_fee(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_update_fee(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_announcement_signatures LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKAnnouncementSignatures *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_announcement_signatures(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_announcement_signatures(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_peer_disconnected LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id
/* @internal */
export function ChannelMessageHandler_peer_disconnected(this_arg: bigint, their_node_id: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_peer_disconnected(this_arg, their_node_id);
	// debug statements here
}
	// LDKCResult_NoneNoneZ ChannelMessageHandler_peer_connected LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR msg, bool inbound
/* @internal */
export function ChannelMessageHandler_peer_connected(this_arg: bigint, their_node_id: number, msg: bigint, inbound: boolean): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_peer_connected(this_arg, their_node_id, msg, inbound);
	return nativeResponseValue;
}
	// void ChannelMessageHandler_handle_channel_reestablish LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelReestablish *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_channel_reestablish(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_channel_reestablish(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_channel_update LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelUpdate *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_channel_update(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_channel_update(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_error LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKErrorMessage *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_error(this_arg: bigint, their_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_error(this_arg, their_node_id, msg);
	// debug statements here
}
	// LDKNodeFeatures ChannelMessageHandler_provided_node_features LDKChannelMessageHandler *NONNULL_PTR this_arg
/* @internal */
export function ChannelMessageHandler_provided_node_features(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_provided_node_features(this_arg);
	return nativeResponseValue;
}
	// LDKInitFeatures ChannelMessageHandler_provided_init_features LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id
/* @internal */
export function ChannelMessageHandler_provided_init_features(this_arg: bigint, their_node_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_provided_init_features(this_arg, their_node_id);
	return nativeResponseValue;
}
	// LDKCOption_CVec_ChainHashZZ ChannelMessageHandler_get_genesis_hashes LDKChannelMessageHandler *NONNULL_PTR this_arg
/* @internal */
export function ChannelMessageHandler_get_genesis_hashes(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_get_genesis_hashes(this_arg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKRoutingMessageHandler {
	handle_node_announcement (msg: bigint): bigint;
	handle_channel_announcement (msg: bigint): bigint;
	handle_channel_update (msg: bigint): bigint;
	get_next_channel_announcement (starting_point: bigint): bigint;
	get_next_node_announcement (starting_point: bigint): bigint;
	peer_connected (their_node_id: number, init: bigint, inbound: boolean): bigint;
	handle_reply_channel_range (their_node_id: number, msg: bigint): bigint;
	handle_reply_short_channel_ids_end (their_node_id: number, msg: bigint): bigint;
	handle_query_channel_range (their_node_id: number, msg: bigint): bigint;
	handle_query_short_channel_ids (their_node_id: number, msg: bigint): bigint;
	processing_queue_high (): boolean;
	provided_node_features (): bigint;
	provided_init_features (their_node_id: number): bigint;
}

/* @internal */
export function LDKRoutingMessageHandler_new(impl: LDKRoutingMessageHandler, MessageSendEventsProvider: number): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKRoutingMessageHandler_new(i, MessageSendEventsProvider), i];
}
	// LDKCResult_boolLightningErrorZ RoutingMessageHandler_handle_node_announcement LDKRoutingMessageHandler *NONNULL_PTR this_arg, const struct LDKNodeAnnouncement *NONNULL_PTR msg
/* @internal */
export function RoutingMessageHandler_handle_node_announcement(this_arg: bigint, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_node_announcement(this_arg, msg);
	return nativeResponseValue;
}
	// LDKCResult_boolLightningErrorZ RoutingMessageHandler_handle_channel_announcement LDKRoutingMessageHandler *NONNULL_PTR this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg
/* @internal */
export function RoutingMessageHandler_handle_channel_announcement(this_arg: bigint, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_channel_announcement(this_arg, msg);
	return nativeResponseValue;
}
	// LDKCResult_boolLightningErrorZ RoutingMessageHandler_handle_channel_update LDKRoutingMessageHandler *NONNULL_PTR this_arg, const struct LDKChannelUpdate *NONNULL_PTR msg
/* @internal */
export function RoutingMessageHandler_handle_channel_update(this_arg: bigint, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_channel_update(this_arg, msg);
	return nativeResponseValue;
}
	// LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ RoutingMessageHandler_get_next_channel_announcement LDKRoutingMessageHandler *NONNULL_PTR this_arg, uint64_t starting_point
/* @internal */
export function RoutingMessageHandler_get_next_channel_announcement(this_arg: bigint, starting_point: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_get_next_channel_announcement(this_arg, starting_point);
	return nativeResponseValue;
}
	// LDKNodeAnnouncement RoutingMessageHandler_get_next_node_announcement LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKNodeId starting_point
/* @internal */
export function RoutingMessageHandler_get_next_node_announcement(this_arg: bigint, starting_point: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_get_next_node_announcement(this_arg, starting_point);
	return nativeResponseValue;
}
	// LDKCResult_NoneNoneZ RoutingMessageHandler_peer_connected LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR init, bool inbound
/* @internal */
export function RoutingMessageHandler_peer_connected(this_arg: bigint, their_node_id: number, init: bigint, inbound: boolean): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_peer_connected(this_arg, their_node_id, init, inbound);
	return nativeResponseValue;
}
	// LDKCResult_NoneLightningErrorZ RoutingMessageHandler_handle_reply_channel_range LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKReplyChannelRange msg
/* @internal */
export function RoutingMessageHandler_handle_reply_channel_range(this_arg: bigint, their_node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_reply_channel_range(this_arg, their_node_id, msg);
	return nativeResponseValue;
}
	// LDKCResult_NoneLightningErrorZ RoutingMessageHandler_handle_reply_short_channel_ids_end LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKReplyShortChannelIdsEnd msg
/* @internal */
export function RoutingMessageHandler_handle_reply_short_channel_ids_end(this_arg: bigint, their_node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_reply_short_channel_ids_end(this_arg, their_node_id, msg);
	return nativeResponseValue;
}
	// LDKCResult_NoneLightningErrorZ RoutingMessageHandler_handle_query_channel_range LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKQueryChannelRange msg
/* @internal */
export function RoutingMessageHandler_handle_query_channel_range(this_arg: bigint, their_node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_query_channel_range(this_arg, their_node_id, msg);
	return nativeResponseValue;
}
	// LDKCResult_NoneLightningErrorZ RoutingMessageHandler_handle_query_short_channel_ids LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKQueryShortChannelIds msg
/* @internal */
export function RoutingMessageHandler_handle_query_short_channel_ids(this_arg: bigint, their_node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_query_short_channel_ids(this_arg, their_node_id, msg);
	return nativeResponseValue;
}
	// bool RoutingMessageHandler_processing_queue_high LDKRoutingMessageHandler *NONNULL_PTR this_arg
/* @internal */
export function RoutingMessageHandler_processing_queue_high(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_processing_queue_high(this_arg);
	return nativeResponseValue;
}
	// LDKNodeFeatures RoutingMessageHandler_provided_node_features LDKRoutingMessageHandler *NONNULL_PTR this_arg
/* @internal */
export function RoutingMessageHandler_provided_node_features(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_provided_node_features(this_arg);
	return nativeResponseValue;
}
	// LDKInitFeatures RoutingMessageHandler_provided_init_features LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id
/* @internal */
export function RoutingMessageHandler_provided_init_features(this_arg: bigint, their_node_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_provided_init_features(this_arg, their_node_id);
	return nativeResponseValue;
}
/* @internal */
export interface LDKOnionMessageProvider {
	next_onion_message_for_peer (peer_node_id: number): bigint;
}

/* @internal */
export function LDKOnionMessageProvider_new(impl: LDKOnionMessageProvider): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKOnionMessageProvider_new(i), i];
}
	// LDKOnionMessage OnionMessageProvider_next_onion_message_for_peer LDKOnionMessageProvider *NONNULL_PTR this_arg, struct LDKPublicKey peer_node_id
/* @internal */
export function OnionMessageProvider_next_onion_message_for_peer(this_arg: bigint, peer_node_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessageProvider_next_onion_message_for_peer(this_arg, peer_node_id);
	return nativeResponseValue;
}
/* @internal */
export interface LDKOnionMessageHandler {
	handle_onion_message (peer_node_id: number, msg: bigint): void;
	peer_connected (their_node_id: number, init: bigint, inbound: boolean): bigint;
	peer_disconnected (their_node_id: number): void;
	provided_node_features (): bigint;
	provided_init_features (their_node_id: number): bigint;
}

/* @internal */
export function LDKOnionMessageHandler_new(impl: LDKOnionMessageHandler, OnionMessageProvider: number): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKOnionMessageHandler_new(i, OnionMessageProvider), i];
}
	// void OnionMessageHandler_handle_onion_message LDKOnionMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey peer_node_id, const struct LDKOnionMessage *NONNULL_PTR msg
/* @internal */
export function OnionMessageHandler_handle_onion_message(this_arg: bigint, peer_node_id: number, msg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessageHandler_handle_onion_message(this_arg, peer_node_id, msg);
	// debug statements here
}
	// LDKCResult_NoneNoneZ OnionMessageHandler_peer_connected LDKOnionMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR init, bool inbound
/* @internal */
export function OnionMessageHandler_peer_connected(this_arg: bigint, their_node_id: number, init: bigint, inbound: boolean): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessageHandler_peer_connected(this_arg, their_node_id, init, inbound);
	return nativeResponseValue;
}
	// void OnionMessageHandler_peer_disconnected LDKOnionMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id
/* @internal */
export function OnionMessageHandler_peer_disconnected(this_arg: bigint, their_node_id: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessageHandler_peer_disconnected(this_arg, their_node_id);
	// debug statements here
}
	// LDKNodeFeatures OnionMessageHandler_provided_node_features LDKOnionMessageHandler *NONNULL_PTR this_arg
/* @internal */
export function OnionMessageHandler_provided_node_features(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessageHandler_provided_node_features(this_arg);
	return nativeResponseValue;
}
	// LDKInitFeatures OnionMessageHandler_provided_init_features LDKOnionMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id
/* @internal */
export function OnionMessageHandler_provided_init_features(this_arg: bigint, their_node_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessageHandler_provided_init_features(this_arg, their_node_id);
	return nativeResponseValue;
}
/* @internal */
export interface LDKCustomMessageReader {
	read (message_type: number, buffer: number): bigint;
}

/* @internal */
export function LDKCustomMessageReader_new(impl: LDKCustomMessageReader): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKCustomMessageReader_new(i), i];
}
	// LDKCResult_COption_TypeZDecodeErrorZ CustomMessageReader_read LDKCustomMessageReader *NONNULL_PTR this_arg, uint16_t message_type, struct LDKu8slice buffer
/* @internal */
export function CustomMessageReader_read(this_arg: bigint, message_type: number, buffer: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomMessageReader_read(this_arg, message_type, buffer);
	return nativeResponseValue;
}
/* @internal */
export interface LDKCustomMessageHandler {
	handle_custom_message (msg: bigint, sender_node_id: number): bigint;
	get_and_clear_pending_msg (): number;
	provided_node_features (): bigint;
	provided_init_features (their_node_id: number): bigint;
}

/* @internal */
export function LDKCustomMessageHandler_new(impl: LDKCustomMessageHandler, CustomMessageReader: number): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKCustomMessageHandler_new(i, CustomMessageReader), i];
}
	// LDKCResult_NoneLightningErrorZ CustomMessageHandler_handle_custom_message LDKCustomMessageHandler *NONNULL_PTR this_arg, struct LDKType msg, struct LDKPublicKey sender_node_id
/* @internal */
export function CustomMessageHandler_handle_custom_message(this_arg: bigint, msg: bigint, sender_node_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomMessageHandler_handle_custom_message(this_arg, msg, sender_node_id);
	return nativeResponseValue;
}
	// LDKCVec_C2Tuple_PublicKeyTypeZZ CustomMessageHandler_get_and_clear_pending_msg LDKCustomMessageHandler *NONNULL_PTR this_arg
/* @internal */
export function CustomMessageHandler_get_and_clear_pending_msg(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomMessageHandler_get_and_clear_pending_msg(this_arg);
	return nativeResponseValue;
}
	// LDKNodeFeatures CustomMessageHandler_provided_node_features LDKCustomMessageHandler *NONNULL_PTR this_arg
/* @internal */
export function CustomMessageHandler_provided_node_features(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomMessageHandler_provided_node_features(this_arg);
	return nativeResponseValue;
}
	// LDKInitFeatures CustomMessageHandler_provided_init_features LDKCustomMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id
/* @internal */
export function CustomMessageHandler_provided_init_features(this_arg: bigint, their_node_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomMessageHandler_provided_init_features(this_arg, their_node_id);
	return nativeResponseValue;
}
/* @internal */
export interface LDKOffersMessageHandler {
	handle_message (message: bigint): bigint;
}

/* @internal */
export function LDKOffersMessageHandler_new(impl: LDKOffersMessageHandler): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKOffersMessageHandler_new(i), i];
}
	// LDKCOption_OffersMessageZ OffersMessageHandler_handle_message LDKOffersMessageHandler *NONNULL_PTR this_arg, struct LDKOffersMessage message
/* @internal */
export function OffersMessageHandler_handle_message(this_arg: bigint, message: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OffersMessageHandler_handle_message(this_arg, message);
	return nativeResponseValue;
}
/* @internal */
export interface LDKCustomOnionMessageHandler {
	handle_custom_message (msg: bigint): bigint;
	read_custom_message (message_type: bigint, buffer: number): bigint;
}

/* @internal */
export function LDKCustomOnionMessageHandler_new(impl: LDKCustomOnionMessageHandler): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKCustomOnionMessageHandler_new(i), i];
}
	// LDKCOption_CustomOnionMessageContentsZ CustomOnionMessageHandler_handle_custom_message LDKCustomOnionMessageHandler *NONNULL_PTR this_arg, struct LDKCustomOnionMessageContents msg
/* @internal */
export function CustomOnionMessageHandler_handle_custom_message(this_arg: bigint, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomOnionMessageHandler_handle_custom_message(this_arg, msg);
	return nativeResponseValue;
}
	// LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ CustomOnionMessageHandler_read_custom_message LDKCustomOnionMessageHandler *NONNULL_PTR this_arg, uint64_t message_type, struct LDKu8slice buffer
/* @internal */
export function CustomOnionMessageHandler_read_custom_message(this_arg: bigint, message_type: bigint, buffer: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomOnionMessageHandler_read_custom_message(this_arg, message_type, buffer);
	return nativeResponseValue;
}
/* @internal */
export interface LDKSocketDescriptor {
	send_data (data: number, resume_read: boolean): number;
	disconnect_socket (): void;
	eq (other_arg: bigint): boolean;
	hash (): bigint;
}

/* @internal */
export function LDKSocketDescriptor_new(impl: LDKSocketDescriptor): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKSocketDescriptor_new(i), i];
}
	// uintptr_t SocketDescriptor_send_data LDKSocketDescriptor *NONNULL_PTR this_arg, struct LDKu8slice data, bool resume_read
/* @internal */
export function SocketDescriptor_send_data(this_arg: bigint, data: number, resume_read: boolean): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SocketDescriptor_send_data(this_arg, data, resume_read);
	return nativeResponseValue;
}
	// void SocketDescriptor_disconnect_socket LDKSocketDescriptor *NONNULL_PTR this_arg
/* @internal */
export function SocketDescriptor_disconnect_socket(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SocketDescriptor_disconnect_socket(this_arg);
	// debug statements here
}
	// uint64_t SocketDescriptor_hash LDKSocketDescriptor *NONNULL_PTR this_arg
/* @internal */
export function SocketDescriptor_hash(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SocketDescriptor_hash(this_arg);
	return nativeResponseValue;
}
/* @internal */
export class LDKEffectiveCapacity {
	protected constructor() {}
}
/* @internal */
export function LDKEffectiveCapacity_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEffectiveCapacity_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEffectiveCapacity_ExactLiquidity_get_liquidity_msat(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEffectiveCapacity_ExactLiquidity_get_liquidity_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEffectiveCapacity_AdvertisedMaxHTLC_get_amount_msat(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEffectiveCapacity_AdvertisedMaxHTLC_get_amount_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEffectiveCapacity_Total_get_capacity_msat(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEffectiveCapacity_Total_get_capacity_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEffectiveCapacity_Total_get_htlc_maximum_msat(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEffectiveCapacity_Total_get_htlc_maximum_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEffectiveCapacity_HintMaxHTLC_get_amount_msat(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEffectiveCapacity_HintMaxHTLC_get_amount_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKPayee {
	protected constructor() {}
}
/* @internal */
export function LDKPayee_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPayee_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPayee_Blinded_get_route_hints(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPayee_Blinded_get_route_hints(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPayee_Blinded_get_features(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPayee_Blinded_get_features(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPayee_Clear_get_node_id(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPayee_Clear_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPayee_Clear_get_route_hints(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPayee_Clear_get_route_hints(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPayee_Clear_get_features(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPayee_Clear_get_features(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPayee_Clear_get_final_cltv_expiry_delta(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPayee_Clear_get_final_cltv_expiry_delta(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKDestination {
	protected constructor() {}
}
/* @internal */
export function LDKDestination_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKDestination_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKDestination_Node_get_node(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKDestination_Node_get_node(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKDestination_BlindedPath_get_blinded_path(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKDestination_BlindedPath_get_blinded_path(ptr);
	return nativeResponseValue;
}
/* @internal */
export interface LDKMessageRouter {
	find_path (sender: number, peers: number, destination: bigint): bigint;
}

/* @internal */
export function LDKMessageRouter_new(impl: LDKMessageRouter): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKMessageRouter_new(i), i];
}
	// LDKCResult_OnionMessagePathNoneZ MessageRouter_find_path LDKMessageRouter *NONNULL_PTR this_arg, struct LDKPublicKey sender, struct LDKCVec_PublicKeyZ peers, struct LDKDestination destination
/* @internal */
export function MessageRouter_find_path(this_arg: bigint, sender: number, peers: number, destination: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageRouter_find_path(this_arg, sender, peers, destination);
	return nativeResponseValue;
}
/* @internal */
export class LDKOnionMessageContents {
	protected constructor() {}
}
/* @internal */
export function LDKOnionMessageContents_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKOnionMessageContents_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKOnionMessageContents_Offers_get_offers(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKOnionMessageContents_Offers_get_offers(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKOnionMessageContents_Custom_get_custom(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKOnionMessageContents_Custom_get_custom(ptr);
	return nativeResponseValue;
}
/* @internal */
export interface LDKCoinSelectionSource {
	select_confirmed_utxos (claim_id: number, must_spend: number, must_pay_to: number, target_feerate_sat_per_1000_weight: number): bigint;
	sign_tx (tx: number): bigint;
}

/* @internal */
export function LDKCoinSelectionSource_new(impl: LDKCoinSelectionSource): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKCoinSelectionSource_new(i), i];
}
	// LDKCResult_CoinSelectionNoneZ CoinSelectionSource_select_confirmed_utxos LDKCoinSelectionSource *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes claim_id, struct LDKCVec_InputZ must_spend, struct LDKCVec_TxOutZ must_pay_to, uint32_t target_feerate_sat_per_1000_weight
/* @internal */
export function CoinSelectionSource_select_confirmed_utxos(this_arg: bigint, claim_id: number, must_spend: number, must_pay_to: number, target_feerate_sat_per_1000_weight: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CoinSelectionSource_select_confirmed_utxos(this_arg, claim_id, must_spend, must_pay_to, target_feerate_sat_per_1000_weight);
	return nativeResponseValue;
}
	// LDKCResult_TransactionNoneZ CoinSelectionSource_sign_tx LDKCoinSelectionSource *NONNULL_PTR this_arg, struct LDKTransaction tx
/* @internal */
export function CoinSelectionSource_sign_tx(this_arg: bigint, tx: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CoinSelectionSource_sign_tx(this_arg, tx);
	return nativeResponseValue;
}
/* @internal */
export interface LDKWalletSource {
	list_confirmed_utxos (): bigint;
	get_change_script (): bigint;
	sign_tx (tx: number): bigint;
}

/* @internal */
export function LDKWalletSource_new(impl: LDKWalletSource): [bigint, number] {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return [wasm.TS_LDKWalletSource_new(i), i];
}
	// LDKCResult_CVec_UtxoZNoneZ WalletSource_list_confirmed_utxos LDKWalletSource *NONNULL_PTR this_arg
/* @internal */
export function WalletSource_list_confirmed_utxos(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WalletSource_list_confirmed_utxos(this_arg);
	return nativeResponseValue;
}
	// LDKCResult_ScriptNoneZ WalletSource_get_change_script LDKWalletSource *NONNULL_PTR this_arg
/* @internal */
export function WalletSource_get_change_script(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WalletSource_get_change_script(this_arg);
	return nativeResponseValue;
}
	// LDKCResult_TransactionNoneZ WalletSource_sign_tx LDKWalletSource *NONNULL_PTR this_arg, struct LDKTransaction tx
/* @internal */
export function WalletSource_sign_tx(this_arg: bigint, tx: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WalletSource_sign_tx(this_arg, tx);
	return nativeResponseValue;
}
/* @internal */
export class LDKGossipSync {
	protected constructor() {}
}
/* @internal */
export function LDKGossipSync_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKGossipSync_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKGossipSync_P2P_get_p2p(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKGossipSync_P2P_get_p2p(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKGossipSync_Rapid_get_rapid(ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKGossipSync_Rapid_get_rapid(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKFallback {
	protected constructor() {}
}
/* @internal */
export function LDKFallback_ty_from_ptr(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKFallback_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKFallback_SegWitProgram_get_version(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKFallback_SegWitProgram_get_version(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKFallback_SegWitProgram_get_program(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKFallback_SegWitProgram_get_program(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKFallback_PubKeyHash_get_pub_key_hash(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKFallback_PubKeyHash_get_pub_key_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKFallback_ScriptHash_get_script_hash(ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKFallback_ScriptHash_get_script_hash(ptr);
	return nativeResponseValue;
}
	// struct LDKStr _ldk_get_compiled_version(void);
/* @internal */
export function _ldk_get_compiled_version(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS__ldk_get_compiled_version();
	return nativeResponseValue;
}
	// struct LDKStr _ldk_c_bindings_get_compiled_version(void);
/* @internal */
export function _ldk_c_bindings_get_compiled_version(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS__ldk_c_bindings_get_compiled_version();
	return nativeResponseValue;
}
	// struct LDKSixteenBytes U128_le_bytes(struct LDKU128 val);
/* @internal */
export function U128_le_bytes(val: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_U128_le_bytes(val);
	return nativeResponseValue;
}
	// struct LDKU128 U128_new(struct LDKSixteenBytes le_bytes);
/* @internal */
export function U128_new(le_bytes: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_U128_new(le_bytes);
	return nativeResponseValue;
}
	// struct LDKBigEndianScalar BigEndianScalar_new(struct LDKThirtyTwoBytes big_endian_bytes);
/* @internal */
export function BigEndianScalar_new(big_endian_bytes: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BigEndianScalar_new(big_endian_bytes);
	return nativeResponseValue;
}
	// uint64_t Bech32Error_clone_ptr(LDKBech32Error *NONNULL_PTR arg);
/* @internal */
export function Bech32Error_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bech32Error_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBech32Error Bech32Error_clone(const struct LDKBech32Error *NONNULL_PTR orig);
/* @internal */
export function Bech32Error_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bech32Error_clone(orig);
	return nativeResponseValue;
}
	// void Bech32Error_free(struct LDKBech32Error o);
/* @internal */
export function Bech32Error_free(o: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bech32Error_free(o);
	// debug statements here
}
	// void Transaction_free(struct LDKTransaction _res);
/* @internal */
export function Transaction_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Transaction_free(_res);
	// debug statements here
}
	// void Witness_free(struct LDKWitness _res);
/* @internal */
export function Witness_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Witness_free(_res);
	// debug statements here
}
	// void TxIn_free(struct LDKTxIn _res);
/* @internal */
export function TxIn_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxIn_free(_res);
	// debug statements here
}
	// struct LDKTxIn TxIn_new(struct LDKWitness witness, struct LDKCVec_u8Z script_sig, uint32_t sequence, struct LDKThirtyTwoBytes previous_txid, uint32_t previous_vout);
/* @internal */
export function TxIn_new(witness: number, script_sig: number, sequence: number, previous_txid: number, previous_vout: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxIn_new(witness, script_sig, sequence, previous_txid, previous_vout);
	return nativeResponseValue;
}
	// struct LDKTxOut TxOut_new(struct LDKCVec_u8Z script_pubkey, uint64_t value);
/* @internal */
export function TxOut_new(script_pubkey: number, value: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxOut_new(script_pubkey, value);
	return nativeResponseValue;
}
	// void TxOut_free(struct LDKTxOut _res);
/* @internal */
export function TxOut_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxOut_free(_res);
	// debug statements here
}
	// uint64_t TxOut_clone_ptr(LDKTxOut *NONNULL_PTR arg);
/* @internal */
export function TxOut_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxOut_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKTxOut TxOut_clone(const struct LDKTxOut *NONNULL_PTR orig);
/* @internal */
export function TxOut_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxOut_clone(orig);
	return nativeResponseValue;
}
	// void Str_free(struct LDKStr _res);
/* @internal */
export function Str_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Str_free(_res);
	// debug statements here
}
	// struct LDKCOption_DurationZ COption_DurationZ_some(uint64_t o);
/* @internal */
export function COption_DurationZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_DurationZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_DurationZ COption_DurationZ_none(void);
/* @internal */
export function COption_DurationZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_DurationZ_none();
	return nativeResponseValue;
}
	// void COption_DurationZ_free(struct LDKCOption_DurationZ _res);
/* @internal */
export function COption_DurationZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_DurationZ_free(_res);
	// debug statements here
}
	// uint64_t COption_DurationZ_clone_ptr(LDKCOption_DurationZ *NONNULL_PTR arg);
/* @internal */
export function COption_DurationZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_DurationZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_DurationZ COption_DurationZ_clone(const struct LDKCOption_DurationZ *NONNULL_PTR orig);
/* @internal */
export function COption_DurationZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_DurationZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_BlindedPathZ_free(struct LDKCVec_BlindedPathZ _res);
/* @internal */
export function CVec_BlindedPathZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_BlindedPathZ_free(_res);
	// debug statements here
}
	// struct LDKCOption_u64Z COption_u64Z_some(uint64_t o);
/* @internal */
export function COption_u64Z_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u64Z_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_u64Z COption_u64Z_none(void);
/* @internal */
export function COption_u64Z_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u64Z_none();
	return nativeResponseValue;
}
	// void COption_u64Z_free(struct LDKCOption_u64Z _res);
/* @internal */
export function COption_u64Z_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u64Z_free(_res);
	// debug statements here
}
	// uint64_t COption_u64Z_clone_ptr(LDKCOption_u64Z *NONNULL_PTR arg);
/* @internal */
export function COption_u64Z_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u64Z_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_u64Z COption_u64Z_clone(const struct LDKCOption_u64Z *NONNULL_PTR orig);
/* @internal */
export function COption_u64Z_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u64Z_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_RefundBolt12ParseErrorZ CResult_RefundBolt12ParseErrorZ_ok(struct LDKRefund o);
/* @internal */
export function CResult_RefundBolt12ParseErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RefundBolt12ParseErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RefundBolt12ParseErrorZ CResult_RefundBolt12ParseErrorZ_err(struct LDKBolt12ParseError e);
/* @internal */
export function CResult_RefundBolt12ParseErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RefundBolt12ParseErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RefundBolt12ParseErrorZ_is_ok(const struct LDKCResult_RefundBolt12ParseErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RefundBolt12ParseErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RefundBolt12ParseErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RefundBolt12ParseErrorZ_free(struct LDKCResult_RefundBolt12ParseErrorZ _res);
/* @internal */
export function CResult_RefundBolt12ParseErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RefundBolt12ParseErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_RefundBolt12ParseErrorZ_clone_ptr(LDKCResult_RefundBolt12ParseErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RefundBolt12ParseErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RefundBolt12ParseErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RefundBolt12ParseErrorZ CResult_RefundBolt12ParseErrorZ_clone(const struct LDKCResult_RefundBolt12ParseErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RefundBolt12ParseErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RefundBolt12ParseErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_ok(void);
/* @internal */
export function CResult_NoneAPIErrorZ_ok(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_ok();
	return nativeResponseValue;
}
	// struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_err(struct LDKAPIError e);
/* @internal */
export function CResult_NoneAPIErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NoneAPIErrorZ_is_ok(const struct LDKCResult_NoneAPIErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NoneAPIErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NoneAPIErrorZ_free(struct LDKCResult_NoneAPIErrorZ _res);
/* @internal */
export function CResult_NoneAPIErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_NoneAPIErrorZ_clone_ptr(LDKCResult_NoneAPIErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NoneAPIErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_clone(const struct LDKCResult_NoneAPIErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NoneAPIErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_CResult_NoneAPIErrorZZ_free(struct LDKCVec_CResult_NoneAPIErrorZZ _res);
/* @internal */
export function CVec_CResult_NoneAPIErrorZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_CResult_NoneAPIErrorZZ_free(_res);
	// debug statements here
}
	// void CVec_APIErrorZ_free(struct LDKCVec_APIErrorZ _res);
/* @internal */
export function CVec_APIErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_APIErrorZ_free(_res);
	// debug statements here
}
	// struct LDKCOption_PaymentSecretZ COption_PaymentSecretZ_some(struct LDKThirtyTwoBytes o);
/* @internal */
export function COption_PaymentSecretZ_some(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentSecretZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_PaymentSecretZ COption_PaymentSecretZ_none(void);
/* @internal */
export function COption_PaymentSecretZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentSecretZ_none();
	return nativeResponseValue;
}
	// void COption_PaymentSecretZ_free(struct LDKCOption_PaymentSecretZ _res);
/* @internal */
export function COption_PaymentSecretZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentSecretZ_free(_res);
	// debug statements here
}
	// uint64_t COption_PaymentSecretZ_clone_ptr(LDKCOption_PaymentSecretZ *NONNULL_PTR arg);
/* @internal */
export function COption_PaymentSecretZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentSecretZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_PaymentSecretZ COption_PaymentSecretZ_clone(const struct LDKCOption_PaymentSecretZ *NONNULL_PTR orig);
/* @internal */
export function COption_PaymentSecretZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentSecretZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_u8Z_free(struct LDKCVec_u8Z _res);
/* @internal */
export function CVec_u8Z_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_u8Z_free(_res);
	// debug statements here
}
	// struct LDKCOption_CVec_u8ZZ COption_CVec_u8ZZ_some(struct LDKCVec_u8Z o);
/* @internal */
export function COption_CVec_u8ZZ_some(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_u8ZZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_CVec_u8ZZ COption_CVec_u8ZZ_none(void);
/* @internal */
export function COption_CVec_u8ZZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_u8ZZ_none();
	return nativeResponseValue;
}
	// void COption_CVec_u8ZZ_free(struct LDKCOption_CVec_u8ZZ _res);
/* @internal */
export function COption_CVec_u8ZZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_u8ZZ_free(_res);
	// debug statements here
}
	// uint64_t COption_CVec_u8ZZ_clone_ptr(LDKCOption_CVec_u8ZZ *NONNULL_PTR arg);
/* @internal */
export function COption_CVec_u8ZZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_u8ZZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_CVec_u8ZZ COption_CVec_u8ZZ_clone(const struct LDKCOption_CVec_u8ZZ *NONNULL_PTR orig);
/* @internal */
export function COption_CVec_u8ZZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_u8ZZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_RecipientOnionFieldsDecodeErrorZ CResult_RecipientOnionFieldsDecodeErrorZ_ok(struct LDKRecipientOnionFields o);
/* @internal */
export function CResult_RecipientOnionFieldsDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecipientOnionFieldsDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RecipientOnionFieldsDecodeErrorZ CResult_RecipientOnionFieldsDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_RecipientOnionFieldsDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecipientOnionFieldsDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RecipientOnionFieldsDecodeErrorZ_is_ok(const struct LDKCResult_RecipientOnionFieldsDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RecipientOnionFieldsDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecipientOnionFieldsDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RecipientOnionFieldsDecodeErrorZ_free(struct LDKCResult_RecipientOnionFieldsDecodeErrorZ _res);
/* @internal */
export function CResult_RecipientOnionFieldsDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecipientOnionFieldsDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_RecipientOnionFieldsDecodeErrorZ_clone_ptr(LDKCResult_RecipientOnionFieldsDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RecipientOnionFieldsDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecipientOnionFieldsDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RecipientOnionFieldsDecodeErrorZ CResult_RecipientOnionFieldsDecodeErrorZ_clone(const struct LDKCResult_RecipientOnionFieldsDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RecipientOnionFieldsDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecipientOnionFieldsDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_OffersMessageZ COption_OffersMessageZ_some(struct LDKOffersMessage o);
/* @internal */
export function COption_OffersMessageZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_OffersMessageZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_OffersMessageZ COption_OffersMessageZ_none(void);
/* @internal */
export function COption_OffersMessageZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_OffersMessageZ_none();
	return nativeResponseValue;
}
	// void COption_OffersMessageZ_free(struct LDKCOption_OffersMessageZ _res);
/* @internal */
export function COption_OffersMessageZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_OffersMessageZ_free(_res);
	// debug statements here
}
	// uint64_t COption_OffersMessageZ_clone_ptr(LDKCOption_OffersMessageZ *NONNULL_PTR arg);
/* @internal */
export function COption_OffersMessageZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_OffersMessageZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_OffersMessageZ COption_OffersMessageZ_clone(const struct LDKCOption_OffersMessageZ *NONNULL_PTR orig);
/* @internal */
export function COption_OffersMessageZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_OffersMessageZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_OffersMessageDecodeErrorZ CResult_OffersMessageDecodeErrorZ_ok(struct LDKOffersMessage o);
/* @internal */
export function CResult_OffersMessageDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OffersMessageDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_OffersMessageDecodeErrorZ CResult_OffersMessageDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_OffersMessageDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OffersMessageDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_OffersMessageDecodeErrorZ_is_ok(const struct LDKCResult_OffersMessageDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_OffersMessageDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OffersMessageDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_OffersMessageDecodeErrorZ_free(struct LDKCResult_OffersMessageDecodeErrorZ _res);
/* @internal */
export function CResult_OffersMessageDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OffersMessageDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_OffersMessageDecodeErrorZ_clone_ptr(LDKCResult_OffersMessageDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_OffersMessageDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OffersMessageDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_OffersMessageDecodeErrorZ CResult_OffersMessageDecodeErrorZ_clone(const struct LDKCResult_OffersMessageDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_OffersMessageDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OffersMessageDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_HTLCClaimZ COption_HTLCClaimZ_some(enum LDKHTLCClaim o);
/* @internal */
export function COption_HTLCClaimZ_some(o: HTLCClaim): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_HTLCClaimZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_HTLCClaimZ COption_HTLCClaimZ_none(void);
/* @internal */
export function COption_HTLCClaimZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_HTLCClaimZ_none();
	return nativeResponseValue;
}
	// void COption_HTLCClaimZ_free(struct LDKCOption_HTLCClaimZ _res);
/* @internal */
export function COption_HTLCClaimZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_HTLCClaimZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_ok(void);
/* @internal */
export function CResult_NoneNoneZ_ok(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_ok();
	return nativeResponseValue;
}
	// struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_err(void);
/* @internal */
export function CResult_NoneNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_NoneNoneZ_is_ok(const struct LDKCResult_NoneNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_NoneNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NoneNoneZ_free(struct LDKCResult_NoneNoneZ _res);
/* @internal */
export function CResult_NoneNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_NoneNoneZ_clone_ptr(LDKCResult_NoneNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NoneNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_clone(const struct LDKCResult_NoneNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NoneNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CResult_CounterpartyCommitmentSecretsDecodeErrorZ_ok(struct LDKCounterpartyCommitmentSecrets o);
/* @internal */
export function CResult_CounterpartyCommitmentSecretsDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyCommitmentSecretsDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CResult_CounterpartyCommitmentSecretsDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_CounterpartyCommitmentSecretsDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyCommitmentSecretsDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_CounterpartyCommitmentSecretsDecodeErrorZ_is_ok(const struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_CounterpartyCommitmentSecretsDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyCommitmentSecretsDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CounterpartyCommitmentSecretsDecodeErrorZ_free(struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ _res);
/* @internal */
export function CResult_CounterpartyCommitmentSecretsDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyCommitmentSecretsDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone_ptr(LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone(const struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_ok(struct LDKTxCreationKeys o);
/* @internal */
export function CResult_TxCreationKeysDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_TxCreationKeysDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_TxCreationKeysDecodeErrorZ_is_ok(const struct LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_TxCreationKeysDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TxCreationKeysDecodeErrorZ_free(struct LDKCResult_TxCreationKeysDecodeErrorZ _res);
/* @internal */
export function CResult_TxCreationKeysDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_TxCreationKeysDecodeErrorZ_clone_ptr(LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TxCreationKeysDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_clone(const struct LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TxCreationKeysDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_ok(struct LDKChannelPublicKeys o);
/* @internal */
export function CResult_ChannelPublicKeysDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelPublicKeysDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelPublicKeysDecodeErrorZ_is_ok(const struct LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelPublicKeysDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelPublicKeysDecodeErrorZ_free(struct LDKCResult_ChannelPublicKeysDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelPublicKeysDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ChannelPublicKeysDecodeErrorZ_clone_ptr(LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelPublicKeysDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_clone(const struct LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelPublicKeysDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_u32Z COption_u32Z_some(uint32_t o);
/* @internal */
export function COption_u32Z_some(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u32Z_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_u32Z COption_u32Z_none(void);
/* @internal */
export function COption_u32Z_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u32Z_none();
	return nativeResponseValue;
}
	// void COption_u32Z_free(struct LDKCOption_u32Z _res);
/* @internal */
export function COption_u32Z_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u32Z_free(_res);
	// debug statements here
}
	// uint64_t COption_u32Z_clone_ptr(LDKCOption_u32Z *NONNULL_PTR arg);
/* @internal */
export function COption_u32Z_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u32Z_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_u32Z COption_u32Z_clone(const struct LDKCOption_u32Z *NONNULL_PTR orig);
/* @internal */
export function COption_u32Z_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u32Z_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(struct LDKHTLCOutputInCommitment o);
/* @internal */
export function CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_HTLCOutputInCommitmentDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(const struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_HTLCOutputInCommitmentDecodeErrorZ_free(struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ _res);
/* @internal */
export function CResult_HTLCOutputInCommitmentDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_HTLCOutputInCommitmentDecodeErrorZ_clone_ptr(LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_HTLCOutputInCommitmentDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(const struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_PaymentPreimageZ COption_PaymentPreimageZ_some(struct LDKThirtyTwoBytes o);
/* @internal */
export function COption_PaymentPreimageZ_some(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentPreimageZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_PaymentPreimageZ COption_PaymentPreimageZ_none(void);
/* @internal */
export function COption_PaymentPreimageZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentPreimageZ_none();
	return nativeResponseValue;
}
	// void COption_PaymentPreimageZ_free(struct LDKCOption_PaymentPreimageZ _res);
/* @internal */
export function COption_PaymentPreimageZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentPreimageZ_free(_res);
	// debug statements here
}
	// uint64_t COption_PaymentPreimageZ_clone_ptr(LDKCOption_PaymentPreimageZ *NONNULL_PTR arg);
/* @internal */
export function COption_PaymentPreimageZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentPreimageZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_PaymentPreimageZ COption_PaymentPreimageZ_clone(const struct LDKCOption_PaymentPreimageZ *NONNULL_PTR orig);
/* @internal */
export function COption_PaymentPreimageZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentPreimageZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(struct LDKCounterpartyChannelTransactionParameters o);
/* @internal */
export function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(const struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ _res);
/* @internal */
export function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone_ptr(LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(const struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_ok(struct LDKChannelTransactionParameters o);
/* @internal */
export function CResult_ChannelTransactionParametersDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelTransactionParametersDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(const struct LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelTransactionParametersDecodeErrorZ_free(struct LDKCResult_ChannelTransactionParametersDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelTransactionParametersDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ChannelTransactionParametersDecodeErrorZ_clone_ptr(LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelTransactionParametersDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_clone(const struct LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelTransactionParametersDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_SignatureZ_free(struct LDKCVec_SignatureZ _res);
/* @internal */
export function CVec_SignatureZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_SignatureZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_ok(struct LDKHolderCommitmentTransaction o);
/* @internal */
export function CResult_HolderCommitmentTransactionDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_HolderCommitmentTransactionDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_HolderCommitmentTransactionDecodeErrorZ_free(struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ _res);
/* @internal */
export function CResult_HolderCommitmentTransactionDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_HolderCommitmentTransactionDecodeErrorZ_clone_ptr(LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_HolderCommitmentTransactionDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_HolderCommitmentTransactionDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(struct LDKBuiltCommitmentTransaction o);
/* @internal */
export function CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_BuiltCommitmentTransactionDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_BuiltCommitmentTransactionDecodeErrorZ_free(struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ _res);
/* @internal */
export function CResult_BuiltCommitmentTransactionDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_BuiltCommitmentTransactionDecodeErrorZ_clone_ptr(LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_BuiltCommitmentTransactionDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TrustedClosingTransactionNoneZ CResult_TrustedClosingTransactionNoneZ_ok(struct LDKTrustedClosingTransaction o);
/* @internal */
export function CResult_TrustedClosingTransactionNoneZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TrustedClosingTransactionNoneZ CResult_TrustedClosingTransactionNoneZ_err(void);
/* @internal */
export function CResult_TrustedClosingTransactionNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_TrustedClosingTransactionNoneZ_is_ok(const struct LDKCResult_TrustedClosingTransactionNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_TrustedClosingTransactionNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TrustedClosingTransactionNoneZ_free(struct LDKCResult_TrustedClosingTransactionNoneZ _res);
/* @internal */
export function CResult_TrustedClosingTransactionNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_ok(struct LDKCommitmentTransaction o);
/* @internal */
export function CResult_CommitmentTransactionDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_CommitmentTransactionDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_CommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_CommitmentTransactionDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CommitmentTransactionDecodeErrorZ_free(struct LDKCResult_CommitmentTransactionDecodeErrorZ _res);
/* @internal */
export function CResult_CommitmentTransactionDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_CommitmentTransactionDecodeErrorZ_clone_ptr(LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CommitmentTransactionDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CommitmentTransactionDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TrustedCommitmentTransactionNoneZ CResult_TrustedCommitmentTransactionNoneZ_ok(struct LDKTrustedCommitmentTransaction o);
/* @internal */
export function CResult_TrustedCommitmentTransactionNoneZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TrustedCommitmentTransactionNoneZ CResult_TrustedCommitmentTransactionNoneZ_err(void);
/* @internal */
export function CResult_TrustedCommitmentTransactionNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_TrustedCommitmentTransactionNoneZ_is_ok(const struct LDKCResult_TrustedCommitmentTransactionNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_TrustedCommitmentTransactionNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TrustedCommitmentTransactionNoneZ_free(struct LDKCResult_TrustedCommitmentTransactionNoneZ _res);
/* @internal */
export function CResult_TrustedCommitmentTransactionNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_ok(struct LDKCVec_SignatureZ o);
/* @internal */
export function CResult_CVec_SignatureZNoneZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_err(void);
/* @internal */
export function CResult_CVec_SignatureZNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_CVec_SignatureZNoneZ_is_ok(const struct LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_CVec_SignatureZNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CVec_SignatureZNoneZ_free(struct LDKCResult_CVec_SignatureZNoneZ _res);
/* @internal */
export function CResult_CVec_SignatureZNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_CVec_SignatureZNoneZ_clone_ptr(LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CVec_SignatureZNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_clone(const struct LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CVec_SignatureZNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_ok(struct LDKShutdownScript o);
/* @internal */
export function CResult_ShutdownScriptDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ShutdownScriptDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ShutdownScriptDecodeErrorZ_is_ok(const struct LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ShutdownScriptDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ShutdownScriptDecodeErrorZ_free(struct LDKCResult_ShutdownScriptDecodeErrorZ _res);
/* @internal */
export function CResult_ShutdownScriptDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ShutdownScriptDecodeErrorZ_clone_ptr(LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ShutdownScriptDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_clone(const struct LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ShutdownScriptDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_ok(struct LDKShutdownScript o);
/* @internal */
export function CResult_ShutdownScriptInvalidShutdownScriptZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_err(struct LDKInvalidShutdownScript e);
/* @internal */
export function CResult_ShutdownScriptInvalidShutdownScriptZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(const struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR o);
/* @internal */
export function CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ShutdownScriptInvalidShutdownScriptZ_free(struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ _res);
/* @internal */
export function CResult_ShutdownScriptInvalidShutdownScriptZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ShutdownScriptInvalidShutdownScriptZ_clone_ptr(LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ShutdownScriptInvalidShutdownScriptZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_clone(const struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ShutdownScriptInvalidShutdownScriptZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedPayInfoDecodeErrorZ CResult_BlindedPayInfoDecodeErrorZ_ok(struct LDKBlindedPayInfo o);
/* @internal */
export function CResult_BlindedPayInfoDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPayInfoDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedPayInfoDecodeErrorZ CResult_BlindedPayInfoDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_BlindedPayInfoDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPayInfoDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_BlindedPayInfoDecodeErrorZ_is_ok(const struct LDKCResult_BlindedPayInfoDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_BlindedPayInfoDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPayInfoDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_BlindedPayInfoDecodeErrorZ_free(struct LDKCResult_BlindedPayInfoDecodeErrorZ _res);
/* @internal */
export function CResult_BlindedPayInfoDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPayInfoDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_BlindedPayInfoDecodeErrorZ_clone_ptr(LDKCResult_BlindedPayInfoDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_BlindedPayInfoDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPayInfoDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedPayInfoDecodeErrorZ CResult_BlindedPayInfoDecodeErrorZ_clone(const struct LDKCResult_BlindedPayInfoDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_BlindedPayInfoDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPayInfoDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(struct LDKDelayedPaymentOutputDescriptor o);
/* @internal */
export function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ _res);
/* @internal */
export function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone_ptr(LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(struct LDKStaticPaymentOutputDescriptor o);
/* @internal */
export function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ _res);
/* @internal */
export function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone_ptr(LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_ok(struct LDKSpendableOutputDescriptor o);
/* @internal */
export function CResult_SpendableOutputDescriptorDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_SpendableOutputDescriptorDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_SpendableOutputDescriptorDecodeErrorZ_free(struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ _res);
/* @internal */
export function CResult_SpendableOutputDescriptorDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_SpendableOutputDescriptorDecodeErrorZ_clone_ptr(LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_SpendableOutputDescriptorDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_SpendableOutputDescriptorDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_SpendableOutputDescriptorZ_free(struct LDKCVec_SpendableOutputDescriptorZ _res);
/* @internal */
export function CVec_SpendableOutputDescriptorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_SpendableOutputDescriptorZ_free(_res);
	// debug statements here
}
	// void CVec_TxOutZ_free(struct LDKCVec_TxOutZ _res);
/* @internal */
export function CVec_TxOutZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_TxOutZ_free(_res);
	// debug statements here
}
	// struct LDKCOption_PackedLockTimeZ COption_PackedLockTimeZ_some(uint32_t o);
/* @internal */
export function COption_PackedLockTimeZ_some(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PackedLockTimeZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_PackedLockTimeZ COption_PackedLockTimeZ_none(void);
/* @internal */
export function COption_PackedLockTimeZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PackedLockTimeZ_none();
	return nativeResponseValue;
}
	// void COption_PackedLockTimeZ_free(struct LDKCOption_PackedLockTimeZ _res);
/* @internal */
export function COption_PackedLockTimeZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PackedLockTimeZ_free(_res);
	// debug statements here
}
	// uint64_t COption_PackedLockTimeZ_clone_ptr(LDKCOption_PackedLockTimeZ *NONNULL_PTR arg);
/* @internal */
export function COption_PackedLockTimeZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PackedLockTimeZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_PackedLockTimeZ COption_PackedLockTimeZ_clone(const struct LDKCOption_PackedLockTimeZ *NONNULL_PTR orig);
/* @internal */
export function COption_PackedLockTimeZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PackedLockTimeZ_clone(orig);
	return nativeResponseValue;
}
	// uint64_t C2Tuple_PartiallySignedTransactionusizeZ_clone_ptr(LDKC2Tuple_PartiallySignedTransactionusizeZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_PartiallySignedTransactionusizeZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PartiallySignedTransactionusizeZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PartiallySignedTransactionusizeZ C2Tuple_PartiallySignedTransactionusizeZ_clone(const struct LDKC2Tuple_PartiallySignedTransactionusizeZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_PartiallySignedTransactionusizeZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PartiallySignedTransactionusizeZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PartiallySignedTransactionusizeZ C2Tuple_PartiallySignedTransactionusizeZ_new(struct LDKCVec_u8Z a, uintptr_t b);
/* @internal */
export function C2Tuple_PartiallySignedTransactionusizeZ_new(a: number, b: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PartiallySignedTransactionusizeZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_PartiallySignedTransactionusizeZ_free(struct LDKC2Tuple_PartiallySignedTransactionusizeZ _res);
/* @internal */
export function C2Tuple_PartiallySignedTransactionusizeZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PartiallySignedTransactionusizeZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_ok(struct LDKC2Tuple_PartiallySignedTransactionusizeZ o);
/* @internal */
export function CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_err(void);
/* @internal */
export function CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_is_ok(const struct LDKCResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_free(struct LDKCResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ _res);
/* @internal */
export function CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_clone_ptr(LDKCResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_clone(const struct LDKCResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_PaymentPreimageZ_free(struct LDKCVec_PaymentPreimageZ _res);
/* @internal */
export function CVec_PaymentPreimageZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_PaymentPreimageZ_free(_res);
	// debug statements here
}
	// uint64_t C2Tuple_SignatureCVec_SignatureZZ_clone_ptr(LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_SignatureCVec_SignatureZZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_SignatureCVec_SignatureZZ C2Tuple_SignatureCVec_SignatureZZ_clone(const struct LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_SignatureCVec_SignatureZZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_SignatureCVec_SignatureZZ C2Tuple_SignatureCVec_SignatureZZ_new(struct LDKSignature a, struct LDKCVec_SignatureZ b);
/* @internal */
export function C2Tuple_SignatureCVec_SignatureZZ_new(a: number, b: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_SignatureCVec_SignatureZZ_free(struct LDKC2Tuple_SignatureCVec_SignatureZZ _res);
/* @internal */
export function C2Tuple_SignatureCVec_SignatureZZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok(struct LDKC2Tuple_SignatureCVec_SignatureZZ o);
/* @internal */
export function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err(void);
/* @internal */
export function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok(const struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free(struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ _res);
/* @internal */
export function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone_ptr(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone(const struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_ok(struct LDKSignature o);
/* @internal */
export function CResult_SignatureNoneZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_err(void);
/* @internal */
export function CResult_SignatureNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_SignatureNoneZ_is_ok(const struct LDKCResult_SignatureNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_SignatureNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_SignatureNoneZ_free(struct LDKCResult_SignatureNoneZ _res);
/* @internal */
export function CResult_SignatureNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_SignatureNoneZ_clone_ptr(LDKCResult_SignatureNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_SignatureNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_clone(const struct LDKCResult_SignatureNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_SignatureNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PublicKeyNoneZ CResult_PublicKeyNoneZ_ok(struct LDKPublicKey o);
/* @internal */
export function CResult_PublicKeyNoneZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PublicKeyNoneZ CResult_PublicKeyNoneZ_err(void);
/* @internal */
export function CResult_PublicKeyNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_PublicKeyNoneZ_is_ok(const struct LDKCResult_PublicKeyNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_PublicKeyNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PublicKeyNoneZ_free(struct LDKCResult_PublicKeyNoneZ _res);
/* @internal */
export function CResult_PublicKeyNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_PublicKeyNoneZ_clone_ptr(LDKCResult_PublicKeyNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PublicKeyNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PublicKeyNoneZ CResult_PublicKeyNoneZ_clone(const struct LDKCResult_PublicKeyNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PublicKeyNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_ScalarZ COption_ScalarZ_some(struct LDKBigEndianScalar o);
/* @internal */
export function COption_ScalarZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ScalarZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_ScalarZ COption_ScalarZ_none(void);
/* @internal */
export function COption_ScalarZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ScalarZ_none();
	return nativeResponseValue;
}
	// void COption_ScalarZ_free(struct LDKCOption_ScalarZ _res);
/* @internal */
export function COption_ScalarZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ScalarZ_free(_res);
	// debug statements here
}
	// uint64_t COption_ScalarZ_clone_ptr(LDKCOption_ScalarZ *NONNULL_PTR arg);
/* @internal */
export function COption_ScalarZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ScalarZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_ScalarZ COption_ScalarZ_clone(const struct LDKCOption_ScalarZ *NONNULL_PTR orig);
/* @internal */
export function COption_ScalarZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ScalarZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_SharedSecretNoneZ CResult_SharedSecretNoneZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */
export function CResult_SharedSecretNoneZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SharedSecretNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_SharedSecretNoneZ CResult_SharedSecretNoneZ_err(void);
/* @internal */
export function CResult_SharedSecretNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SharedSecretNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_SharedSecretNoneZ_is_ok(const struct LDKCResult_SharedSecretNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_SharedSecretNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SharedSecretNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_SharedSecretNoneZ_free(struct LDKCResult_SharedSecretNoneZ _res);
/* @internal */
export function CResult_SharedSecretNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SharedSecretNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_SharedSecretNoneZ_clone_ptr(LDKCResult_SharedSecretNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_SharedSecretNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SharedSecretNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_SharedSecretNoneZ CResult_SharedSecretNoneZ_clone(const struct LDKCResult_SharedSecretNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_SharedSecretNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SharedSecretNoneZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_U5Z_free(struct LDKCVec_U5Z _res);
/* @internal */
export function CVec_U5Z_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_U5Z_free(_res);
	// debug statements here
}
	// struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_ok(struct LDKRecoverableSignature o);
/* @internal */
export function CResult_RecoverableSignatureNoneZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_err(void);
/* @internal */
export function CResult_RecoverableSignatureNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_RecoverableSignatureNoneZ_is_ok(const struct LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_RecoverableSignatureNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RecoverableSignatureNoneZ_free(struct LDKCResult_RecoverableSignatureNoneZ _res);
/* @internal */
export function CResult_RecoverableSignatureNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_RecoverableSignatureNoneZ_clone_ptr(LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RecoverableSignatureNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_clone(const struct LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RecoverableSignatureNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ CResult_WriteableEcdsaChannelSignerDecodeErrorZ_ok(struct LDKWriteableEcdsaChannelSigner o);
/* @internal */
export function CResult_WriteableEcdsaChannelSignerDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WriteableEcdsaChannelSignerDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ CResult_WriteableEcdsaChannelSignerDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_WriteableEcdsaChannelSignerDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WriteableEcdsaChannelSignerDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_WriteableEcdsaChannelSignerDecodeErrorZ_is_ok(const struct LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_WriteableEcdsaChannelSignerDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WriteableEcdsaChannelSignerDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_WriteableEcdsaChannelSignerDecodeErrorZ_free(struct LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ _res);
/* @internal */
export function CResult_WriteableEcdsaChannelSignerDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WriteableEcdsaChannelSignerDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_WriteableEcdsaChannelSignerDecodeErrorZ_clone_ptr(LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_WriteableEcdsaChannelSignerDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WriteableEcdsaChannelSignerDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ CResult_WriteableEcdsaChannelSignerDecodeErrorZ_clone(const struct LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_WriteableEcdsaChannelSignerDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WriteableEcdsaChannelSignerDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ScriptNoneZ CResult_ScriptNoneZ_ok(struct LDKCVec_u8Z o);
/* @internal */
export function CResult_ScriptNoneZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScriptNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ScriptNoneZ CResult_ScriptNoneZ_err(void);
/* @internal */
export function CResult_ScriptNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScriptNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_ScriptNoneZ_is_ok(const struct LDKCResult_ScriptNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_ScriptNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScriptNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ScriptNoneZ_free(struct LDKCResult_ScriptNoneZ _res);
/* @internal */
export function CResult_ScriptNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScriptNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ScriptNoneZ_clone_ptr(LDKCResult_ScriptNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ScriptNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScriptNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ScriptNoneZ CResult_ScriptNoneZ_clone(const struct LDKCResult_ScriptNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ScriptNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScriptNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownScriptNoneZ CResult_ShutdownScriptNoneZ_ok(struct LDKShutdownScript o);
/* @internal */
export function CResult_ShutdownScriptNoneZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownScriptNoneZ CResult_ShutdownScriptNoneZ_err(void);
/* @internal */
export function CResult_ShutdownScriptNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_ShutdownScriptNoneZ_is_ok(const struct LDKCResult_ShutdownScriptNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_ShutdownScriptNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ShutdownScriptNoneZ_free(struct LDKCResult_ShutdownScriptNoneZ _res);
/* @internal */
export function CResult_ShutdownScriptNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ShutdownScriptNoneZ_clone_ptr(LDKCResult_ShutdownScriptNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ShutdownScriptNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownScriptNoneZ CResult_ShutdownScriptNoneZ_clone(const struct LDKCResult_ShutdownScriptNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ShutdownScriptNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptNoneZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_CVec_u8ZZ_free(struct LDKCVec_CVec_u8ZZ _res);
/* @internal */
export function CVec_CVec_u8ZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_CVec_u8ZZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_ok(struct LDKCVec_CVec_u8ZZ o);
/* @internal */
export function CResult_CVec_CVec_u8ZZNoneZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_err(void);
/* @internal */
export function CResult_CVec_CVec_u8ZZNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_CVec_CVec_u8ZZNoneZ_is_ok(const struct LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_CVec_CVec_u8ZZNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CVec_CVec_u8ZZNoneZ_free(struct LDKCResult_CVec_CVec_u8ZZNoneZ _res);
/* @internal */
export function CResult_CVec_CVec_u8ZZNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_CVec_CVec_u8ZZNoneZ_clone_ptr(LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CVec_CVec_u8ZZNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_clone(const struct LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CVec_CVec_u8ZZNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_ok(struct LDKInMemorySigner o);
/* @internal */
export function CResult_InMemorySignerDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_InMemorySignerDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_InMemorySignerDecodeErrorZ_is_ok(const struct LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_InMemorySignerDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_InMemorySignerDecodeErrorZ_free(struct LDKCResult_InMemorySignerDecodeErrorZ _res);
/* @internal */
export function CResult_InMemorySignerDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_InMemorySignerDecodeErrorZ_clone_ptr(LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_InMemorySignerDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_clone(const struct LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_InMemorySignerDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PartiallySignedTransactionNoneZ CResult_PartiallySignedTransactionNoneZ_ok(struct LDKCVec_u8Z o);
/* @internal */
export function CResult_PartiallySignedTransactionNoneZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PartiallySignedTransactionNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PartiallySignedTransactionNoneZ CResult_PartiallySignedTransactionNoneZ_err(void);
/* @internal */
export function CResult_PartiallySignedTransactionNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PartiallySignedTransactionNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_PartiallySignedTransactionNoneZ_is_ok(const struct LDKCResult_PartiallySignedTransactionNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_PartiallySignedTransactionNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PartiallySignedTransactionNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PartiallySignedTransactionNoneZ_free(struct LDKCResult_PartiallySignedTransactionNoneZ _res);
/* @internal */
export function CResult_PartiallySignedTransactionNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PartiallySignedTransactionNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_PartiallySignedTransactionNoneZ_clone_ptr(LDKCResult_PartiallySignedTransactionNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PartiallySignedTransactionNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PartiallySignedTransactionNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PartiallySignedTransactionNoneZ CResult_PartiallySignedTransactionNoneZ_clone(const struct LDKCResult_PartiallySignedTransactionNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PartiallySignedTransactionNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PartiallySignedTransactionNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_ok(struct LDKTransaction o);
/* @internal */
export function CResult_TransactionNoneZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_err(void);
/* @internal */
export function CResult_TransactionNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_TransactionNoneZ_is_ok(const struct LDKCResult_TransactionNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_TransactionNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TransactionNoneZ_free(struct LDKCResult_TransactionNoneZ _res);
/* @internal */
export function CResult_TransactionNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_TransactionNoneZ_clone_ptr(LDKCResult_TransactionNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TransactionNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_clone(const struct LDKCResult_TransactionNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TransactionNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_ChannelDetailsZ_free(struct LDKCVec_ChannelDetailsZ _res);
/* @internal */
export function CVec_ChannelDetailsZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_ChannelDetailsZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_ok(struct LDKRoute o);
/* @internal */
export function CResult_RouteLightningErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_err(struct LDKLightningError e);
/* @internal */
export function CResult_RouteLightningErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RouteLightningErrorZ_is_ok(const struct LDKCResult_RouteLightningErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RouteLightningErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RouteLightningErrorZ_free(struct LDKCResult_RouteLightningErrorZ _res);
/* @internal */
export function CResult_RouteLightningErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_RouteLightningErrorZ_clone_ptr(LDKCResult_RouteLightningErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RouteLightningErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_clone(const struct LDKCResult_RouteLightningErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RouteLightningErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_InFlightHtlcsDecodeErrorZ CResult_InFlightHtlcsDecodeErrorZ_ok(struct LDKInFlightHtlcs o);
/* @internal */
export function CResult_InFlightHtlcsDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InFlightHtlcsDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_InFlightHtlcsDecodeErrorZ CResult_InFlightHtlcsDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_InFlightHtlcsDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InFlightHtlcsDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_InFlightHtlcsDecodeErrorZ_is_ok(const struct LDKCResult_InFlightHtlcsDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_InFlightHtlcsDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InFlightHtlcsDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_InFlightHtlcsDecodeErrorZ_free(struct LDKCResult_InFlightHtlcsDecodeErrorZ _res);
/* @internal */
export function CResult_InFlightHtlcsDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InFlightHtlcsDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_InFlightHtlcsDecodeErrorZ_clone_ptr(LDKCResult_InFlightHtlcsDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_InFlightHtlcsDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InFlightHtlcsDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_InFlightHtlcsDecodeErrorZ CResult_InFlightHtlcsDecodeErrorZ_clone(const struct LDKCResult_InFlightHtlcsDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_InFlightHtlcsDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InFlightHtlcsDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_ok(struct LDKRouteHop o);
/* @internal */
export function CResult_RouteHopDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_RouteHopDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RouteHopDecodeErrorZ_is_ok(const struct LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RouteHopDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RouteHopDecodeErrorZ_free(struct LDKCResult_RouteHopDecodeErrorZ _res);
/* @internal */
export function CResult_RouteHopDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_RouteHopDecodeErrorZ_clone_ptr(LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RouteHopDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_clone(const struct LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RouteHopDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_BlindedHopZ_free(struct LDKCVec_BlindedHopZ _res);
/* @internal */
export function CVec_BlindedHopZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_BlindedHopZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_BlindedTailDecodeErrorZ CResult_BlindedTailDecodeErrorZ_ok(struct LDKBlindedTail o);
/* @internal */
export function CResult_BlindedTailDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedTailDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedTailDecodeErrorZ CResult_BlindedTailDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_BlindedTailDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedTailDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_BlindedTailDecodeErrorZ_is_ok(const struct LDKCResult_BlindedTailDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_BlindedTailDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedTailDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_BlindedTailDecodeErrorZ_free(struct LDKCResult_BlindedTailDecodeErrorZ _res);
/* @internal */
export function CResult_BlindedTailDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedTailDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_BlindedTailDecodeErrorZ_clone_ptr(LDKCResult_BlindedTailDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_BlindedTailDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedTailDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedTailDecodeErrorZ CResult_BlindedTailDecodeErrorZ_clone(const struct LDKCResult_BlindedTailDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_BlindedTailDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedTailDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_RouteHopZ_free(struct LDKCVec_RouteHopZ _res);
/* @internal */
export function CVec_RouteHopZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_RouteHopZ_free(_res);
	// debug statements here
}
	// void CVec_PathZ_free(struct LDKCVec_PathZ _res);
/* @internal */
export function CVec_PathZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_PathZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_ok(struct LDKRoute o);
/* @internal */
export function CResult_RouteDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_RouteDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RouteDecodeErrorZ_is_ok(const struct LDKCResult_RouteDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RouteDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RouteDecodeErrorZ_free(struct LDKCResult_RouteDecodeErrorZ _res);
/* @internal */
export function CResult_RouteDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_RouteDecodeErrorZ_clone_ptr(LDKCResult_RouteDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RouteDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_clone(const struct LDKCResult_RouteDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RouteDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_ok(struct LDKRouteParameters o);
/* @internal */
export function CResult_RouteParametersDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_RouteParametersDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RouteParametersDecodeErrorZ_is_ok(const struct LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RouteParametersDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RouteParametersDecodeErrorZ_free(struct LDKCResult_RouteParametersDecodeErrorZ _res);
/* @internal */
export function CResult_RouteParametersDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_RouteParametersDecodeErrorZ_clone_ptr(LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RouteParametersDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_clone(const struct LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RouteParametersDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_u64Z_free(struct LDKCVec_u64Z _res);
/* @internal */
export function CVec_u64Z_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_u64Z_free(_res);
	// debug statements here
}
	// struct LDKCResult_PaymentParametersDecodeErrorZ CResult_PaymentParametersDecodeErrorZ_ok(struct LDKPaymentParameters o);
/* @internal */
export function CResult_PaymentParametersDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentParametersDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentParametersDecodeErrorZ CResult_PaymentParametersDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_PaymentParametersDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentParametersDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PaymentParametersDecodeErrorZ_is_ok(const struct LDKCResult_PaymentParametersDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PaymentParametersDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentParametersDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PaymentParametersDecodeErrorZ_free(struct LDKCResult_PaymentParametersDecodeErrorZ _res);
/* @internal */
export function CResult_PaymentParametersDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentParametersDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_PaymentParametersDecodeErrorZ_clone_ptr(LDKCResult_PaymentParametersDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PaymentParametersDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentParametersDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentParametersDecodeErrorZ CResult_PaymentParametersDecodeErrorZ_clone(const struct LDKCResult_PaymentParametersDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PaymentParametersDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentParametersDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// uint64_t C2Tuple_BlindedPayInfoBlindedPathZ_clone_ptr(LDKC2Tuple_BlindedPayInfoBlindedPathZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_BlindedPayInfoBlindedPathZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlindedPayInfoBlindedPathZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_BlindedPayInfoBlindedPathZ C2Tuple_BlindedPayInfoBlindedPathZ_clone(const struct LDKC2Tuple_BlindedPayInfoBlindedPathZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_BlindedPayInfoBlindedPathZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlindedPayInfoBlindedPathZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_BlindedPayInfoBlindedPathZ C2Tuple_BlindedPayInfoBlindedPathZ_new(struct LDKBlindedPayInfo a, struct LDKBlindedPath b);
/* @internal */
export function C2Tuple_BlindedPayInfoBlindedPathZ_new(a: bigint, b: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlindedPayInfoBlindedPathZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_BlindedPayInfoBlindedPathZ_free(struct LDKC2Tuple_BlindedPayInfoBlindedPathZ _res);
/* @internal */
export function C2Tuple_BlindedPayInfoBlindedPathZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlindedPayInfoBlindedPathZ_free(_res);
	// debug statements here
}
	// void CVec_C2Tuple_BlindedPayInfoBlindedPathZZ_free(struct LDKCVec_C2Tuple_BlindedPayInfoBlindedPathZZ _res);
/* @internal */
export function CVec_C2Tuple_BlindedPayInfoBlindedPathZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C2Tuple_BlindedPayInfoBlindedPathZZ_free(_res);
	// debug statements here
}
	// void CVec_RouteHintZ_free(struct LDKCVec_RouteHintZ _res);
/* @internal */
export function CVec_RouteHintZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_RouteHintZ_free(_res);
	// debug statements here
}
	// void CVec_RouteHintHopZ_free(struct LDKCVec_RouteHintHopZ _res);
/* @internal */
export function CVec_RouteHintHopZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_RouteHintHopZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_ok(struct LDKRouteHint o);
/* @internal */
export function CResult_RouteHintDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_RouteHintDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RouteHintDecodeErrorZ_is_ok(const struct LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RouteHintDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RouteHintDecodeErrorZ_free(struct LDKCResult_RouteHintDecodeErrorZ _res);
/* @internal */
export function CResult_RouteHintDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_RouteHintDecodeErrorZ_clone_ptr(LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RouteHintDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_clone(const struct LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RouteHintDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_ok(struct LDKRouteHintHop o);
/* @internal */
export function CResult_RouteHintHopDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_RouteHintHopDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RouteHintHopDecodeErrorZ_is_ok(const struct LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RouteHintHopDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RouteHintHopDecodeErrorZ_free(struct LDKCResult_RouteHintHopDecodeErrorZ _res);
/* @internal */
export function CResult_RouteHintHopDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_RouteHintHopDecodeErrorZ_clone_ptr(LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RouteHintHopDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_clone(const struct LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RouteHintHopDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_PublicKeyZ_free(struct LDKCVec_PublicKeyZ _res);
/* @internal */
export function CVec_PublicKeyZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_PublicKeyZ_free(_res);
	// debug statements here
}
	// void CVec_TransactionZ_free(struct LDKCVec_TransactionZ _res);
/* @internal */
export function CVec_TransactionZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_TransactionZ_free(_res);
	// debug statements here
}
	// uint64_t C2Tuple_usizeTransactionZ_clone_ptr(LDKC2Tuple_usizeTransactionZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_usizeTransactionZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_usizeTransactionZ C2Tuple_usizeTransactionZ_clone(const struct LDKC2Tuple_usizeTransactionZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_usizeTransactionZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_usizeTransactionZ C2Tuple_usizeTransactionZ_new(uintptr_t a, struct LDKTransaction b);
/* @internal */
export function C2Tuple_usizeTransactionZ_new(a: number, b: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_usizeTransactionZ_free(struct LDKC2Tuple_usizeTransactionZ _res);
/* @internal */
export function C2Tuple_usizeTransactionZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_free(_res);
	// debug statements here
}
	// void CVec_C2Tuple_usizeTransactionZZ_free(struct LDKCVec_C2Tuple_usizeTransactionZZ _res);
/* @internal */
export function CVec_C2Tuple_usizeTransactionZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C2Tuple_usizeTransactionZZ_free(_res);
	// debug statements here
}
	// struct LDKCOption_BlockHashZ COption_BlockHashZ_some(struct LDKThirtyTwoBytes o);
/* @internal */
export function COption_BlockHashZ_some(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_BlockHashZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_BlockHashZ COption_BlockHashZ_none(void);
/* @internal */
export function COption_BlockHashZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_BlockHashZ_none();
	return nativeResponseValue;
}
	// void COption_BlockHashZ_free(struct LDKCOption_BlockHashZ _res);
/* @internal */
export function COption_BlockHashZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_BlockHashZ_free(_res);
	// debug statements here
}
	// uint64_t COption_BlockHashZ_clone_ptr(LDKCOption_BlockHashZ *NONNULL_PTR arg);
/* @internal */
export function COption_BlockHashZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_BlockHashZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_BlockHashZ COption_BlockHashZ_clone(const struct LDKCOption_BlockHashZ *NONNULL_PTR orig);
/* @internal */
export function COption_BlockHashZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_BlockHashZ_clone(orig);
	return nativeResponseValue;
}
	// uint64_t C2Tuple_TxidCOption_BlockHashZZ_clone_ptr(LDKC2Tuple_TxidCOption_BlockHashZZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_TxidCOption_BlockHashZZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCOption_BlockHashZZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_TxidCOption_BlockHashZZ C2Tuple_TxidCOption_BlockHashZZ_clone(const struct LDKC2Tuple_TxidCOption_BlockHashZZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_TxidCOption_BlockHashZZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCOption_BlockHashZZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_TxidCOption_BlockHashZZ C2Tuple_TxidCOption_BlockHashZZ_new(struct LDKThirtyTwoBytes a, struct LDKCOption_BlockHashZ b);
/* @internal */
export function C2Tuple_TxidCOption_BlockHashZZ_new(a: number, b: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCOption_BlockHashZZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_TxidCOption_BlockHashZZ_free(struct LDKC2Tuple_TxidCOption_BlockHashZZ _res);
/* @internal */
export function C2Tuple_TxidCOption_BlockHashZZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCOption_BlockHashZZ_free(_res);
	// debug statements here
}
	// void CVec_C2Tuple_TxidCOption_BlockHashZZZ_free(struct LDKCVec_C2Tuple_TxidCOption_BlockHashZZZ _res);
/* @internal */
export function CVec_C2Tuple_TxidCOption_BlockHashZZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C2Tuple_TxidCOption_BlockHashZZZ_free(_res);
	// debug statements here
}
	// void CVec_MonitorEventZ_free(struct LDKCVec_MonitorEventZ _res);
/* @internal */
export function CVec_MonitorEventZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_MonitorEventZ_free(_res);
	// debug statements here
}
	// uint64_t C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_clone_ptr(LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ *NONNULL_PTR arg);
/* @internal */
export function C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_clone(const struct LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ *NONNULL_PTR orig);
/* @internal */
export function C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_new(struct LDKOutPoint a, struct LDKCVec_MonitorEventZ b, struct LDKPublicKey c);
/* @internal */
export function C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_new(a: bigint, b: number, c: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_new(a, b, c);
	return nativeResponseValue;
}
	// void C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_free(struct LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ _res);
/* @internal */
export function C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_free(_res);
	// debug statements here
}
	// void CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ_free(struct LDKCVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ _res);
/* @internal */
export function CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_FixedPenaltyScorerDecodeErrorZ CResult_FixedPenaltyScorerDecodeErrorZ_ok(struct LDKFixedPenaltyScorer o);
/* @internal */
export function CResult_FixedPenaltyScorerDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FixedPenaltyScorerDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_FixedPenaltyScorerDecodeErrorZ CResult_FixedPenaltyScorerDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_FixedPenaltyScorerDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FixedPenaltyScorerDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_FixedPenaltyScorerDecodeErrorZ_is_ok(const struct LDKCResult_FixedPenaltyScorerDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_FixedPenaltyScorerDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FixedPenaltyScorerDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_FixedPenaltyScorerDecodeErrorZ_free(struct LDKCResult_FixedPenaltyScorerDecodeErrorZ _res);
/* @internal */
export function CResult_FixedPenaltyScorerDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FixedPenaltyScorerDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_FixedPenaltyScorerDecodeErrorZ_clone_ptr(LDKCResult_FixedPenaltyScorerDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_FixedPenaltyScorerDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FixedPenaltyScorerDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_FixedPenaltyScorerDecodeErrorZ CResult_FixedPenaltyScorerDecodeErrorZ_clone(const struct LDKCResult_FixedPenaltyScorerDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_FixedPenaltyScorerDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FixedPenaltyScorerDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_NodeIdZ_free(struct LDKCVec_NodeIdZ _res);
/* @internal */
export function CVec_NodeIdZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_NodeIdZ_free(_res);
	// debug statements here
}
	// uint64_t C2Tuple_u64u64Z_clone_ptr(LDKC2Tuple_u64u64Z *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_u64u64Z_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u64u64Z_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_u64u64Z C2Tuple_u64u64Z_clone(const struct LDKC2Tuple_u64u64Z *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_u64u64Z_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u64u64Z_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_u64u64Z C2Tuple_u64u64Z_new(uint64_t a, uint64_t b);
/* @internal */
export function C2Tuple_u64u64Z_new(a: bigint, b: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u64u64Z_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_u64u64Z_free(struct LDKC2Tuple_u64u64Z _res);
/* @internal */
export function C2Tuple_u64u64Z_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u64u64Z_free(_res);
	// debug statements here
}
	// struct LDKCOption_C2Tuple_u64u64ZZ COption_C2Tuple_u64u64ZZ_some(struct LDKC2Tuple_u64u64Z o);
/* @internal */
export function COption_C2Tuple_u64u64ZZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C2Tuple_u64u64ZZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_C2Tuple_u64u64ZZ COption_C2Tuple_u64u64ZZ_none(void);
/* @internal */
export function COption_C2Tuple_u64u64ZZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C2Tuple_u64u64ZZ_none();
	return nativeResponseValue;
}
	// void COption_C2Tuple_u64u64ZZ_free(struct LDKCOption_C2Tuple_u64u64ZZ _res);
/* @internal */
export function COption_C2Tuple_u64u64ZZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C2Tuple_u64u64ZZ_free(_res);
	// debug statements here
}
	// uint64_t COption_C2Tuple_u64u64ZZ_clone_ptr(LDKCOption_C2Tuple_u64u64ZZ *NONNULL_PTR arg);
/* @internal */
export function COption_C2Tuple_u64u64ZZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C2Tuple_u64u64ZZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_C2Tuple_u64u64ZZ COption_C2Tuple_u64u64ZZ_clone(const struct LDKCOption_C2Tuple_u64u64ZZ *NONNULL_PTR orig);
/* @internal */
export function COption_C2Tuple_u64u64ZZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C2Tuple_u64u64ZZ_clone(orig);
	return nativeResponseValue;
}
	// uint64_t C2Tuple_Z_clone_ptr(LDKC2Tuple_Z *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_Z_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_Z_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_Z C2Tuple_Z_clone(const struct LDKC2Tuple_Z *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_Z_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_Z_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_Z C2Tuple_Z_new(struct LDKEightU16s a, struct LDKEightU16s b);
/* @internal */
export function C2Tuple_Z_new(a: number, b: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_Z_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_Z_free(struct LDKC2Tuple_Z _res);
/* @internal */
export function C2Tuple_Z_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_Z_free(_res);
	// debug statements here
}
	// uint64_t C2Tuple__u168_u168Z_clone_ptr(LDKC2Tuple__u168_u168Z *NONNULL_PTR arg);
/* @internal */
export function C2Tuple__u168_u168Z_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple__u168_u168Z_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple__u168_u168Z C2Tuple__u168_u168Z_clone(const struct LDKC2Tuple__u168_u168Z *NONNULL_PTR orig);
/* @internal */
export function C2Tuple__u168_u168Z_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple__u168_u168Z_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple__u168_u168Z C2Tuple__u168_u168Z_new(struct LDKEightU16s a, struct LDKEightU16s b);
/* @internal */
export function C2Tuple__u168_u168Z_new(a: number, b: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple__u168_u168Z_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple__u168_u168Z_free(struct LDKC2Tuple__u168_u168Z _res);
/* @internal */
export function C2Tuple__u168_u168Z_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple__u168_u168Z_free(_res);
	// debug statements here
}
	// struct LDKCOption_C2Tuple_EightU16sEightU16sZZ COption_C2Tuple_EightU16sEightU16sZZ_some(struct LDKC2Tuple__u168_u168Z o);
/* @internal */
export function COption_C2Tuple_EightU16sEightU16sZZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C2Tuple_EightU16sEightU16sZZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_C2Tuple_EightU16sEightU16sZZ COption_C2Tuple_EightU16sEightU16sZZ_none(void);
/* @internal */
export function COption_C2Tuple_EightU16sEightU16sZZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C2Tuple_EightU16sEightU16sZZ_none();
	return nativeResponseValue;
}
	// void COption_C2Tuple_EightU16sEightU16sZZ_free(struct LDKCOption_C2Tuple_EightU16sEightU16sZZ _res);
/* @internal */
export function COption_C2Tuple_EightU16sEightU16sZZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C2Tuple_EightU16sEightU16sZZ_free(_res);
	// debug statements here
}
	// uint64_t COption_C2Tuple_EightU16sEightU16sZZ_clone_ptr(LDKCOption_C2Tuple_EightU16sEightU16sZZ *NONNULL_PTR arg);
/* @internal */
export function COption_C2Tuple_EightU16sEightU16sZZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C2Tuple_EightU16sEightU16sZZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_C2Tuple_EightU16sEightU16sZZ COption_C2Tuple_EightU16sEightU16sZZ_clone(const struct LDKCOption_C2Tuple_EightU16sEightU16sZZ *NONNULL_PTR orig);
/* @internal */
export function COption_C2Tuple_EightU16sEightU16sZZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C2Tuple_EightU16sEightU16sZZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ProbabilisticScorerDecodeErrorZ CResult_ProbabilisticScorerDecodeErrorZ_ok(struct LDKProbabilisticScorer o);
/* @internal */
export function CResult_ProbabilisticScorerDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ProbabilisticScorerDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ProbabilisticScorerDecodeErrorZ CResult_ProbabilisticScorerDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ProbabilisticScorerDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ProbabilisticScorerDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ProbabilisticScorerDecodeErrorZ_is_ok(const struct LDKCResult_ProbabilisticScorerDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ProbabilisticScorerDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ProbabilisticScorerDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ProbabilisticScorerDecodeErrorZ_free(struct LDKCResult_ProbabilisticScorerDecodeErrorZ _res);
/* @internal */
export function CResult_ProbabilisticScorerDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ProbabilisticScorerDecodeErrorZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_ok(struct LDKInitFeatures o);
/* @internal */
export function CResult_InitFeaturesDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_InitFeaturesDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_InitFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_InitFeaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_InitFeaturesDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_InitFeaturesDecodeErrorZ_free(struct LDKCResult_InitFeaturesDecodeErrorZ _res);
/* @internal */
export function CResult_InitFeaturesDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_InitFeaturesDecodeErrorZ_clone_ptr(LDKCResult_InitFeaturesDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_InitFeaturesDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_clone(const struct LDKCResult_InitFeaturesDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_InitFeaturesDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_ok(struct LDKChannelFeatures o);
/* @internal */
export function CResult_ChannelFeaturesDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelFeaturesDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_ChannelFeaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelFeaturesDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelFeaturesDecodeErrorZ_free(struct LDKCResult_ChannelFeaturesDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelFeaturesDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ChannelFeaturesDecodeErrorZ_clone_ptr(LDKCResult_ChannelFeaturesDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelFeaturesDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_clone(const struct LDKCResult_ChannelFeaturesDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelFeaturesDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_ok(struct LDKNodeFeatures o);
/* @internal */
export function CResult_NodeFeaturesDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_NodeFeaturesDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NodeFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_NodeFeaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NodeFeaturesDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NodeFeaturesDecodeErrorZ_free(struct LDKCResult_NodeFeaturesDecodeErrorZ _res);
/* @internal */
export function CResult_NodeFeaturesDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_NodeFeaturesDecodeErrorZ_clone_ptr(LDKCResult_NodeFeaturesDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NodeFeaturesDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_clone(const struct LDKCResult_NodeFeaturesDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NodeFeaturesDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ CResult_Bolt11InvoiceFeaturesDecodeErrorZ_ok(struct LDKBolt11InvoiceFeatures o);
/* @internal */
export function CResult_Bolt11InvoiceFeaturesDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceFeaturesDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ CResult_Bolt11InvoiceFeaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_Bolt11InvoiceFeaturesDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceFeaturesDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_Bolt11InvoiceFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_Bolt11InvoiceFeaturesDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceFeaturesDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_Bolt11InvoiceFeaturesDecodeErrorZ_free(struct LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ _res);
/* @internal */
export function CResult_Bolt11InvoiceFeaturesDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceFeaturesDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_Bolt11InvoiceFeaturesDecodeErrorZ_clone_ptr(LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_Bolt11InvoiceFeaturesDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceFeaturesDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ CResult_Bolt11InvoiceFeaturesDecodeErrorZ_clone(const struct LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_Bolt11InvoiceFeaturesDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceFeaturesDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ CResult_Bolt12InvoiceFeaturesDecodeErrorZ_ok(struct LDKBolt12InvoiceFeatures o);
/* @internal */
export function CResult_Bolt12InvoiceFeaturesDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt12InvoiceFeaturesDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ CResult_Bolt12InvoiceFeaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_Bolt12InvoiceFeaturesDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt12InvoiceFeaturesDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_Bolt12InvoiceFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_Bolt12InvoiceFeaturesDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt12InvoiceFeaturesDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_Bolt12InvoiceFeaturesDecodeErrorZ_free(struct LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ _res);
/* @internal */
export function CResult_Bolt12InvoiceFeaturesDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt12InvoiceFeaturesDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_Bolt12InvoiceFeaturesDecodeErrorZ_clone_ptr(LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_Bolt12InvoiceFeaturesDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt12InvoiceFeaturesDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ CResult_Bolt12InvoiceFeaturesDecodeErrorZ_clone(const struct LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_Bolt12InvoiceFeaturesDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt12InvoiceFeaturesDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedHopFeaturesDecodeErrorZ CResult_BlindedHopFeaturesDecodeErrorZ_ok(struct LDKBlindedHopFeatures o);
/* @internal */
export function CResult_BlindedHopFeaturesDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedHopFeaturesDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedHopFeaturesDecodeErrorZ CResult_BlindedHopFeaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_BlindedHopFeaturesDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedHopFeaturesDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_BlindedHopFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_BlindedHopFeaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_BlindedHopFeaturesDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedHopFeaturesDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_BlindedHopFeaturesDecodeErrorZ_free(struct LDKCResult_BlindedHopFeaturesDecodeErrorZ _res);
/* @internal */
export function CResult_BlindedHopFeaturesDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedHopFeaturesDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_BlindedHopFeaturesDecodeErrorZ_clone_ptr(LDKCResult_BlindedHopFeaturesDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_BlindedHopFeaturesDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedHopFeaturesDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedHopFeaturesDecodeErrorZ CResult_BlindedHopFeaturesDecodeErrorZ_clone(const struct LDKCResult_BlindedHopFeaturesDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_BlindedHopFeaturesDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedHopFeaturesDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ CResult_ChannelTypeFeaturesDecodeErrorZ_ok(struct LDKChannelTypeFeatures o);
/* @internal */
export function CResult_ChannelTypeFeaturesDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ CResult_ChannelTypeFeaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelTypeFeaturesDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelTypeFeaturesDecodeErrorZ_free(struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelTypeFeaturesDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ChannelTypeFeaturesDecodeErrorZ_clone_ptr(LDKCResult_ChannelTypeFeaturesDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelTypeFeaturesDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ CResult_ChannelTypeFeaturesDecodeErrorZ_clone(const struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelTypeFeaturesDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentPurposeDecodeErrorZ CResult_PaymentPurposeDecodeErrorZ_ok(struct LDKPaymentPurpose o);
/* @internal */
export function CResult_PaymentPurposeDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPurposeDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentPurposeDecodeErrorZ CResult_PaymentPurposeDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_PaymentPurposeDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPurposeDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PaymentPurposeDecodeErrorZ_is_ok(const struct LDKCResult_PaymentPurposeDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PaymentPurposeDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPurposeDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PaymentPurposeDecodeErrorZ_free(struct LDKCResult_PaymentPurposeDecodeErrorZ _res);
/* @internal */
export function CResult_PaymentPurposeDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPurposeDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_PaymentPurposeDecodeErrorZ_clone_ptr(LDKCResult_PaymentPurposeDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PaymentPurposeDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPurposeDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentPurposeDecodeErrorZ CResult_PaymentPurposeDecodeErrorZ_clone(const struct LDKCResult_PaymentPurposeDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PaymentPurposeDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPurposeDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_some(struct LDKNetworkUpdate o);
/* @internal */
export function COption_NetworkUpdateZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetworkUpdateZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_none(void);
/* @internal */
export function COption_NetworkUpdateZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetworkUpdateZ_none();
	return nativeResponseValue;
}
	// void COption_NetworkUpdateZ_free(struct LDKCOption_NetworkUpdateZ _res);
/* @internal */
export function COption_NetworkUpdateZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetworkUpdateZ_free(_res);
	// debug statements here
}
	// uint64_t COption_NetworkUpdateZ_clone_ptr(LDKCOption_NetworkUpdateZ *NONNULL_PTR arg);
/* @internal */
export function COption_NetworkUpdateZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetworkUpdateZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_clone(const struct LDKCOption_NetworkUpdateZ *NONNULL_PTR orig);
/* @internal */
export function COption_NetworkUpdateZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetworkUpdateZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_PathFailureZ COption_PathFailureZ_some(struct LDKPathFailure o);
/* @internal */
export function COption_PathFailureZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PathFailureZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_PathFailureZ COption_PathFailureZ_none(void);
/* @internal */
export function COption_PathFailureZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PathFailureZ_none();
	return nativeResponseValue;
}
	// void COption_PathFailureZ_free(struct LDKCOption_PathFailureZ _res);
/* @internal */
export function COption_PathFailureZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PathFailureZ_free(_res);
	// debug statements here
}
	// uint64_t COption_PathFailureZ_clone_ptr(LDKCOption_PathFailureZ *NONNULL_PTR arg);
/* @internal */
export function COption_PathFailureZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PathFailureZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_PathFailureZ COption_PathFailureZ_clone(const struct LDKCOption_PathFailureZ *NONNULL_PTR orig);
/* @internal */
export function COption_PathFailureZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PathFailureZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_PathFailureZDecodeErrorZ CResult_COption_PathFailureZDecodeErrorZ_ok(struct LDKCOption_PathFailureZ o);
/* @internal */
export function CResult_COption_PathFailureZDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_PathFailureZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_PathFailureZDecodeErrorZ CResult_COption_PathFailureZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_COption_PathFailureZDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_PathFailureZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_COption_PathFailureZDecodeErrorZ_is_ok(const struct LDKCResult_COption_PathFailureZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_COption_PathFailureZDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_PathFailureZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_COption_PathFailureZDecodeErrorZ_free(struct LDKCResult_COption_PathFailureZDecodeErrorZ _res);
/* @internal */
export function CResult_COption_PathFailureZDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_PathFailureZDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_COption_PathFailureZDecodeErrorZ_clone_ptr(LDKCResult_COption_PathFailureZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_COption_PathFailureZDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_PathFailureZDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_PathFailureZDecodeErrorZ CResult_COption_PathFailureZDecodeErrorZ_clone(const struct LDKCResult_COption_PathFailureZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_COption_PathFailureZDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_PathFailureZDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_some(struct LDKClosureReason o);
/* @internal */
export function COption_ClosureReasonZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ClosureReasonZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_none(void);
/* @internal */
export function COption_ClosureReasonZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ClosureReasonZ_none();
	return nativeResponseValue;
}
	// void COption_ClosureReasonZ_free(struct LDKCOption_ClosureReasonZ _res);
/* @internal */
export function COption_ClosureReasonZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ClosureReasonZ_free(_res);
	// debug statements here
}
	// uint64_t COption_ClosureReasonZ_clone_ptr(LDKCOption_ClosureReasonZ *NONNULL_PTR arg);
/* @internal */
export function COption_ClosureReasonZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ClosureReasonZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_clone(const struct LDKCOption_ClosureReasonZ *NONNULL_PTR orig);
/* @internal */
export function COption_ClosureReasonZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ClosureReasonZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_ok(struct LDKCOption_ClosureReasonZ o);
/* @internal */
export function CResult_COption_ClosureReasonZDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_COption_ClosureReasonZDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(const struct LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_COption_ClosureReasonZDecodeErrorZ_free(struct LDKCResult_COption_ClosureReasonZDecodeErrorZ _res);
/* @internal */
export function CResult_COption_ClosureReasonZDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_COption_ClosureReasonZDecodeErrorZ_clone_ptr(LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_COption_ClosureReasonZDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_clone(const struct LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_COption_ClosureReasonZDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_HTLCDestinationZ COption_HTLCDestinationZ_some(struct LDKHTLCDestination o);
/* @internal */
export function COption_HTLCDestinationZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_HTLCDestinationZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_HTLCDestinationZ COption_HTLCDestinationZ_none(void);
/* @internal */
export function COption_HTLCDestinationZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_HTLCDestinationZ_none();
	return nativeResponseValue;
}
	// void COption_HTLCDestinationZ_free(struct LDKCOption_HTLCDestinationZ _res);
/* @internal */
export function COption_HTLCDestinationZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_HTLCDestinationZ_free(_res);
	// debug statements here
}
	// uint64_t COption_HTLCDestinationZ_clone_ptr(LDKCOption_HTLCDestinationZ *NONNULL_PTR arg);
/* @internal */
export function COption_HTLCDestinationZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_HTLCDestinationZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_HTLCDestinationZ COption_HTLCDestinationZ_clone(const struct LDKCOption_HTLCDestinationZ *NONNULL_PTR orig);
/* @internal */
export function COption_HTLCDestinationZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_HTLCDestinationZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ CResult_COption_HTLCDestinationZDecodeErrorZ_ok(struct LDKCOption_HTLCDestinationZ o);
/* @internal */
export function CResult_COption_HTLCDestinationZDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_HTLCDestinationZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ CResult_COption_HTLCDestinationZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_COption_HTLCDestinationZDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_HTLCDestinationZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_COption_HTLCDestinationZDecodeErrorZ_is_ok(const struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_COption_HTLCDestinationZDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_HTLCDestinationZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_COption_HTLCDestinationZDecodeErrorZ_free(struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ _res);
/* @internal */
export function CResult_COption_HTLCDestinationZDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_HTLCDestinationZDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_COption_HTLCDestinationZDecodeErrorZ_clone_ptr(LDKCResult_COption_HTLCDestinationZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_COption_HTLCDestinationZDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_HTLCDestinationZDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ CResult_COption_HTLCDestinationZDecodeErrorZ_clone(const struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_COption_HTLCDestinationZDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_HTLCDestinationZDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentFailureReasonDecodeErrorZ CResult_PaymentFailureReasonDecodeErrorZ_ok(enum LDKPaymentFailureReason o);
/* @internal */
export function CResult_PaymentFailureReasonDecodeErrorZ_ok(o: PaymentFailureReason): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentFailureReasonDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentFailureReasonDecodeErrorZ CResult_PaymentFailureReasonDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_PaymentFailureReasonDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentFailureReasonDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PaymentFailureReasonDecodeErrorZ_is_ok(const struct LDKCResult_PaymentFailureReasonDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PaymentFailureReasonDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentFailureReasonDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PaymentFailureReasonDecodeErrorZ_free(struct LDKCResult_PaymentFailureReasonDecodeErrorZ _res);
/* @internal */
export function CResult_PaymentFailureReasonDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentFailureReasonDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_PaymentFailureReasonDecodeErrorZ_clone_ptr(LDKCResult_PaymentFailureReasonDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PaymentFailureReasonDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentFailureReasonDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentFailureReasonDecodeErrorZ CResult_PaymentFailureReasonDecodeErrorZ_clone(const struct LDKCResult_PaymentFailureReasonDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PaymentFailureReasonDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentFailureReasonDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_u128Z COption_u128Z_some(struct LDKU128 o);
/* @internal */
export function COption_u128Z_some(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u128Z_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_u128Z COption_u128Z_none(void);
/* @internal */
export function COption_u128Z_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u128Z_none();
	return nativeResponseValue;
}
	// void COption_u128Z_free(struct LDKCOption_u128Z _res);
/* @internal */
export function COption_u128Z_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u128Z_free(_res);
	// debug statements here
}
	// uint64_t COption_u128Z_clone_ptr(LDKCOption_u128Z *NONNULL_PTR arg);
/* @internal */
export function COption_u128Z_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u128Z_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_u128Z COption_u128Z_clone(const struct LDKCOption_u128Z *NONNULL_PTR orig);
/* @internal */
export function COption_u128Z_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u128Z_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_PaymentIdZ COption_PaymentIdZ_some(struct LDKThirtyTwoBytes o);
/* @internal */
export function COption_PaymentIdZ_some(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentIdZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_PaymentIdZ COption_PaymentIdZ_none(void);
/* @internal */
export function COption_PaymentIdZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentIdZ_none();
	return nativeResponseValue;
}
	// void COption_PaymentIdZ_free(struct LDKCOption_PaymentIdZ _res);
/* @internal */
export function COption_PaymentIdZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentIdZ_free(_res);
	// debug statements here
}
	// uint64_t COption_PaymentIdZ_clone_ptr(LDKCOption_PaymentIdZ *NONNULL_PTR arg);
/* @internal */
export function COption_PaymentIdZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentIdZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_PaymentIdZ COption_PaymentIdZ_clone(const struct LDKCOption_PaymentIdZ *NONNULL_PTR orig);
/* @internal */
export function COption_PaymentIdZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentIdZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_PaymentFailureReasonZ COption_PaymentFailureReasonZ_some(enum LDKPaymentFailureReason o);
/* @internal */
export function COption_PaymentFailureReasonZ_some(o: PaymentFailureReason): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentFailureReasonZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_PaymentFailureReasonZ COption_PaymentFailureReasonZ_none(void);
/* @internal */
export function COption_PaymentFailureReasonZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentFailureReasonZ_none();
	return nativeResponseValue;
}
	// void COption_PaymentFailureReasonZ_free(struct LDKCOption_PaymentFailureReasonZ _res);
/* @internal */
export function COption_PaymentFailureReasonZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentFailureReasonZ_free(_res);
	// debug statements here
}
	// uint64_t COption_PaymentFailureReasonZ_clone_ptr(LDKCOption_PaymentFailureReasonZ *NONNULL_PTR arg);
/* @internal */
export function COption_PaymentFailureReasonZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentFailureReasonZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_PaymentFailureReasonZ COption_PaymentFailureReasonZ_clone(const struct LDKCOption_PaymentFailureReasonZ *NONNULL_PTR orig);
/* @internal */
export function COption_PaymentFailureReasonZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentFailureReasonZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_PaymentHashZ COption_PaymentHashZ_some(struct LDKThirtyTwoBytes o);
/* @internal */
export function COption_PaymentHashZ_some(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentHashZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_PaymentHashZ COption_PaymentHashZ_none(void);
/* @internal */
export function COption_PaymentHashZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentHashZ_none();
	return nativeResponseValue;
}
	// void COption_PaymentHashZ_free(struct LDKCOption_PaymentHashZ _res);
/* @internal */
export function COption_PaymentHashZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentHashZ_free(_res);
	// debug statements here
}
	// uint64_t COption_PaymentHashZ_clone_ptr(LDKCOption_PaymentHashZ *NONNULL_PTR arg);
/* @internal */
export function COption_PaymentHashZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentHashZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_PaymentHashZ COption_PaymentHashZ_clone(const struct LDKCOption_PaymentHashZ *NONNULL_PTR orig);
/* @internal */
export function COption_PaymentHashZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_PaymentHashZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_EventZ COption_EventZ_some(struct LDKEvent o);
/* @internal */
export function COption_EventZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_EventZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_EventZ COption_EventZ_none(void);
/* @internal */
export function COption_EventZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_EventZ_none();
	return nativeResponseValue;
}
	// void COption_EventZ_free(struct LDKCOption_EventZ _res);
/* @internal */
export function COption_EventZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_EventZ_free(_res);
	// debug statements here
}
	// uint64_t COption_EventZ_clone_ptr(LDKCOption_EventZ *NONNULL_PTR arg);
/* @internal */
export function COption_EventZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_EventZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_EventZ COption_EventZ_clone(const struct LDKCOption_EventZ *NONNULL_PTR orig);
/* @internal */
export function COption_EventZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_EventZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_ok(struct LDKCOption_EventZ o);
/* @internal */
export function CResult_COption_EventZDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_COption_EventZDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_COption_EventZDecodeErrorZ_is_ok(const struct LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_COption_EventZDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_COption_EventZDecodeErrorZ_free(struct LDKCResult_COption_EventZDecodeErrorZ _res);
/* @internal */
export function CResult_COption_EventZDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_COption_EventZDecodeErrorZ_clone_ptr(LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_COption_EventZDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_clone(const struct LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_COption_EventZDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_MessageSendEventZ_free(struct LDKCVec_MessageSendEventZ _res);
/* @internal */
export function CVec_MessageSendEventZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_MessageSendEventZ_free(_res);
	// debug statements here
}
	// void CVec_ChainHashZ_free(struct LDKCVec_ChainHashZ _res);
/* @internal */
export function CVec_ChainHashZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_ChainHashZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_OfferBolt12ParseErrorZ CResult_OfferBolt12ParseErrorZ_ok(struct LDKOffer o);
/* @internal */
export function CResult_OfferBolt12ParseErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OfferBolt12ParseErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_OfferBolt12ParseErrorZ CResult_OfferBolt12ParseErrorZ_err(struct LDKBolt12ParseError e);
/* @internal */
export function CResult_OfferBolt12ParseErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OfferBolt12ParseErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_OfferBolt12ParseErrorZ_is_ok(const struct LDKCResult_OfferBolt12ParseErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_OfferBolt12ParseErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OfferBolt12ParseErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_OfferBolt12ParseErrorZ_free(struct LDKCResult_OfferBolt12ParseErrorZ _res);
/* @internal */
export function CResult_OfferBolt12ParseErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OfferBolt12ParseErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_OfferBolt12ParseErrorZ_clone_ptr(LDKCResult_OfferBolt12ParseErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_OfferBolt12ParseErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OfferBolt12ParseErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_OfferBolt12ParseErrorZ CResult_OfferBolt12ParseErrorZ_clone(const struct LDKCResult_OfferBolt12ParseErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_OfferBolt12ParseErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OfferBolt12ParseErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_ok(struct LDKPublicKey o);
/* @internal */
export function CResult_PublicKeyErrorZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_err(enum LDKSecp256k1Error e);
/* @internal */
export function CResult_PublicKeyErrorZ_err(e: Secp256k1Error): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PublicKeyErrorZ_is_ok(const struct LDKCResult_PublicKeyErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PublicKeyErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PublicKeyErrorZ_free(struct LDKCResult_PublicKeyErrorZ _res);
/* @internal */
export function CResult_PublicKeyErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_PublicKeyErrorZ_clone_ptr(LDKCResult_PublicKeyErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PublicKeyErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_clone(const struct LDKCResult_PublicKeyErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PublicKeyErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_ok(struct LDKNodeId o);
/* @internal */
export function CResult_NodeIdDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_NodeIdDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NodeIdDecodeErrorZ_is_ok(const struct LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NodeIdDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NodeIdDecodeErrorZ_free(struct LDKCResult_NodeIdDecodeErrorZ _res);
/* @internal */
export function CResult_NodeIdDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_NodeIdDecodeErrorZ_clone_ptr(LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NodeIdDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_clone(const struct LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NodeIdDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_ok(struct LDKCOption_NetworkUpdateZ o);
/* @internal */
export function CResult_COption_NetworkUpdateZDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_COption_NetworkUpdateZDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(const struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_COption_NetworkUpdateZDecodeErrorZ_free(struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ _res);
/* @internal */
export function CResult_COption_NetworkUpdateZDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_COption_NetworkUpdateZDecodeErrorZ_clone_ptr(LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_COption_NetworkUpdateZDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_clone(const struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_COption_NetworkUpdateZDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_UtxoLookupZ COption_UtxoLookupZ_some(struct LDKUtxoLookup o);
/* @internal */
export function COption_UtxoLookupZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_UtxoLookupZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_UtxoLookupZ COption_UtxoLookupZ_none(void);
/* @internal */
export function COption_UtxoLookupZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_UtxoLookupZ_none();
	return nativeResponseValue;
}
	// void COption_UtxoLookupZ_free(struct LDKCOption_UtxoLookupZ _res);
/* @internal */
export function COption_UtxoLookupZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_UtxoLookupZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_ok(void);
/* @internal */
export function CResult_NoneLightningErrorZ_ok(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_ok();
	return nativeResponseValue;
}
	// struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_err(struct LDKLightningError e);
/* @internal */
export function CResult_NoneLightningErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NoneLightningErrorZ_is_ok(const struct LDKCResult_NoneLightningErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NoneLightningErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NoneLightningErrorZ_free(struct LDKCResult_NoneLightningErrorZ _res);
/* @internal */
export function CResult_NoneLightningErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_NoneLightningErrorZ_clone_ptr(LDKCResult_NoneLightningErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NoneLightningErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_clone(const struct LDKCResult_NoneLightningErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NoneLightningErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_ok(bool o);
/* @internal */
export function CResult_boolLightningErrorZ_ok(o: boolean): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_err(struct LDKLightningError e);
/* @internal */
export function CResult_boolLightningErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_boolLightningErrorZ_is_ok(const struct LDKCResult_boolLightningErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_boolLightningErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_boolLightningErrorZ_free(struct LDKCResult_boolLightningErrorZ _res);
/* @internal */
export function CResult_boolLightningErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_boolLightningErrorZ_clone_ptr(LDKCResult_boolLightningErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_boolLightningErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_clone(const struct LDKCResult_boolLightningErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_boolLightningErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_clone(orig);
	return nativeResponseValue;
}
	// uint64_t C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone_ptr(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR arg);
/* @internal */
export function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(const struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR orig);
/* @internal */
export function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(struct LDKChannelAnnouncement a, struct LDKChannelUpdate b, struct LDKChannelUpdate c);
/* @internal */
export function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(a: bigint, b: bigint, c: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(a, b, c);
	return nativeResponseValue;
}
	// void C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ _res);
/* @internal */
export function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(_res);
	// debug statements here
}
	// struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_some(struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ o);
/* @internal */
export function COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_none(void);
/* @internal */
export function COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_none();
	return nativeResponseValue;
}
	// void COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ _res);
/* @internal */
export function COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(_res);
	// debug statements here
}
	// uint64_t COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_clone_ptr(LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ *NONNULL_PTR arg);
/* @internal */
export function COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_clone(const struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ *NONNULL_PTR orig);
/* @internal */
export function COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelUpdateInfoDecodeErrorZ CResult_ChannelUpdateInfoDecodeErrorZ_ok(struct LDKChannelUpdateInfo o);
/* @internal */
export function CResult_ChannelUpdateInfoDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateInfoDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelUpdateInfoDecodeErrorZ CResult_ChannelUpdateInfoDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelUpdateInfoDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateInfoDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelUpdateInfoDecodeErrorZ_is_ok(const struct LDKCResult_ChannelUpdateInfoDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelUpdateInfoDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateInfoDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelUpdateInfoDecodeErrorZ_free(struct LDKCResult_ChannelUpdateInfoDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelUpdateInfoDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateInfoDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ChannelUpdateInfoDecodeErrorZ_clone_ptr(LDKCResult_ChannelUpdateInfoDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelUpdateInfoDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateInfoDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelUpdateInfoDecodeErrorZ CResult_ChannelUpdateInfoDecodeErrorZ_clone(const struct LDKCResult_ChannelUpdateInfoDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelUpdateInfoDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateInfoDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_ok(struct LDKChannelInfo o);
/* @internal */
export function CResult_ChannelInfoDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelInfoDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelInfoDecodeErrorZ_is_ok(const struct LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelInfoDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelInfoDecodeErrorZ_free(struct LDKCResult_ChannelInfoDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelInfoDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ChannelInfoDecodeErrorZ_clone_ptr(LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelInfoDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_clone(const struct LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelInfoDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_ok(struct LDKRoutingFees o);
/* @internal */
export function CResult_RoutingFeesDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_RoutingFeesDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RoutingFeesDecodeErrorZ_is_ok(const struct LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RoutingFeesDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RoutingFeesDecodeErrorZ_free(struct LDKCResult_RoutingFeesDecodeErrorZ _res);
/* @internal */
export function CResult_RoutingFeesDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_RoutingFeesDecodeErrorZ_clone_ptr(LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RoutingFeesDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_clone(const struct LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RoutingFeesDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_NetAddressZ_free(struct LDKCVec_NetAddressZ _res);
/* @internal */
export function CVec_NetAddressZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_NetAddressZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_ok(struct LDKNodeAnnouncementInfo o);
/* @internal */
export function CResult_NodeAnnouncementInfoDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_NodeAnnouncementInfoDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(const struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NodeAnnouncementInfoDecodeErrorZ_free(struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ _res);
/* @internal */
export function CResult_NodeAnnouncementInfoDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_NodeAnnouncementInfoDecodeErrorZ_clone_ptr(LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NodeAnnouncementInfoDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_clone(const struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NodeAnnouncementInfoDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAliasDecodeErrorZ CResult_NodeAliasDecodeErrorZ_ok(struct LDKNodeAlias o);
/* @internal */
export function CResult_NodeAliasDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAliasDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAliasDecodeErrorZ CResult_NodeAliasDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_NodeAliasDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAliasDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NodeAliasDecodeErrorZ_is_ok(const struct LDKCResult_NodeAliasDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NodeAliasDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAliasDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NodeAliasDecodeErrorZ_free(struct LDKCResult_NodeAliasDecodeErrorZ _res);
/* @internal */
export function CResult_NodeAliasDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAliasDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_NodeAliasDecodeErrorZ_clone_ptr(LDKCResult_NodeAliasDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NodeAliasDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAliasDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAliasDecodeErrorZ CResult_NodeAliasDecodeErrorZ_clone(const struct LDKCResult_NodeAliasDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NodeAliasDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAliasDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_ok(struct LDKNodeInfo o);
/* @internal */
export function CResult_NodeInfoDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_NodeInfoDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NodeInfoDecodeErrorZ_is_ok(const struct LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NodeInfoDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NodeInfoDecodeErrorZ_free(struct LDKCResult_NodeInfoDecodeErrorZ _res);
/* @internal */
export function CResult_NodeInfoDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_NodeInfoDecodeErrorZ_clone_ptr(LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NodeInfoDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_clone(const struct LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NodeInfoDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_ok(struct LDKNetworkGraph o);
/* @internal */
export function CResult_NetworkGraphDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_NetworkGraphDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NetworkGraphDecodeErrorZ_is_ok(const struct LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NetworkGraphDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NetworkGraphDecodeErrorZ_free(struct LDKCResult_NetworkGraphDecodeErrorZ _res);
/* @internal */
export function CResult_NetworkGraphDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_free(_res);
	// debug statements here
}
	// struct LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_some(struct LDKCVec_NetAddressZ o);
/* @internal */
export function COption_CVec_NetAddressZZ_some(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_NetAddressZZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_none(void);
/* @internal */
export function COption_CVec_NetAddressZZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_NetAddressZZ_none();
	return nativeResponseValue;
}
	// void COption_CVec_NetAddressZZ_free(struct LDKCOption_CVec_NetAddressZZ _res);
/* @internal */
export function COption_CVec_NetAddressZZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_NetAddressZZ_free(_res);
	// debug statements here
}
	// uint64_t COption_CVec_NetAddressZZ_clone_ptr(LDKCOption_CVec_NetAddressZZ *NONNULL_PTR arg);
/* @internal */
export function COption_CVec_NetAddressZZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_NetAddressZZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_clone(const struct LDKCOption_CVec_NetAddressZZ *NONNULL_PTR orig);
/* @internal */
export function COption_CVec_NetAddressZZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_NetAddressZZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_HTLCOutputInCommitmentZ_free(struct LDKCVec_HTLCOutputInCommitmentZ _res);
/* @internal */
export function CVec_HTLCOutputInCommitmentZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_HTLCOutputInCommitmentZ_free(_res);
	// debug statements here
}
	// void CVec_HTLCDescriptorZ_free(struct LDKCVec_HTLCDescriptorZ _res);
/* @internal */
export function CVec_HTLCDescriptorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_HTLCDescriptorZ_free(_res);
	// debug statements here
}
	// void CVec_UtxoZ_free(struct LDKCVec_UtxoZ _res);
/* @internal */
export function CVec_UtxoZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_UtxoZ_free(_res);
	// debug statements here
}
	// struct LDKCOption_TxOutZ COption_TxOutZ_some(struct LDKTxOut o);
/* @internal */
export function COption_TxOutZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TxOutZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_TxOutZ COption_TxOutZ_none(void);
/* @internal */
export function COption_TxOutZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TxOutZ_none();
	return nativeResponseValue;
}
	// void COption_TxOutZ_free(struct LDKCOption_TxOutZ _res);
/* @internal */
export function COption_TxOutZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TxOutZ_free(_res);
	// debug statements here
}
	// uint64_t COption_TxOutZ_clone_ptr(LDKCOption_TxOutZ *NONNULL_PTR arg);
/* @internal */
export function COption_TxOutZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TxOutZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_TxOutZ COption_TxOutZ_clone(const struct LDKCOption_TxOutZ *NONNULL_PTR orig);
/* @internal */
export function COption_TxOutZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TxOutZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_InputZ_free(struct LDKCVec_InputZ _res);
/* @internal */
export function CVec_InputZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_InputZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_CoinSelectionNoneZ CResult_CoinSelectionNoneZ_ok(struct LDKCoinSelection o);
/* @internal */
export function CResult_CoinSelectionNoneZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CoinSelectionNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CoinSelectionNoneZ CResult_CoinSelectionNoneZ_err(void);
/* @internal */
export function CResult_CoinSelectionNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CoinSelectionNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_CoinSelectionNoneZ_is_ok(const struct LDKCResult_CoinSelectionNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_CoinSelectionNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CoinSelectionNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CoinSelectionNoneZ_free(struct LDKCResult_CoinSelectionNoneZ _res);
/* @internal */
export function CResult_CoinSelectionNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CoinSelectionNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_CoinSelectionNoneZ_clone_ptr(LDKCResult_CoinSelectionNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CoinSelectionNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CoinSelectionNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CoinSelectionNoneZ CResult_CoinSelectionNoneZ_clone(const struct LDKCResult_CoinSelectionNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CoinSelectionNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CoinSelectionNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_CVec_UtxoZNoneZ CResult_CVec_UtxoZNoneZ_ok(struct LDKCVec_UtxoZ o);
/* @internal */
export function CResult_CVec_UtxoZNoneZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_UtxoZNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CVec_UtxoZNoneZ CResult_CVec_UtxoZNoneZ_err(void);
/* @internal */
export function CResult_CVec_UtxoZNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_UtxoZNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_CVec_UtxoZNoneZ_is_ok(const struct LDKCResult_CVec_UtxoZNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_CVec_UtxoZNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_UtxoZNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CVec_UtxoZNoneZ_free(struct LDKCResult_CVec_UtxoZNoneZ _res);
/* @internal */
export function CResult_CVec_UtxoZNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_UtxoZNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_CVec_UtxoZNoneZ_clone_ptr(LDKCResult_CVec_UtxoZNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CVec_UtxoZNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_UtxoZNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CVec_UtxoZNoneZ CResult_CVec_UtxoZNoneZ_clone(const struct LDKCResult_CVec_UtxoZNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CVec_UtxoZNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_UtxoZNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_u16Z COption_u16Z_some(uint16_t o);
/* @internal */
export function COption_u16Z_some(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u16Z_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_u16Z COption_u16Z_none(void);
/* @internal */
export function COption_u16Z_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u16Z_none();
	return nativeResponseValue;
}
	// void COption_u16Z_free(struct LDKCOption_u16Z _res);
/* @internal */
export function COption_u16Z_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u16Z_free(_res);
	// debug statements here
}
	// uint64_t COption_u16Z_clone_ptr(LDKCOption_u16Z *NONNULL_PTR arg);
/* @internal */
export function COption_u16Z_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u16Z_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_u16Z COption_u16Z_clone(const struct LDKCOption_u16Z *NONNULL_PTR orig);
/* @internal */
export function COption_u16Z_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u16Z_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_ChannelShutdownStateZ COption_ChannelShutdownStateZ_some(enum LDKChannelShutdownState o);
/* @internal */
export function COption_ChannelShutdownStateZ_some(o: ChannelShutdownState): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ChannelShutdownStateZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_ChannelShutdownStateZ COption_ChannelShutdownStateZ_none(void);
/* @internal */
export function COption_ChannelShutdownStateZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ChannelShutdownStateZ_none();
	return nativeResponseValue;
}
	// void COption_ChannelShutdownStateZ_free(struct LDKCOption_ChannelShutdownStateZ _res);
/* @internal */
export function COption_ChannelShutdownStateZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ChannelShutdownStateZ_free(_res);
	// debug statements here
}
	// uint64_t COption_ChannelShutdownStateZ_clone_ptr(LDKCOption_ChannelShutdownStateZ *NONNULL_PTR arg);
/* @internal */
export function COption_ChannelShutdownStateZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ChannelShutdownStateZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_ChannelShutdownStateZ COption_ChannelShutdownStateZ_clone(const struct LDKCOption_ChannelShutdownStateZ *NONNULL_PTR orig);
/* @internal */
export function COption_ChannelShutdownStateZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ChannelShutdownStateZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */
export function CResult__u832APIErrorZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_err(struct LDKAPIError e);
/* @internal */
export function CResult__u832APIErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult__u832APIErrorZ_is_ok(const struct LDKCResult__u832APIErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult__u832APIErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult__u832APIErrorZ_free(struct LDKCResult__u832APIErrorZ _res);
/* @internal */
export function CResult__u832APIErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult__u832APIErrorZ_clone_ptr(LDKCResult__u832APIErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult__u832APIErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_clone(const struct LDKCResult__u832APIErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult__u832APIErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_RecentPaymentDetailsZ_free(struct LDKCVec_RecentPaymentDetailsZ _res);
/* @internal */
export function CVec_RecentPaymentDetailsZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_RecentPaymentDetailsZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_ok(void);
/* @internal */
export function CResult_NonePaymentSendFailureZ_ok(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_ok();
	return nativeResponseValue;
}
	// struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_err(struct LDKPaymentSendFailure e);
/* @internal */
export function CResult_NonePaymentSendFailureZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NonePaymentSendFailureZ_is_ok(const struct LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR o);
/* @internal */
export function CResult_NonePaymentSendFailureZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NonePaymentSendFailureZ_free(struct LDKCResult_NonePaymentSendFailureZ _res);
/* @internal */
export function CResult_NonePaymentSendFailureZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_NonePaymentSendFailureZ_clone_ptr(LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NonePaymentSendFailureZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_clone(const struct LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NonePaymentSendFailureZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneRetryableSendFailureZ CResult_NoneRetryableSendFailureZ_ok(void);
/* @internal */
export function CResult_NoneRetryableSendFailureZ_ok(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneRetryableSendFailureZ_ok();
	return nativeResponseValue;
}
	// struct LDKCResult_NoneRetryableSendFailureZ CResult_NoneRetryableSendFailureZ_err(enum LDKRetryableSendFailure e);
/* @internal */
export function CResult_NoneRetryableSendFailureZ_err(e: RetryableSendFailure): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneRetryableSendFailureZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NoneRetryableSendFailureZ_is_ok(const struct LDKCResult_NoneRetryableSendFailureZ *NONNULL_PTR o);
/* @internal */
export function CResult_NoneRetryableSendFailureZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneRetryableSendFailureZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NoneRetryableSendFailureZ_free(struct LDKCResult_NoneRetryableSendFailureZ _res);
/* @internal */
export function CResult_NoneRetryableSendFailureZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneRetryableSendFailureZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_NoneRetryableSendFailureZ_clone_ptr(LDKCResult_NoneRetryableSendFailureZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NoneRetryableSendFailureZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneRetryableSendFailureZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneRetryableSendFailureZ CResult_NoneRetryableSendFailureZ_clone(const struct LDKCResult_NoneRetryableSendFailureZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NoneRetryableSendFailureZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneRetryableSendFailureZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentHashPaymentSendFailureZ CResult_PaymentHashPaymentSendFailureZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */
export function CResult_PaymentHashPaymentSendFailureZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentHashPaymentSendFailureZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentHashPaymentSendFailureZ CResult_PaymentHashPaymentSendFailureZ_err(struct LDKPaymentSendFailure e);
/* @internal */
export function CResult_PaymentHashPaymentSendFailureZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentHashPaymentSendFailureZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PaymentHashPaymentSendFailureZ_is_ok(const struct LDKCResult_PaymentHashPaymentSendFailureZ *NONNULL_PTR o);
/* @internal */
export function CResult_PaymentHashPaymentSendFailureZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentHashPaymentSendFailureZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PaymentHashPaymentSendFailureZ_free(struct LDKCResult_PaymentHashPaymentSendFailureZ _res);
/* @internal */
export function CResult_PaymentHashPaymentSendFailureZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentHashPaymentSendFailureZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_PaymentHashPaymentSendFailureZ_clone_ptr(LDKCResult_PaymentHashPaymentSendFailureZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PaymentHashPaymentSendFailureZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentHashPaymentSendFailureZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentHashPaymentSendFailureZ CResult_PaymentHashPaymentSendFailureZ_clone(const struct LDKCResult_PaymentHashPaymentSendFailureZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PaymentHashPaymentSendFailureZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentHashPaymentSendFailureZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentHashRetryableSendFailureZ CResult_PaymentHashRetryableSendFailureZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */
export function CResult_PaymentHashRetryableSendFailureZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentHashRetryableSendFailureZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentHashRetryableSendFailureZ CResult_PaymentHashRetryableSendFailureZ_err(enum LDKRetryableSendFailure e);
/* @internal */
export function CResult_PaymentHashRetryableSendFailureZ_err(e: RetryableSendFailure): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentHashRetryableSendFailureZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PaymentHashRetryableSendFailureZ_is_ok(const struct LDKCResult_PaymentHashRetryableSendFailureZ *NONNULL_PTR o);
/* @internal */
export function CResult_PaymentHashRetryableSendFailureZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentHashRetryableSendFailureZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PaymentHashRetryableSendFailureZ_free(struct LDKCResult_PaymentHashRetryableSendFailureZ _res);
/* @internal */
export function CResult_PaymentHashRetryableSendFailureZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentHashRetryableSendFailureZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_PaymentHashRetryableSendFailureZ_clone_ptr(LDKCResult_PaymentHashRetryableSendFailureZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PaymentHashRetryableSendFailureZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentHashRetryableSendFailureZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentHashRetryableSendFailureZ CResult_PaymentHashRetryableSendFailureZ_clone(const struct LDKCResult_PaymentHashRetryableSendFailureZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PaymentHashRetryableSendFailureZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentHashRetryableSendFailureZ_clone(orig);
	return nativeResponseValue;
}
	// uint64_t C2Tuple_PaymentHashPaymentIdZ_clone_ptr(LDKC2Tuple_PaymentHashPaymentIdZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_PaymentHashPaymentIdZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PaymentHashPaymentIdZ C2Tuple_PaymentHashPaymentIdZ_clone(const struct LDKC2Tuple_PaymentHashPaymentIdZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_PaymentHashPaymentIdZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PaymentHashPaymentIdZ C2Tuple_PaymentHashPaymentIdZ_new(struct LDKThirtyTwoBytes a, struct LDKThirtyTwoBytes b);
/* @internal */
export function C2Tuple_PaymentHashPaymentIdZ_new(a: number, b: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_PaymentHashPaymentIdZ_free(struct LDKC2Tuple_PaymentHashPaymentIdZ _res);
/* @internal */
export function C2Tuple_PaymentHashPaymentIdZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok(struct LDKC2Tuple_PaymentHashPaymentIdZ o);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err(struct LDKPaymentSendFailure e);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok(const struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR o);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free(struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ _res);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone_ptr(LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR arg);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone(const struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR orig);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_ThirtyTwoBytesZ_free(struct LDKCVec_ThirtyTwoBytesZ _res);
/* @internal */
export function CVec_ThirtyTwoBytesZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_ThirtyTwoBytesZ_free(_res);
	// debug statements here
}
	// uint64_t C2Tuple_PaymentHashPaymentSecretZ_clone_ptr(LDKC2Tuple_PaymentHashPaymentSecretZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_PaymentHashPaymentSecretZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PaymentHashPaymentSecretZ C2Tuple_PaymentHashPaymentSecretZ_clone(const struct LDKC2Tuple_PaymentHashPaymentSecretZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_PaymentHashPaymentSecretZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PaymentHashPaymentSecretZ C2Tuple_PaymentHashPaymentSecretZ_new(struct LDKThirtyTwoBytes a, struct LDKThirtyTwoBytes b);
/* @internal */
export function C2Tuple_PaymentHashPaymentSecretZ_new(a: number, b: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_PaymentHashPaymentSecretZ_free(struct LDKC2Tuple_PaymentHashPaymentSecretZ _res);
/* @internal */
export function C2Tuple_PaymentHashPaymentSecretZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok(struct LDKC2Tuple_PaymentHashPaymentSecretZ o);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err(void);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free(struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ _res);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone_ptr(LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */
export function CResult_PaymentSecretNoneZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_err(void);
/* @internal */
export function CResult_PaymentSecretNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_PaymentSecretNoneZ_is_ok(const struct LDKCResult_PaymentSecretNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_PaymentSecretNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PaymentSecretNoneZ_free(struct LDKCResult_PaymentSecretNoneZ _res);
/* @internal */
export function CResult_PaymentSecretNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_PaymentSecretNoneZ_clone_ptr(LDKCResult_PaymentSecretNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PaymentSecretNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_clone(const struct LDKCResult_PaymentSecretNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PaymentSecretNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */
export function CResult_PaymentPreimageAPIErrorZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_err(struct LDKAPIError e);
/* @internal */
export function CResult_PaymentPreimageAPIErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PaymentPreimageAPIErrorZ_is_ok(const struct LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PaymentPreimageAPIErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PaymentPreimageAPIErrorZ_free(struct LDKCResult_PaymentPreimageAPIErrorZ _res);
/* @internal */
export function CResult_PaymentPreimageAPIErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_PaymentPreimageAPIErrorZ_clone_ptr(LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PaymentPreimageAPIErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_clone(const struct LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PaymentPreimageAPIErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_CVec_ChainHashZZ COption_CVec_ChainHashZZ_some(struct LDKCVec_ChainHashZ o);
/* @internal */
export function COption_CVec_ChainHashZZ_some(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_ChainHashZZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_CVec_ChainHashZZ COption_CVec_ChainHashZZ_none(void);
/* @internal */
export function COption_CVec_ChainHashZZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_ChainHashZZ_none();
	return nativeResponseValue;
}
	// void COption_CVec_ChainHashZZ_free(struct LDKCOption_CVec_ChainHashZZ _res);
/* @internal */
export function COption_CVec_ChainHashZZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_ChainHashZZ_free(_res);
	// debug statements here
}
	// uint64_t COption_CVec_ChainHashZZ_clone_ptr(LDKCOption_CVec_ChainHashZZ *NONNULL_PTR arg);
/* @internal */
export function COption_CVec_ChainHashZZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_ChainHashZZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_CVec_ChainHashZZ COption_CVec_ChainHashZZ_clone(const struct LDKCOption_CVec_ChainHashZZ *NONNULL_PTR orig);
/* @internal */
export function COption_CVec_ChainHashZZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_ChainHashZZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CResult_CounterpartyForwardingInfoDecodeErrorZ_ok(struct LDKCounterpartyForwardingInfo o);
/* @internal */
export function CResult_CounterpartyForwardingInfoDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyForwardingInfoDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CResult_CounterpartyForwardingInfoDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_CounterpartyForwardingInfoDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyForwardingInfoDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_CounterpartyForwardingInfoDecodeErrorZ_is_ok(const struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_CounterpartyForwardingInfoDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyForwardingInfoDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CounterpartyForwardingInfoDecodeErrorZ_free(struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ _res);
/* @internal */
export function CResult_CounterpartyForwardingInfoDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyForwardingInfoDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_CounterpartyForwardingInfoDecodeErrorZ_clone_ptr(LDKCResult_CounterpartyForwardingInfoDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CounterpartyForwardingInfoDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyForwardingInfoDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CResult_CounterpartyForwardingInfoDecodeErrorZ_clone(const struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CounterpartyForwardingInfoDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyForwardingInfoDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelCounterpartyDecodeErrorZ CResult_ChannelCounterpartyDecodeErrorZ_ok(struct LDKChannelCounterparty o);
/* @internal */
export function CResult_ChannelCounterpartyDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelCounterpartyDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelCounterpartyDecodeErrorZ CResult_ChannelCounterpartyDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelCounterpartyDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelCounterpartyDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelCounterpartyDecodeErrorZ_is_ok(const struct LDKCResult_ChannelCounterpartyDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelCounterpartyDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelCounterpartyDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelCounterpartyDecodeErrorZ_free(struct LDKCResult_ChannelCounterpartyDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelCounterpartyDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelCounterpartyDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ChannelCounterpartyDecodeErrorZ_clone_ptr(LDKCResult_ChannelCounterpartyDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelCounterpartyDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelCounterpartyDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelCounterpartyDecodeErrorZ CResult_ChannelCounterpartyDecodeErrorZ_clone(const struct LDKCResult_ChannelCounterpartyDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelCounterpartyDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelCounterpartyDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelDetailsDecodeErrorZ CResult_ChannelDetailsDecodeErrorZ_ok(struct LDKChannelDetails o);
/* @internal */
export function CResult_ChannelDetailsDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelDetailsDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelDetailsDecodeErrorZ CResult_ChannelDetailsDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelDetailsDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelDetailsDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelDetailsDecodeErrorZ_is_ok(const struct LDKCResult_ChannelDetailsDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelDetailsDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelDetailsDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelDetailsDecodeErrorZ_free(struct LDKCResult_ChannelDetailsDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelDetailsDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelDetailsDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ChannelDetailsDecodeErrorZ_clone_ptr(LDKCResult_ChannelDetailsDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelDetailsDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelDetailsDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelDetailsDecodeErrorZ CResult_ChannelDetailsDecodeErrorZ_clone(const struct LDKCResult_ChannelDetailsDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelDetailsDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelDetailsDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PhantomRouteHintsDecodeErrorZ CResult_PhantomRouteHintsDecodeErrorZ_ok(struct LDKPhantomRouteHints o);
/* @internal */
export function CResult_PhantomRouteHintsDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PhantomRouteHintsDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PhantomRouteHintsDecodeErrorZ CResult_PhantomRouteHintsDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_PhantomRouteHintsDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PhantomRouteHintsDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PhantomRouteHintsDecodeErrorZ_is_ok(const struct LDKCResult_PhantomRouteHintsDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PhantomRouteHintsDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PhantomRouteHintsDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PhantomRouteHintsDecodeErrorZ_free(struct LDKCResult_PhantomRouteHintsDecodeErrorZ _res);
/* @internal */
export function CResult_PhantomRouteHintsDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PhantomRouteHintsDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_PhantomRouteHintsDecodeErrorZ_clone_ptr(LDKCResult_PhantomRouteHintsDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PhantomRouteHintsDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PhantomRouteHintsDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PhantomRouteHintsDecodeErrorZ CResult_PhantomRouteHintsDecodeErrorZ_clone(const struct LDKCResult_PhantomRouteHintsDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PhantomRouteHintsDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PhantomRouteHintsDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelShutdownStateDecodeErrorZ CResult_ChannelShutdownStateDecodeErrorZ_ok(enum LDKChannelShutdownState o);
/* @internal */
export function CResult_ChannelShutdownStateDecodeErrorZ_ok(o: ChannelShutdownState): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelShutdownStateDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelShutdownStateDecodeErrorZ CResult_ChannelShutdownStateDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelShutdownStateDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelShutdownStateDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelShutdownStateDecodeErrorZ_is_ok(const struct LDKCResult_ChannelShutdownStateDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelShutdownStateDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelShutdownStateDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelShutdownStateDecodeErrorZ_free(struct LDKCResult_ChannelShutdownStateDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelShutdownStateDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelShutdownStateDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ChannelShutdownStateDecodeErrorZ_clone_ptr(LDKCResult_ChannelShutdownStateDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelShutdownStateDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelShutdownStateDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelShutdownStateDecodeErrorZ CResult_ChannelShutdownStateDecodeErrorZ_clone(const struct LDKCResult_ChannelShutdownStateDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelShutdownStateDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelShutdownStateDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_ChannelMonitorZ_free(struct LDKCVec_ChannelMonitorZ _res);
/* @internal */
export function CVec_ChannelMonitorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_ChannelMonitorZ_free(_res);
	// debug statements here
}
	// struct LDKC2Tuple_BlockHashChannelManagerZ C2Tuple_BlockHashChannelManagerZ_new(struct LDKThirtyTwoBytes a, struct LDKChannelManager b);
/* @internal */
export function C2Tuple_BlockHashChannelManagerZ_new(a: number, b: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelManagerZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_BlockHashChannelManagerZ_free(struct LDKC2Tuple_BlockHashChannelManagerZ _res);
/* @internal */
export function C2Tuple_BlockHashChannelManagerZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelManagerZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok(struct LDKC2Tuple_BlockHashChannelManagerZ o);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok(const struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free(struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ _res);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_MaxDustHTLCExposureDecodeErrorZ CResult_MaxDustHTLCExposureDecodeErrorZ_ok(struct LDKMaxDustHTLCExposure o);
/* @internal */
export function CResult_MaxDustHTLCExposureDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_MaxDustHTLCExposureDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_MaxDustHTLCExposureDecodeErrorZ CResult_MaxDustHTLCExposureDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_MaxDustHTLCExposureDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_MaxDustHTLCExposureDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_MaxDustHTLCExposureDecodeErrorZ_is_ok(const struct LDKCResult_MaxDustHTLCExposureDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_MaxDustHTLCExposureDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_MaxDustHTLCExposureDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_MaxDustHTLCExposureDecodeErrorZ_free(struct LDKCResult_MaxDustHTLCExposureDecodeErrorZ _res);
/* @internal */
export function CResult_MaxDustHTLCExposureDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_MaxDustHTLCExposureDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_MaxDustHTLCExposureDecodeErrorZ_clone_ptr(LDKCResult_MaxDustHTLCExposureDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_MaxDustHTLCExposureDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_MaxDustHTLCExposureDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_MaxDustHTLCExposureDecodeErrorZ CResult_MaxDustHTLCExposureDecodeErrorZ_clone(const struct LDKCResult_MaxDustHTLCExposureDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_MaxDustHTLCExposureDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_MaxDustHTLCExposureDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_ok(struct LDKChannelConfig o);
/* @internal */
export function CResult_ChannelConfigDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelConfigDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelConfigDecodeErrorZ_is_ok(const struct LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelConfigDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelConfigDecodeErrorZ_free(struct LDKCResult_ChannelConfigDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelConfigDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ChannelConfigDecodeErrorZ_clone_ptr(LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelConfigDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_clone(const struct LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelConfigDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_MaxDustHTLCExposureZ COption_MaxDustHTLCExposureZ_some(struct LDKMaxDustHTLCExposure o);
/* @internal */
export function COption_MaxDustHTLCExposureZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_MaxDustHTLCExposureZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_MaxDustHTLCExposureZ COption_MaxDustHTLCExposureZ_none(void);
/* @internal */
export function COption_MaxDustHTLCExposureZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_MaxDustHTLCExposureZ_none();
	return nativeResponseValue;
}
	// void COption_MaxDustHTLCExposureZ_free(struct LDKCOption_MaxDustHTLCExposureZ _res);
/* @internal */
export function COption_MaxDustHTLCExposureZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_MaxDustHTLCExposureZ_free(_res);
	// debug statements here
}
	// uint64_t COption_MaxDustHTLCExposureZ_clone_ptr(LDKCOption_MaxDustHTLCExposureZ *NONNULL_PTR arg);
/* @internal */
export function COption_MaxDustHTLCExposureZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_MaxDustHTLCExposureZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_MaxDustHTLCExposureZ COption_MaxDustHTLCExposureZ_clone(const struct LDKCOption_MaxDustHTLCExposureZ *NONNULL_PTR orig);
/* @internal */
export function COption_MaxDustHTLCExposureZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_MaxDustHTLCExposureZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_APIErrorZ COption_APIErrorZ_some(struct LDKAPIError o);
/* @internal */
export function COption_APIErrorZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_APIErrorZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_APIErrorZ COption_APIErrorZ_none(void);
/* @internal */
export function COption_APIErrorZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_APIErrorZ_none();
	return nativeResponseValue;
}
	// void COption_APIErrorZ_free(struct LDKCOption_APIErrorZ _res);
/* @internal */
export function COption_APIErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_APIErrorZ_free(_res);
	// debug statements here
}
	// uint64_t COption_APIErrorZ_clone_ptr(LDKCOption_APIErrorZ *NONNULL_PTR arg);
/* @internal */
export function COption_APIErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_APIErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_APIErrorZ COption_APIErrorZ_clone(const struct LDKCOption_APIErrorZ *NONNULL_PTR orig);
/* @internal */
export function COption_APIErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_APIErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_APIErrorZDecodeErrorZ CResult_COption_APIErrorZDecodeErrorZ_ok(struct LDKCOption_APIErrorZ o);
/* @internal */
export function CResult_COption_APIErrorZDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_APIErrorZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_APIErrorZDecodeErrorZ CResult_COption_APIErrorZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_COption_APIErrorZDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_APIErrorZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_COption_APIErrorZDecodeErrorZ_is_ok(const struct LDKCResult_COption_APIErrorZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_COption_APIErrorZDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_APIErrorZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_COption_APIErrorZDecodeErrorZ_free(struct LDKCResult_COption_APIErrorZDecodeErrorZ _res);
/* @internal */
export function CResult_COption_APIErrorZDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_APIErrorZDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_COption_APIErrorZDecodeErrorZ_clone_ptr(LDKCResult_COption_APIErrorZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_COption_APIErrorZDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_APIErrorZDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_APIErrorZDecodeErrorZ CResult_COption_APIErrorZDecodeErrorZ_clone(const struct LDKCResult_COption_APIErrorZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_COption_APIErrorZDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_APIErrorZDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_BigSizeDecodeErrorZ CResult_BigSizeDecodeErrorZ_ok(struct LDKBigSize o);
/* @internal */
export function CResult_BigSizeDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BigSizeDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_BigSizeDecodeErrorZ CResult_BigSizeDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_BigSizeDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BigSizeDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_BigSizeDecodeErrorZ_is_ok(const struct LDKCResult_BigSizeDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_BigSizeDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BigSizeDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_BigSizeDecodeErrorZ_free(struct LDKCResult_BigSizeDecodeErrorZ _res);
/* @internal */
export function CResult_BigSizeDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BigSizeDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_BigSizeDecodeErrorZ_clone_ptr(LDKCResult_BigSizeDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_BigSizeDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BigSizeDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_BigSizeDecodeErrorZ CResult_BigSizeDecodeErrorZ_clone(const struct LDKCResult_BigSizeDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_BigSizeDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BigSizeDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_HostnameDecodeErrorZ CResult_HostnameDecodeErrorZ_ok(struct LDKHostname o);
/* @internal */
export function CResult_HostnameDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HostnameDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_HostnameDecodeErrorZ CResult_HostnameDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_HostnameDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HostnameDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_HostnameDecodeErrorZ_is_ok(const struct LDKCResult_HostnameDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_HostnameDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HostnameDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_HostnameDecodeErrorZ_free(struct LDKCResult_HostnameDecodeErrorZ _res);
/* @internal */
export function CResult_HostnameDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HostnameDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_HostnameDecodeErrorZ_clone_ptr(LDKCResult_HostnameDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_HostnameDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HostnameDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_HostnameDecodeErrorZ CResult_HostnameDecodeErrorZ_clone(const struct LDKCResult_HostnameDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_HostnameDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HostnameDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TransactionU16LenLimitedNoneZ CResult_TransactionU16LenLimitedNoneZ_ok(struct LDKTransactionU16LenLimited o);
/* @internal */
export function CResult_TransactionU16LenLimitedNoneZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionU16LenLimitedNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TransactionU16LenLimitedNoneZ CResult_TransactionU16LenLimitedNoneZ_err(void);
/* @internal */
export function CResult_TransactionU16LenLimitedNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionU16LenLimitedNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_TransactionU16LenLimitedNoneZ_is_ok(const struct LDKCResult_TransactionU16LenLimitedNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_TransactionU16LenLimitedNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionU16LenLimitedNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TransactionU16LenLimitedNoneZ_free(struct LDKCResult_TransactionU16LenLimitedNoneZ _res);
/* @internal */
export function CResult_TransactionU16LenLimitedNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionU16LenLimitedNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_TransactionU16LenLimitedNoneZ_clone_ptr(LDKCResult_TransactionU16LenLimitedNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TransactionU16LenLimitedNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionU16LenLimitedNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TransactionU16LenLimitedNoneZ CResult_TransactionU16LenLimitedNoneZ_clone(const struct LDKCResult_TransactionU16LenLimitedNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TransactionU16LenLimitedNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionU16LenLimitedNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TransactionU16LenLimitedDecodeErrorZ CResult_TransactionU16LenLimitedDecodeErrorZ_ok(struct LDKTransactionU16LenLimited o);
/* @internal */
export function CResult_TransactionU16LenLimitedDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionU16LenLimitedDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TransactionU16LenLimitedDecodeErrorZ CResult_TransactionU16LenLimitedDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_TransactionU16LenLimitedDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionU16LenLimitedDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_TransactionU16LenLimitedDecodeErrorZ_is_ok(const struct LDKCResult_TransactionU16LenLimitedDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_TransactionU16LenLimitedDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionU16LenLimitedDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TransactionU16LenLimitedDecodeErrorZ_free(struct LDKCResult_TransactionU16LenLimitedDecodeErrorZ _res);
/* @internal */
export function CResult_TransactionU16LenLimitedDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionU16LenLimitedDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_TransactionU16LenLimitedDecodeErrorZ_clone_ptr(LDKCResult_TransactionU16LenLimitedDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TransactionU16LenLimitedDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionU16LenLimitedDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TransactionU16LenLimitedDecodeErrorZ CResult_TransactionU16LenLimitedDecodeErrorZ_clone(const struct LDKCResult_TransactionU16LenLimitedDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TransactionU16LenLimitedDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionU16LenLimitedDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_UntrustedStringDecodeErrorZ CResult_UntrustedStringDecodeErrorZ_ok(struct LDKUntrustedString o);
/* @internal */
export function CResult_UntrustedStringDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UntrustedStringDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_UntrustedStringDecodeErrorZ CResult_UntrustedStringDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_UntrustedStringDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UntrustedStringDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_UntrustedStringDecodeErrorZ_is_ok(const struct LDKCResult_UntrustedStringDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_UntrustedStringDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UntrustedStringDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_UntrustedStringDecodeErrorZ_free(struct LDKCResult_UntrustedStringDecodeErrorZ _res);
/* @internal */
export function CResult_UntrustedStringDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UntrustedStringDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_UntrustedStringDecodeErrorZ_clone_ptr(LDKCResult_UntrustedStringDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_UntrustedStringDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UntrustedStringDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_UntrustedStringDecodeErrorZ CResult_UntrustedStringDecodeErrorZ_clone(const struct LDKCResult_UntrustedStringDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_UntrustedStringDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UntrustedStringDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_ok(struct LDKOutPoint o);
/* @internal */
export function CResult_OutPointDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_OutPointDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_OutPointDecodeErrorZ_is_ok(const struct LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_OutPointDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_OutPointDecodeErrorZ_free(struct LDKCResult_OutPointDecodeErrorZ _res);
/* @internal */
export function CResult_OutPointDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_OutPointDecodeErrorZ_clone_ptr(LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_OutPointDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_clone(const struct LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_OutPointDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_TypeZ COption_TypeZ_some(struct LDKType o);
/* @internal */
export function COption_TypeZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TypeZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_TypeZ COption_TypeZ_none(void);
/* @internal */
export function COption_TypeZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TypeZ_none();
	return nativeResponseValue;
}
	// void COption_TypeZ_free(struct LDKCOption_TypeZ _res);
/* @internal */
export function COption_TypeZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TypeZ_free(_res);
	// debug statements here
}
	// uint64_t COption_TypeZ_clone_ptr(LDKCOption_TypeZ *NONNULL_PTR arg);
/* @internal */
export function COption_TypeZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TypeZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_TypeZ COption_TypeZ_clone(const struct LDKCOption_TypeZ *NONNULL_PTR orig);
/* @internal */
export function COption_TypeZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TypeZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_ok(struct LDKCOption_TypeZ o);
/* @internal */
export function CResult_COption_TypeZDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_COption_TypeZDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_COption_TypeZDecodeErrorZ_is_ok(const struct LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_COption_TypeZDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_COption_TypeZDecodeErrorZ_free(struct LDKCResult_COption_TypeZDecodeErrorZ _res);
/* @internal */
export function CResult_COption_TypeZDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_COption_TypeZDecodeErrorZ_clone_ptr(LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_COption_TypeZDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_clone(const struct LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_COption_TypeZDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentIdPaymentErrorZ CResult_PaymentIdPaymentErrorZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */
export function CResult_PaymentIdPaymentErrorZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentIdPaymentErrorZ CResult_PaymentIdPaymentErrorZ_err(struct LDKPaymentError e);
/* @internal */
export function CResult_PaymentIdPaymentErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PaymentIdPaymentErrorZ_is_ok(const struct LDKCResult_PaymentIdPaymentErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PaymentIdPaymentErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PaymentIdPaymentErrorZ_free(struct LDKCResult_PaymentIdPaymentErrorZ _res);
/* @internal */
export function CResult_PaymentIdPaymentErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_PaymentIdPaymentErrorZ_clone_ptr(LDKCResult_PaymentIdPaymentErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PaymentIdPaymentErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentIdPaymentErrorZ CResult_PaymentIdPaymentErrorZ_clone(const struct LDKCResult_PaymentIdPaymentErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PaymentIdPaymentErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NonePaymentErrorZ CResult_NonePaymentErrorZ_ok(void);
/* @internal */
export function CResult_NonePaymentErrorZ_ok(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentErrorZ_ok();
	return nativeResponseValue;
}
	// struct LDKCResult_NonePaymentErrorZ CResult_NonePaymentErrorZ_err(struct LDKPaymentError e);
/* @internal */
export function CResult_NonePaymentErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NonePaymentErrorZ_is_ok(const struct LDKCResult_NonePaymentErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NonePaymentErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NonePaymentErrorZ_free(struct LDKCResult_NonePaymentErrorZ _res);
/* @internal */
export function CResult_NonePaymentErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_NonePaymentErrorZ_clone_ptr(LDKCResult_NonePaymentErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NonePaymentErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NonePaymentErrorZ CResult_NonePaymentErrorZ_clone(const struct LDKCResult_NonePaymentErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NonePaymentErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_StringErrorZ CResult_StringErrorZ_ok(struct LDKStr o);
/* @internal */
export function CResult_StringErrorZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StringErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_StringErrorZ CResult_StringErrorZ_err(enum LDKSecp256k1Error e);
/* @internal */
export function CResult_StringErrorZ_err(e: Secp256k1Error): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StringErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_StringErrorZ_is_ok(const struct LDKCResult_StringErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_StringErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StringErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_StringErrorZ_free(struct LDKCResult_StringErrorZ _res);
/* @internal */
export function CResult_StringErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StringErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_StringErrorZ_clone_ptr(LDKCResult_StringErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_StringErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StringErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_StringErrorZ CResult_StringErrorZ_clone(const struct LDKCResult_StringErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_StringErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StringErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_ok(struct LDKChannelMonitorUpdate o);
/* @internal */
export function CResult_ChannelMonitorUpdateDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelMonitorUpdateDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(const struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelMonitorUpdateDecodeErrorZ_free(struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelMonitorUpdateDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ChannelMonitorUpdateDecodeErrorZ_clone_ptr(LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelMonitorUpdateDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_clone(const struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelMonitorUpdateDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_MonitorEventZ COption_MonitorEventZ_some(struct LDKMonitorEvent o);
/* @internal */
export function COption_MonitorEventZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_MonitorEventZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_MonitorEventZ COption_MonitorEventZ_none(void);
/* @internal */
export function COption_MonitorEventZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_MonitorEventZ_none();
	return nativeResponseValue;
}
	// void COption_MonitorEventZ_free(struct LDKCOption_MonitorEventZ _res);
/* @internal */
export function COption_MonitorEventZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_MonitorEventZ_free(_res);
	// debug statements here
}
	// uint64_t COption_MonitorEventZ_clone_ptr(LDKCOption_MonitorEventZ *NONNULL_PTR arg);
/* @internal */
export function COption_MonitorEventZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_MonitorEventZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_MonitorEventZ COption_MonitorEventZ_clone(const struct LDKCOption_MonitorEventZ *NONNULL_PTR orig);
/* @internal */
export function COption_MonitorEventZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_MonitorEventZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_ok(struct LDKCOption_MonitorEventZ o);
/* @internal */
export function CResult_COption_MonitorEventZDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_COption_MonitorEventZDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_COption_MonitorEventZDecodeErrorZ_is_ok(const struct LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_COption_MonitorEventZDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_COption_MonitorEventZDecodeErrorZ_free(struct LDKCResult_COption_MonitorEventZDecodeErrorZ _res);
/* @internal */
export function CResult_COption_MonitorEventZDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_COption_MonitorEventZDecodeErrorZ_clone_ptr(LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_COption_MonitorEventZDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_clone(const struct LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_COption_MonitorEventZDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_ok(struct LDKHTLCUpdate o);
/* @internal */
export function CResult_HTLCUpdateDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_HTLCUpdateDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_HTLCUpdateDecodeErrorZ_is_ok(const struct LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_HTLCUpdateDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_HTLCUpdateDecodeErrorZ_free(struct LDKCResult_HTLCUpdateDecodeErrorZ _res);
/* @internal */
export function CResult_HTLCUpdateDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_HTLCUpdateDecodeErrorZ_clone_ptr(LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_HTLCUpdateDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_clone(const struct LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_HTLCUpdateDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// uint64_t C2Tuple_OutPointScriptZ_clone_ptr(LDKC2Tuple_OutPointScriptZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_OutPointScriptZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointScriptZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_OutPointScriptZ C2Tuple_OutPointScriptZ_clone(const struct LDKC2Tuple_OutPointScriptZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_OutPointScriptZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointScriptZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_OutPointScriptZ C2Tuple_OutPointScriptZ_new(struct LDKOutPoint a, struct LDKCVec_u8Z b);
/* @internal */
export function C2Tuple_OutPointScriptZ_new(a: bigint, b: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointScriptZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_OutPointScriptZ_free(struct LDKC2Tuple_OutPointScriptZ _res);
/* @internal */
export function C2Tuple_OutPointScriptZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointScriptZ_free(_res);
	// debug statements here
}
	// uint64_t C2Tuple_u32ScriptZ_clone_ptr(LDKC2Tuple_u32ScriptZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_u32ScriptZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32ScriptZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_u32ScriptZ C2Tuple_u32ScriptZ_clone(const struct LDKC2Tuple_u32ScriptZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_u32ScriptZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32ScriptZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_u32ScriptZ C2Tuple_u32ScriptZ_new(uint32_t a, struct LDKCVec_u8Z b);
/* @internal */
export function C2Tuple_u32ScriptZ_new(a: number, b: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32ScriptZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_u32ScriptZ_free(struct LDKC2Tuple_u32ScriptZ _res);
/* @internal */
export function C2Tuple_u32ScriptZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32ScriptZ_free(_res);
	// debug statements here
}
	// void CVec_C2Tuple_u32ScriptZZ_free(struct LDKCVec_C2Tuple_u32ScriptZZ _res);
/* @internal */
export function CVec_C2Tuple_u32ScriptZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C2Tuple_u32ScriptZZ_free(_res);
	// debug statements here
}
	// uint64_t C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone_ptr(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone(const struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new(struct LDKThirtyTwoBytes a, struct LDKCVec_C2Tuple_u32ScriptZZ b);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new(a: number, b: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free(struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ _res);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free(_res);
	// debug statements here
}
	// void CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free(struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ _res);
/* @internal */
export function CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free(_res);
	// debug statements here
}
	// uint64_t C2Tuple_u32TxOutZ_clone_ptr(LDKC2Tuple_u32TxOutZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_u32TxOutZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_clone(const struct LDKC2Tuple_u32TxOutZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_u32TxOutZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_new(uint32_t a, struct LDKTxOut b);
/* @internal */
export function C2Tuple_u32TxOutZ_new(a: number, b: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_u32TxOutZ_free(struct LDKC2Tuple_u32TxOutZ _res);
/* @internal */
export function C2Tuple_u32TxOutZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_free(_res);
	// debug statements here
}
	// void CVec_C2Tuple_u32TxOutZZ_free(struct LDKCVec_C2Tuple_u32TxOutZZ _res);
/* @internal */
export function CVec_C2Tuple_u32TxOutZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C2Tuple_u32TxOutZZ_free(_res);
	// debug statements here
}
	// uint64_t C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone_ptr(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone(const struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new(struct LDKThirtyTwoBytes a, struct LDKCVec_C2Tuple_u32TxOutZZ b);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new(a: number, b: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free(struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ _res);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free(_res);
	// debug statements here
}
	// void CVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ_free(struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ _res);
/* @internal */
export function CVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ_free(_res);
	// debug statements here
}
	// void CVec_BalanceZ_free(struct LDKCVec_BalanceZ _res);
/* @internal */
export function CVec_BalanceZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_BalanceZ_free(_res);
	// debug statements here
}
	// uint64_t C2Tuple_BlockHashChannelMonitorZ_clone_ptr(LDKC2Tuple_BlockHashChannelMonitorZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_BlockHashChannelMonitorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_BlockHashChannelMonitorZ C2Tuple_BlockHashChannelMonitorZ_clone(const struct LDKC2Tuple_BlockHashChannelMonitorZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_BlockHashChannelMonitorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_BlockHashChannelMonitorZ C2Tuple_BlockHashChannelMonitorZ_new(struct LDKThirtyTwoBytes a, struct LDKChannelMonitor b);
/* @internal */
export function C2Tuple_BlockHashChannelMonitorZ_new(a: number, b: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_BlockHashChannelMonitorZ_free(struct LDKC2Tuple_BlockHashChannelMonitorZ _res);
/* @internal */
export function C2Tuple_BlockHashChannelMonitorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok(struct LDKC2Tuple_BlockHashChannelMonitorZ o);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok(const struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free(struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ _res);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone_ptr(LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone(const struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// uint64_t C2Tuple_PublicKeyTypeZ_clone_ptr(LDKC2Tuple_PublicKeyTypeZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_PublicKeyTypeZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PublicKeyTypeZ C2Tuple_PublicKeyTypeZ_clone(const struct LDKC2Tuple_PublicKeyTypeZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_PublicKeyTypeZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PublicKeyTypeZ C2Tuple_PublicKeyTypeZ_new(struct LDKPublicKey a, struct LDKType b);
/* @internal */
export function C2Tuple_PublicKeyTypeZ_new(a: number, b: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_PublicKeyTypeZ_free(struct LDKC2Tuple_PublicKeyTypeZ _res);
/* @internal */
export function C2Tuple_PublicKeyTypeZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_free(_res);
	// debug statements here
}
	// void CVec_C2Tuple_PublicKeyTypeZZ_free(struct LDKCVec_C2Tuple_PublicKeyTypeZZ _res);
/* @internal */
export function CVec_C2Tuple_PublicKeyTypeZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C2Tuple_PublicKeyTypeZZ_free(_res);
	// debug statements here
}
	// struct LDKCOption_CustomOnionMessageContentsZ COption_CustomOnionMessageContentsZ_some(struct LDKCustomOnionMessageContents o);
/* @internal */
export function COption_CustomOnionMessageContentsZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CustomOnionMessageContentsZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_CustomOnionMessageContentsZ COption_CustomOnionMessageContentsZ_none(void);
/* @internal */
export function COption_CustomOnionMessageContentsZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CustomOnionMessageContentsZ_none();
	return nativeResponseValue;
}
	// void COption_CustomOnionMessageContentsZ_free(struct LDKCOption_CustomOnionMessageContentsZ _res);
/* @internal */
export function COption_CustomOnionMessageContentsZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CustomOnionMessageContentsZ_free(_res);
	// debug statements here
}
	// uint64_t COption_CustomOnionMessageContentsZ_clone_ptr(LDKCOption_CustomOnionMessageContentsZ *NONNULL_PTR arg);
/* @internal */
export function COption_CustomOnionMessageContentsZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CustomOnionMessageContentsZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_CustomOnionMessageContentsZ COption_CustomOnionMessageContentsZ_clone(const struct LDKCOption_CustomOnionMessageContentsZ *NONNULL_PTR orig);
/* @internal */
export function COption_CustomOnionMessageContentsZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CustomOnionMessageContentsZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_ok(struct LDKCOption_CustomOnionMessageContentsZ o);
/* @internal */
export function CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_is_ok(const struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_free(struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ _res);
/* @internal */
export function CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_clone_ptr(LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_clone(const struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_NetAddressZ COption_NetAddressZ_some(struct LDKNetAddress o);
/* @internal */
export function COption_NetAddressZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetAddressZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_NetAddressZ COption_NetAddressZ_none(void);
/* @internal */
export function COption_NetAddressZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetAddressZ_none();
	return nativeResponseValue;
}
	// void COption_NetAddressZ_free(struct LDKCOption_NetAddressZ _res);
/* @internal */
export function COption_NetAddressZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetAddressZ_free(_res);
	// debug statements here
}
	// uint64_t COption_NetAddressZ_clone_ptr(LDKCOption_NetAddressZ *NONNULL_PTR arg);
/* @internal */
export function COption_NetAddressZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetAddressZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_NetAddressZ COption_NetAddressZ_clone(const struct LDKCOption_NetAddressZ *NONNULL_PTR orig);
/* @internal */
export function COption_NetAddressZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetAddressZ_clone(orig);
	return nativeResponseValue;
}
	// uint64_t C2Tuple_PublicKeyCOption_NetAddressZZ_clone_ptr(LDKC2Tuple_PublicKeyCOption_NetAddressZZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_PublicKeyCOption_NetAddressZZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyCOption_NetAddressZZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PublicKeyCOption_NetAddressZZ C2Tuple_PublicKeyCOption_NetAddressZZ_clone(const struct LDKC2Tuple_PublicKeyCOption_NetAddressZZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_PublicKeyCOption_NetAddressZZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyCOption_NetAddressZZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PublicKeyCOption_NetAddressZZ C2Tuple_PublicKeyCOption_NetAddressZZ_new(struct LDKPublicKey a, struct LDKCOption_NetAddressZ b);
/* @internal */
export function C2Tuple_PublicKeyCOption_NetAddressZZ_new(a: number, b: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyCOption_NetAddressZZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_PublicKeyCOption_NetAddressZZ_free(struct LDKC2Tuple_PublicKeyCOption_NetAddressZZ _res);
/* @internal */
export function C2Tuple_PublicKeyCOption_NetAddressZZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyCOption_NetAddressZZ_free(_res);
	// debug statements here
}
	// void CVec_C2Tuple_PublicKeyCOption_NetAddressZZZ_free(struct LDKCVec_C2Tuple_PublicKeyCOption_NetAddressZZZ _res);
/* @internal */
export function CVec_C2Tuple_PublicKeyCOption_NetAddressZZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C2Tuple_PublicKeyCOption_NetAddressZZZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_ok(struct LDKCVec_u8Z o);
/* @internal */
export function CResult_CVec_u8ZPeerHandleErrorZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_err(struct LDKPeerHandleError e);
/* @internal */
export function CResult_CVec_u8ZPeerHandleErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_CVec_u8ZPeerHandleErrorZ_is_ok(const struct LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_CVec_u8ZPeerHandleErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CVec_u8ZPeerHandleErrorZ_free(struct LDKCResult_CVec_u8ZPeerHandleErrorZ _res);
/* @internal */
export function CResult_CVec_u8ZPeerHandleErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_CVec_u8ZPeerHandleErrorZ_clone_ptr(LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CVec_u8ZPeerHandleErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_clone(const struct LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CVec_u8ZPeerHandleErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_ok(void);
/* @internal */
export function CResult_NonePeerHandleErrorZ_ok(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_ok();
	return nativeResponseValue;
}
	// struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_err(struct LDKPeerHandleError e);
/* @internal */
export function CResult_NonePeerHandleErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NonePeerHandleErrorZ_is_ok(const struct LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NonePeerHandleErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NonePeerHandleErrorZ_free(struct LDKCResult_NonePeerHandleErrorZ _res);
/* @internal */
export function CResult_NonePeerHandleErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_NonePeerHandleErrorZ_clone_ptr(LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NonePeerHandleErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_clone(const struct LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NonePeerHandleErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_ok(bool o);
/* @internal */
export function CResult_boolPeerHandleErrorZ_ok(o: boolean): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_err(struct LDKPeerHandleError e);
/* @internal */
export function CResult_boolPeerHandleErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_boolPeerHandleErrorZ_is_ok(const struct LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_boolPeerHandleErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_boolPeerHandleErrorZ_free(struct LDKCResult_boolPeerHandleErrorZ _res);
/* @internal */
export function CResult_boolPeerHandleErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_boolPeerHandleErrorZ_clone_ptr(LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_boolPeerHandleErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_clone(const struct LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_boolPeerHandleErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TxOutUtxoLookupErrorZ CResult_TxOutUtxoLookupErrorZ_ok(struct LDKTxOut o);
/* @internal */
export function CResult_TxOutUtxoLookupErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxOutUtxoLookupErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TxOutUtxoLookupErrorZ CResult_TxOutUtxoLookupErrorZ_err(enum LDKUtxoLookupError e);
/* @internal */
export function CResult_TxOutUtxoLookupErrorZ_err(e: UtxoLookupError): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxOutUtxoLookupErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_TxOutUtxoLookupErrorZ_is_ok(const struct LDKCResult_TxOutUtxoLookupErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_TxOutUtxoLookupErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxOutUtxoLookupErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TxOutUtxoLookupErrorZ_free(struct LDKCResult_TxOutUtxoLookupErrorZ _res);
/* @internal */
export function CResult_TxOutUtxoLookupErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxOutUtxoLookupErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_TxOutUtxoLookupErrorZ_clone_ptr(LDKCResult_TxOutUtxoLookupErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TxOutUtxoLookupErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxOutUtxoLookupErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TxOutUtxoLookupErrorZ CResult_TxOutUtxoLookupErrorZ_clone(const struct LDKCResult_TxOutUtxoLookupErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TxOutUtxoLookupErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxOutUtxoLookupErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_OnionMessagePathNoneZ CResult_OnionMessagePathNoneZ_ok(struct LDKOnionMessagePath o);
/* @internal */
export function CResult_OnionMessagePathNoneZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OnionMessagePathNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_OnionMessagePathNoneZ CResult_OnionMessagePathNoneZ_err(void);
/* @internal */
export function CResult_OnionMessagePathNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OnionMessagePathNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_OnionMessagePathNoneZ_is_ok(const struct LDKCResult_OnionMessagePathNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_OnionMessagePathNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OnionMessagePathNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_OnionMessagePathNoneZ_free(struct LDKCResult_OnionMessagePathNoneZ _res);
/* @internal */
export function CResult_OnionMessagePathNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OnionMessagePathNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_OnionMessagePathNoneZ_clone_ptr(LDKCResult_OnionMessagePathNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_OnionMessagePathNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OnionMessagePathNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_OnionMessagePathNoneZ CResult_OnionMessagePathNoneZ_clone(const struct LDKCResult_OnionMessagePathNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_OnionMessagePathNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OnionMessagePathNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneSendErrorZ CResult_NoneSendErrorZ_ok(void);
/* @internal */
export function CResult_NoneSendErrorZ_ok(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneSendErrorZ_ok();
	return nativeResponseValue;
}
	// struct LDKCResult_NoneSendErrorZ CResult_NoneSendErrorZ_err(struct LDKSendError e);
/* @internal */
export function CResult_NoneSendErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneSendErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NoneSendErrorZ_is_ok(const struct LDKCResult_NoneSendErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NoneSendErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneSendErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NoneSendErrorZ_free(struct LDKCResult_NoneSendErrorZ _res);
/* @internal */
export function CResult_NoneSendErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneSendErrorZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_BlindedPathNoneZ CResult_BlindedPathNoneZ_ok(struct LDKBlindedPath o);
/* @internal */
export function CResult_BlindedPathNoneZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPathNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedPathNoneZ CResult_BlindedPathNoneZ_err(void);
/* @internal */
export function CResult_BlindedPathNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPathNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_BlindedPathNoneZ_is_ok(const struct LDKCResult_BlindedPathNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_BlindedPathNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPathNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_BlindedPathNoneZ_free(struct LDKCResult_BlindedPathNoneZ _res);
/* @internal */
export function CResult_BlindedPathNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPathNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_BlindedPathNoneZ_clone_ptr(LDKCResult_BlindedPathNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_BlindedPathNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPathNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedPathNoneZ CResult_BlindedPathNoneZ_clone(const struct LDKCResult_BlindedPathNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_BlindedPathNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPathNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedPathDecodeErrorZ CResult_BlindedPathDecodeErrorZ_ok(struct LDKBlindedPath o);
/* @internal */
export function CResult_BlindedPathDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPathDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedPathDecodeErrorZ CResult_BlindedPathDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_BlindedPathDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPathDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_BlindedPathDecodeErrorZ_is_ok(const struct LDKCResult_BlindedPathDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_BlindedPathDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPathDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_BlindedPathDecodeErrorZ_free(struct LDKCResult_BlindedPathDecodeErrorZ _res);
/* @internal */
export function CResult_BlindedPathDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPathDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_BlindedPathDecodeErrorZ_clone_ptr(LDKCResult_BlindedPathDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_BlindedPathDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPathDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedPathDecodeErrorZ CResult_BlindedPathDecodeErrorZ_clone(const struct LDKCResult_BlindedPathDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_BlindedPathDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedPathDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedHopDecodeErrorZ CResult_BlindedHopDecodeErrorZ_ok(struct LDKBlindedHop o);
/* @internal */
export function CResult_BlindedHopDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedHopDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedHopDecodeErrorZ CResult_BlindedHopDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_BlindedHopDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedHopDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_BlindedHopDecodeErrorZ_is_ok(const struct LDKCResult_BlindedHopDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_BlindedHopDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedHopDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_BlindedHopDecodeErrorZ_free(struct LDKCResult_BlindedHopDecodeErrorZ _res);
/* @internal */
export function CResult_BlindedHopDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedHopDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_BlindedHopDecodeErrorZ_clone_ptr(LDKCResult_BlindedHopDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_BlindedHopDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedHopDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedHopDecodeErrorZ CResult_BlindedHopDecodeErrorZ_clone(const struct LDKCResult_BlindedHopDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_BlindedHopDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BlindedHopDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_u32GraphSyncErrorZ CResult_u32GraphSyncErrorZ_ok(uint32_t o);
/* @internal */
export function CResult_u32GraphSyncErrorZ_ok(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_u32GraphSyncErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_u32GraphSyncErrorZ CResult_u32GraphSyncErrorZ_err(struct LDKGraphSyncError e);
/* @internal */
export function CResult_u32GraphSyncErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_u32GraphSyncErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_u32GraphSyncErrorZ_is_ok(const struct LDKCResult_u32GraphSyncErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_u32GraphSyncErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_u32GraphSyncErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_u32GraphSyncErrorZ_free(struct LDKCResult_u32GraphSyncErrorZ _res);
/* @internal */
export function CResult_u32GraphSyncErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_u32GraphSyncErrorZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_NoneErrorZ CResult_NoneErrorZ_ok(void);
/* @internal */
export function CResult_NoneErrorZ_ok(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneErrorZ_ok();
	return nativeResponseValue;
}
	// struct LDKCResult_NoneErrorZ CResult_NoneErrorZ_err(enum LDKIOError e);
/* @internal */
export function CResult_NoneErrorZ_err(e: IOError): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NoneErrorZ_is_ok(const struct LDKCResult_NoneErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NoneErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NoneErrorZ_free(struct LDKCResult_NoneErrorZ _res);
/* @internal */
export function CResult_NoneErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_NoneErrorZ_clone_ptr(LDKCResult_NoneErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NoneErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneErrorZ CResult_NoneErrorZ_clone(const struct LDKCResult_NoneErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NoneErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_ScriptZ COption_ScriptZ_some(struct LDKCVec_u8Z o);
/* @internal */
export function COption_ScriptZ_some(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ScriptZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_ScriptZ COption_ScriptZ_none(void);
/* @internal */
export function COption_ScriptZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ScriptZ_none();
	return nativeResponseValue;
}
	// void COption_ScriptZ_free(struct LDKCOption_ScriptZ _res);
/* @internal */
export function COption_ScriptZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ScriptZ_free(_res);
	// debug statements here
}
	// uint64_t COption_ScriptZ_clone_ptr(LDKCOption_ScriptZ *NONNULL_PTR arg);
/* @internal */
export function COption_ScriptZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ScriptZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_ScriptZ COption_ScriptZ_clone(const struct LDKCOption_ScriptZ *NONNULL_PTR orig);
/* @internal */
export function COption_ScriptZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ScriptZ_clone(orig);
	return nativeResponseValue;
}
	// enum LDKCOption_NoneZ COption_NoneZ_some(void);
/* @internal */
export function COption_NoneZ_some(): COption_NoneZ {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NoneZ_some();
	return nativeResponseValue;
}
	// enum LDKCOption_NoneZ COption_NoneZ_none(void);
/* @internal */
export function COption_NoneZ_none(): COption_NoneZ {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NoneZ_none();
	return nativeResponseValue;
}
	// void COption_NoneZ_free(enum LDKCOption_NoneZ _res);
/* @internal */
export function COption_NoneZ_free(_res: COption_NoneZ): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NoneZ_free(_res);
	// debug statements here
}
	// void CVec_WitnessZ_free(struct LDKCVec_WitnessZ _res);
/* @internal */
export function CVec_WitnessZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_WitnessZ_free(_res);
	// debug statements here
}
	// struct LDKCOption_i64Z COption_i64Z_some(int64_t o);
/* @internal */
export function COption_i64Z_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_i64Z_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_i64Z COption_i64Z_none(void);
/* @internal */
export function COption_i64Z_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_i64Z_none();
	return nativeResponseValue;
}
	// void COption_i64Z_free(struct LDKCOption_i64Z _res);
/* @internal */
export function COption_i64Z_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_i64Z_free(_res);
	// debug statements here
}
	// uint64_t COption_i64Z_clone_ptr(LDKCOption_i64Z *NONNULL_PTR arg);
/* @internal */
export function COption_i64Z_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_i64Z_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_i64Z COption_i64Z_clone(const struct LDKCOption_i64Z *NONNULL_PTR orig);
/* @internal */
export function COption_i64Z_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_i64Z_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_TxidZ COption_TxidZ_some(struct LDKThirtyTwoBytes o);
/* @internal */
export function COption_TxidZ_some(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TxidZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_TxidZ COption_TxidZ_none(void);
/* @internal */
export function COption_TxidZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TxidZ_none();
	return nativeResponseValue;
}
	// void COption_TxidZ_free(struct LDKCOption_TxidZ _res);
/* @internal */
export function COption_TxidZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TxidZ_free(_res);
	// debug statements here
}
	// uint64_t COption_TxidZ_clone_ptr(LDKCOption_TxidZ *NONNULL_PTR arg);
/* @internal */
export function COption_TxidZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TxidZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_TxidZ COption_TxidZ_clone(const struct LDKCOption_TxidZ *NONNULL_PTR orig);
/* @internal */
export function COption_TxidZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TxidZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_ok(struct LDKNetAddress o);
/* @internal */
export function CResult_NetAddressDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_NetAddressDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NetAddressDecodeErrorZ_is_ok(const struct LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NetAddressDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NetAddressDecodeErrorZ_free(struct LDKCResult_NetAddressDecodeErrorZ _res);
/* @internal */
export function CResult_NetAddressDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_NetAddressDecodeErrorZ_clone_ptr(LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NetAddressDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_clone(const struct LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NetAddressDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_UpdateAddHTLCZ_free(struct LDKCVec_UpdateAddHTLCZ _res);
/* @internal */
export function CVec_UpdateAddHTLCZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_UpdateAddHTLCZ_free(_res);
	// debug statements here
}
	// void CVec_UpdateFulfillHTLCZ_free(struct LDKCVec_UpdateFulfillHTLCZ _res);
/* @internal */
export function CVec_UpdateFulfillHTLCZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_UpdateFulfillHTLCZ_free(_res);
	// debug statements here
}
	// void CVec_UpdateFailHTLCZ_free(struct LDKCVec_UpdateFailHTLCZ _res);
/* @internal */
export function CVec_UpdateFailHTLCZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_UpdateFailHTLCZ_free(_res);
	// debug statements here
}
	// void CVec_UpdateFailMalformedHTLCZ_free(struct LDKCVec_UpdateFailMalformedHTLCZ _res);
/* @internal */
export function CVec_UpdateFailMalformedHTLCZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_UpdateFailMalformedHTLCZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_ok(struct LDKAcceptChannel o);
/* @internal */
export function CResult_AcceptChannelDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_AcceptChannelDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_AcceptChannelDecodeErrorZ_is_ok(const struct LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_AcceptChannelDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_AcceptChannelDecodeErrorZ_free(struct LDKCResult_AcceptChannelDecodeErrorZ _res);
/* @internal */
export function CResult_AcceptChannelDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_AcceptChannelDecodeErrorZ_clone_ptr(LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_AcceptChannelDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_clone(const struct LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_AcceptChannelDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_AcceptChannelV2DecodeErrorZ CResult_AcceptChannelV2DecodeErrorZ_ok(struct LDKAcceptChannelV2 o);
/* @internal */
export function CResult_AcceptChannelV2DecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelV2DecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_AcceptChannelV2DecodeErrorZ CResult_AcceptChannelV2DecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_AcceptChannelV2DecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelV2DecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_AcceptChannelV2DecodeErrorZ_is_ok(const struct LDKCResult_AcceptChannelV2DecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_AcceptChannelV2DecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelV2DecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_AcceptChannelV2DecodeErrorZ_free(struct LDKCResult_AcceptChannelV2DecodeErrorZ _res);
/* @internal */
export function CResult_AcceptChannelV2DecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelV2DecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_AcceptChannelV2DecodeErrorZ_clone_ptr(LDKCResult_AcceptChannelV2DecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_AcceptChannelV2DecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelV2DecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_AcceptChannelV2DecodeErrorZ CResult_AcceptChannelV2DecodeErrorZ_clone(const struct LDKCResult_AcceptChannelV2DecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_AcceptChannelV2DecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelV2DecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TxAddInputDecodeErrorZ CResult_TxAddInputDecodeErrorZ_ok(struct LDKTxAddInput o);
/* @internal */
export function CResult_TxAddInputDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAddInputDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TxAddInputDecodeErrorZ CResult_TxAddInputDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_TxAddInputDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAddInputDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_TxAddInputDecodeErrorZ_is_ok(const struct LDKCResult_TxAddInputDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_TxAddInputDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAddInputDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TxAddInputDecodeErrorZ_free(struct LDKCResult_TxAddInputDecodeErrorZ _res);
/* @internal */
export function CResult_TxAddInputDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAddInputDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_TxAddInputDecodeErrorZ_clone_ptr(LDKCResult_TxAddInputDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TxAddInputDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAddInputDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TxAddInputDecodeErrorZ CResult_TxAddInputDecodeErrorZ_clone(const struct LDKCResult_TxAddInputDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TxAddInputDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAddInputDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TxAddOutputDecodeErrorZ CResult_TxAddOutputDecodeErrorZ_ok(struct LDKTxAddOutput o);
/* @internal */
export function CResult_TxAddOutputDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAddOutputDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TxAddOutputDecodeErrorZ CResult_TxAddOutputDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_TxAddOutputDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAddOutputDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_TxAddOutputDecodeErrorZ_is_ok(const struct LDKCResult_TxAddOutputDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_TxAddOutputDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAddOutputDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TxAddOutputDecodeErrorZ_free(struct LDKCResult_TxAddOutputDecodeErrorZ _res);
/* @internal */
export function CResult_TxAddOutputDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAddOutputDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_TxAddOutputDecodeErrorZ_clone_ptr(LDKCResult_TxAddOutputDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TxAddOutputDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAddOutputDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TxAddOutputDecodeErrorZ CResult_TxAddOutputDecodeErrorZ_clone(const struct LDKCResult_TxAddOutputDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TxAddOutputDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAddOutputDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TxRemoveInputDecodeErrorZ CResult_TxRemoveInputDecodeErrorZ_ok(struct LDKTxRemoveInput o);
/* @internal */
export function CResult_TxRemoveInputDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxRemoveInputDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TxRemoveInputDecodeErrorZ CResult_TxRemoveInputDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_TxRemoveInputDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxRemoveInputDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_TxRemoveInputDecodeErrorZ_is_ok(const struct LDKCResult_TxRemoveInputDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_TxRemoveInputDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxRemoveInputDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TxRemoveInputDecodeErrorZ_free(struct LDKCResult_TxRemoveInputDecodeErrorZ _res);
/* @internal */
export function CResult_TxRemoveInputDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxRemoveInputDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_TxRemoveInputDecodeErrorZ_clone_ptr(LDKCResult_TxRemoveInputDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TxRemoveInputDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxRemoveInputDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TxRemoveInputDecodeErrorZ CResult_TxRemoveInputDecodeErrorZ_clone(const struct LDKCResult_TxRemoveInputDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TxRemoveInputDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxRemoveInputDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TxRemoveOutputDecodeErrorZ CResult_TxRemoveOutputDecodeErrorZ_ok(struct LDKTxRemoveOutput o);
/* @internal */
export function CResult_TxRemoveOutputDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxRemoveOutputDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TxRemoveOutputDecodeErrorZ CResult_TxRemoveOutputDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_TxRemoveOutputDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxRemoveOutputDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_TxRemoveOutputDecodeErrorZ_is_ok(const struct LDKCResult_TxRemoveOutputDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_TxRemoveOutputDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxRemoveOutputDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TxRemoveOutputDecodeErrorZ_free(struct LDKCResult_TxRemoveOutputDecodeErrorZ _res);
/* @internal */
export function CResult_TxRemoveOutputDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxRemoveOutputDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_TxRemoveOutputDecodeErrorZ_clone_ptr(LDKCResult_TxRemoveOutputDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TxRemoveOutputDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxRemoveOutputDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TxRemoveOutputDecodeErrorZ CResult_TxRemoveOutputDecodeErrorZ_clone(const struct LDKCResult_TxRemoveOutputDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TxRemoveOutputDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxRemoveOutputDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TxCompleteDecodeErrorZ CResult_TxCompleteDecodeErrorZ_ok(struct LDKTxComplete o);
/* @internal */
export function CResult_TxCompleteDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCompleteDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TxCompleteDecodeErrorZ CResult_TxCompleteDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_TxCompleteDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCompleteDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_TxCompleteDecodeErrorZ_is_ok(const struct LDKCResult_TxCompleteDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_TxCompleteDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCompleteDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TxCompleteDecodeErrorZ_free(struct LDKCResult_TxCompleteDecodeErrorZ _res);
/* @internal */
export function CResult_TxCompleteDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCompleteDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_TxCompleteDecodeErrorZ_clone_ptr(LDKCResult_TxCompleteDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TxCompleteDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCompleteDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TxCompleteDecodeErrorZ CResult_TxCompleteDecodeErrorZ_clone(const struct LDKCResult_TxCompleteDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TxCompleteDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCompleteDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TxSignaturesDecodeErrorZ CResult_TxSignaturesDecodeErrorZ_ok(struct LDKTxSignatures o);
/* @internal */
export function CResult_TxSignaturesDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxSignaturesDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TxSignaturesDecodeErrorZ CResult_TxSignaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_TxSignaturesDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxSignaturesDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_TxSignaturesDecodeErrorZ_is_ok(const struct LDKCResult_TxSignaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_TxSignaturesDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxSignaturesDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TxSignaturesDecodeErrorZ_free(struct LDKCResult_TxSignaturesDecodeErrorZ _res);
/* @internal */
export function CResult_TxSignaturesDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxSignaturesDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_TxSignaturesDecodeErrorZ_clone_ptr(LDKCResult_TxSignaturesDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TxSignaturesDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxSignaturesDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TxSignaturesDecodeErrorZ CResult_TxSignaturesDecodeErrorZ_clone(const struct LDKCResult_TxSignaturesDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TxSignaturesDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxSignaturesDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TxInitRbfDecodeErrorZ CResult_TxInitRbfDecodeErrorZ_ok(struct LDKTxInitRbf o);
/* @internal */
export function CResult_TxInitRbfDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxInitRbfDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TxInitRbfDecodeErrorZ CResult_TxInitRbfDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_TxInitRbfDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxInitRbfDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_TxInitRbfDecodeErrorZ_is_ok(const struct LDKCResult_TxInitRbfDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_TxInitRbfDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxInitRbfDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TxInitRbfDecodeErrorZ_free(struct LDKCResult_TxInitRbfDecodeErrorZ _res);
/* @internal */
export function CResult_TxInitRbfDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxInitRbfDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_TxInitRbfDecodeErrorZ_clone_ptr(LDKCResult_TxInitRbfDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TxInitRbfDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxInitRbfDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TxInitRbfDecodeErrorZ CResult_TxInitRbfDecodeErrorZ_clone(const struct LDKCResult_TxInitRbfDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TxInitRbfDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxInitRbfDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TxAckRbfDecodeErrorZ CResult_TxAckRbfDecodeErrorZ_ok(struct LDKTxAckRbf o);
/* @internal */
export function CResult_TxAckRbfDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAckRbfDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TxAckRbfDecodeErrorZ CResult_TxAckRbfDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_TxAckRbfDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAckRbfDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_TxAckRbfDecodeErrorZ_is_ok(const struct LDKCResult_TxAckRbfDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_TxAckRbfDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAckRbfDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TxAckRbfDecodeErrorZ_free(struct LDKCResult_TxAckRbfDecodeErrorZ _res);
/* @internal */
export function CResult_TxAckRbfDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAckRbfDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_TxAckRbfDecodeErrorZ_clone_ptr(LDKCResult_TxAckRbfDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TxAckRbfDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAckRbfDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TxAckRbfDecodeErrorZ CResult_TxAckRbfDecodeErrorZ_clone(const struct LDKCResult_TxAckRbfDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TxAckRbfDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAckRbfDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TxAbortDecodeErrorZ CResult_TxAbortDecodeErrorZ_ok(struct LDKTxAbort o);
/* @internal */
export function CResult_TxAbortDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAbortDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TxAbortDecodeErrorZ CResult_TxAbortDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_TxAbortDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAbortDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_TxAbortDecodeErrorZ_is_ok(const struct LDKCResult_TxAbortDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_TxAbortDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAbortDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TxAbortDecodeErrorZ_free(struct LDKCResult_TxAbortDecodeErrorZ _res);
/* @internal */
export function CResult_TxAbortDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAbortDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_TxAbortDecodeErrorZ_clone_ptr(LDKCResult_TxAbortDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TxAbortDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAbortDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TxAbortDecodeErrorZ CResult_TxAbortDecodeErrorZ_clone(const struct LDKCResult_TxAbortDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TxAbortDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxAbortDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_ok(struct LDKAnnouncementSignatures o);
/* @internal */
export function CResult_AnnouncementSignaturesDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_AnnouncementSignaturesDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(const struct LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_AnnouncementSignaturesDecodeErrorZ_free(struct LDKCResult_AnnouncementSignaturesDecodeErrorZ _res);
/* @internal */
export function CResult_AnnouncementSignaturesDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_AnnouncementSignaturesDecodeErrorZ_clone_ptr(LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_AnnouncementSignaturesDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_clone(const struct LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_AnnouncementSignaturesDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_ok(struct LDKChannelReestablish o);
/* @internal */
export function CResult_ChannelReestablishDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelReestablishDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelReestablishDecodeErrorZ_is_ok(const struct LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelReestablishDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelReestablishDecodeErrorZ_free(struct LDKCResult_ChannelReestablishDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelReestablishDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ChannelReestablishDecodeErrorZ_clone_ptr(LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelReestablishDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_clone(const struct LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelReestablishDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_ok(struct LDKClosingSigned o);
/* @internal */
export function CResult_ClosingSignedDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ClosingSignedDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ClosingSignedDecodeErrorZ_is_ok(const struct LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ClosingSignedDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ClosingSignedDecodeErrorZ_free(struct LDKCResult_ClosingSignedDecodeErrorZ _res);
/* @internal */
export function CResult_ClosingSignedDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ClosingSignedDecodeErrorZ_clone_ptr(LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ClosingSignedDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_clone(const struct LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ClosingSignedDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(struct LDKClosingSignedFeeRange o);
/* @internal */
export function CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ClosingSignedFeeRangeDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(const struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ClosingSignedFeeRangeDecodeErrorZ_free(struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ _res);
/* @internal */
export function CResult_ClosingSignedFeeRangeDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ClosingSignedFeeRangeDecodeErrorZ_clone_ptr(LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ClosingSignedFeeRangeDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(const struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_ok(struct LDKCommitmentSigned o);
/* @internal */
export function CResult_CommitmentSignedDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_CommitmentSignedDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_CommitmentSignedDecodeErrorZ_is_ok(const struct LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_CommitmentSignedDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CommitmentSignedDecodeErrorZ_free(struct LDKCResult_CommitmentSignedDecodeErrorZ _res);
/* @internal */
export function CResult_CommitmentSignedDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_CommitmentSignedDecodeErrorZ_clone_ptr(LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CommitmentSignedDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_clone(const struct LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CommitmentSignedDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_ok(struct LDKFundingCreated o);
/* @internal */
export function CResult_FundingCreatedDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_FundingCreatedDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_FundingCreatedDecodeErrorZ_is_ok(const struct LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_FundingCreatedDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_FundingCreatedDecodeErrorZ_free(struct LDKCResult_FundingCreatedDecodeErrorZ _res);
/* @internal */
export function CResult_FundingCreatedDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_FundingCreatedDecodeErrorZ_clone_ptr(LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_FundingCreatedDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_clone(const struct LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_FundingCreatedDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_ok(struct LDKFundingSigned o);
/* @internal */
export function CResult_FundingSignedDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_FundingSignedDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_FundingSignedDecodeErrorZ_is_ok(const struct LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_FundingSignedDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_FundingSignedDecodeErrorZ_free(struct LDKCResult_FundingSignedDecodeErrorZ _res);
/* @internal */
export function CResult_FundingSignedDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_FundingSignedDecodeErrorZ_clone_ptr(LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_FundingSignedDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_clone(const struct LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_FundingSignedDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelReadyDecodeErrorZ CResult_ChannelReadyDecodeErrorZ_ok(struct LDKChannelReady o);
/* @internal */
export function CResult_ChannelReadyDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReadyDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelReadyDecodeErrorZ CResult_ChannelReadyDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelReadyDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReadyDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelReadyDecodeErrorZ_is_ok(const struct LDKCResult_ChannelReadyDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelReadyDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReadyDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelReadyDecodeErrorZ_free(struct LDKCResult_ChannelReadyDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelReadyDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReadyDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ChannelReadyDecodeErrorZ_clone_ptr(LDKCResult_ChannelReadyDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelReadyDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReadyDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelReadyDecodeErrorZ CResult_ChannelReadyDecodeErrorZ_clone(const struct LDKCResult_ChannelReadyDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelReadyDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReadyDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_ok(struct LDKInit o);
/* @internal */
export function CResult_InitDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_InitDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_InitDecodeErrorZ_is_ok(const struct LDKCResult_InitDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_InitDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_InitDecodeErrorZ_free(struct LDKCResult_InitDecodeErrorZ _res);
/* @internal */
export function CResult_InitDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_InitDecodeErrorZ_clone_ptr(LDKCResult_InitDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_InitDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_clone(const struct LDKCResult_InitDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_InitDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_ok(struct LDKOpenChannel o);
/* @internal */
export function CResult_OpenChannelDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_OpenChannelDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_OpenChannelDecodeErrorZ_is_ok(const struct LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_OpenChannelDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_OpenChannelDecodeErrorZ_free(struct LDKCResult_OpenChannelDecodeErrorZ _res);
/* @internal */
export function CResult_OpenChannelDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_OpenChannelDecodeErrorZ_clone_ptr(LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_OpenChannelDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_clone(const struct LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_OpenChannelDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_OpenChannelV2DecodeErrorZ CResult_OpenChannelV2DecodeErrorZ_ok(struct LDKOpenChannelV2 o);
/* @internal */
export function CResult_OpenChannelV2DecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelV2DecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_OpenChannelV2DecodeErrorZ CResult_OpenChannelV2DecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_OpenChannelV2DecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelV2DecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_OpenChannelV2DecodeErrorZ_is_ok(const struct LDKCResult_OpenChannelV2DecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_OpenChannelV2DecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelV2DecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_OpenChannelV2DecodeErrorZ_free(struct LDKCResult_OpenChannelV2DecodeErrorZ _res);
/* @internal */
export function CResult_OpenChannelV2DecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelV2DecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_OpenChannelV2DecodeErrorZ_clone_ptr(LDKCResult_OpenChannelV2DecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_OpenChannelV2DecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelV2DecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_OpenChannelV2DecodeErrorZ CResult_OpenChannelV2DecodeErrorZ_clone(const struct LDKCResult_OpenChannelV2DecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_OpenChannelV2DecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelV2DecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_ok(struct LDKRevokeAndACK o);
/* @internal */
export function CResult_RevokeAndACKDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_RevokeAndACKDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RevokeAndACKDecodeErrorZ_is_ok(const struct LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RevokeAndACKDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RevokeAndACKDecodeErrorZ_free(struct LDKCResult_RevokeAndACKDecodeErrorZ _res);
/* @internal */
export function CResult_RevokeAndACKDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_RevokeAndACKDecodeErrorZ_clone_ptr(LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RevokeAndACKDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_clone(const struct LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RevokeAndACKDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_ok(struct LDKShutdown o);
/* @internal */
export function CResult_ShutdownDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ShutdownDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ShutdownDecodeErrorZ_is_ok(const struct LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ShutdownDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ShutdownDecodeErrorZ_free(struct LDKCResult_ShutdownDecodeErrorZ _res);
/* @internal */
export function CResult_ShutdownDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ShutdownDecodeErrorZ_clone_ptr(LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ShutdownDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_clone(const struct LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ShutdownDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_ok(struct LDKUpdateFailHTLC o);
/* @internal */
export function CResult_UpdateFailHTLCDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_UpdateFailHTLCDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_UpdateFailHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_UpdateFailHTLCDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_UpdateFailHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFailHTLCDecodeErrorZ _res);
/* @internal */
export function CResult_UpdateFailHTLCDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_UpdateFailHTLCDecodeErrorZ_clone_ptr(LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_UpdateFailHTLCDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_UpdateFailHTLCDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(struct LDKUpdateFailMalformedHTLC o);
/* @internal */
export function CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ _res);
/* @internal */
export function CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone_ptr(LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_ok(struct LDKUpdateFee o);
/* @internal */
export function CResult_UpdateFeeDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_UpdateFeeDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_UpdateFeeDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_UpdateFeeDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_UpdateFeeDecodeErrorZ_free(struct LDKCResult_UpdateFeeDecodeErrorZ _res);
/* @internal */
export function CResult_UpdateFeeDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_UpdateFeeDecodeErrorZ_clone_ptr(LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_UpdateFeeDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_clone(const struct LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_UpdateFeeDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_ok(struct LDKUpdateFulfillHTLC o);
/* @internal */
export function CResult_UpdateFulfillHTLCDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_UpdateFulfillHTLCDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_UpdateFulfillHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ _res);
/* @internal */
export function CResult_UpdateFulfillHTLCDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_UpdateFulfillHTLCDecodeErrorZ_clone_ptr(LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_UpdateFulfillHTLCDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_UpdateFulfillHTLCDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_ok(struct LDKUpdateAddHTLC o);
/* @internal */
export function CResult_UpdateAddHTLCDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_UpdateAddHTLCDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_UpdateAddHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_UpdateAddHTLCDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_UpdateAddHTLCDecodeErrorZ_free(struct LDKCResult_UpdateAddHTLCDecodeErrorZ _res);
/* @internal */
export function CResult_UpdateAddHTLCDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_UpdateAddHTLCDecodeErrorZ_clone_ptr(LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_UpdateAddHTLCDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_UpdateAddHTLCDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_OnionMessageDecodeErrorZ CResult_OnionMessageDecodeErrorZ_ok(struct LDKOnionMessage o);
/* @internal */
export function CResult_OnionMessageDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OnionMessageDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_OnionMessageDecodeErrorZ CResult_OnionMessageDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_OnionMessageDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OnionMessageDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_OnionMessageDecodeErrorZ_is_ok(const struct LDKCResult_OnionMessageDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_OnionMessageDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OnionMessageDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_OnionMessageDecodeErrorZ_free(struct LDKCResult_OnionMessageDecodeErrorZ _res);
/* @internal */
export function CResult_OnionMessageDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OnionMessageDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_OnionMessageDecodeErrorZ_clone_ptr(LDKCResult_OnionMessageDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_OnionMessageDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OnionMessageDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_OnionMessageDecodeErrorZ CResult_OnionMessageDecodeErrorZ_clone(const struct LDKCResult_OnionMessageDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_OnionMessageDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OnionMessageDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_ok(struct LDKPing o);
/* @internal */
export function CResult_PingDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_PingDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PingDecodeErrorZ_is_ok(const struct LDKCResult_PingDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PingDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PingDecodeErrorZ_free(struct LDKCResult_PingDecodeErrorZ _res);
/* @internal */
export function CResult_PingDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_PingDecodeErrorZ_clone_ptr(LDKCResult_PingDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PingDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_clone(const struct LDKCResult_PingDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PingDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_ok(struct LDKPong o);
/* @internal */
export function CResult_PongDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_PongDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PongDecodeErrorZ_is_ok(const struct LDKCResult_PongDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PongDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PongDecodeErrorZ_free(struct LDKCResult_PongDecodeErrorZ _res);
/* @internal */
export function CResult_PongDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_PongDecodeErrorZ_clone_ptr(LDKCResult_PongDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PongDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_clone(const struct LDKCResult_PongDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PongDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(struct LDKUnsignedChannelAnnouncement o);
/* @internal */
export function CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ _res);
/* @internal */
export function CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone_ptr(LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(const struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_ok(struct LDKChannelAnnouncement o);
/* @internal */
export function CResult_ChannelAnnouncementDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelAnnouncementDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelAnnouncementDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelAnnouncementDecodeErrorZ_free(struct LDKCResult_ChannelAnnouncementDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelAnnouncementDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ChannelAnnouncementDecodeErrorZ_clone_ptr(LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelAnnouncementDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_clone(const struct LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelAnnouncementDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_ok(struct LDKUnsignedChannelUpdate o);
/* @internal */
export function CResult_UnsignedChannelUpdateDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_UnsignedChannelUpdateDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_UnsignedChannelUpdateDecodeErrorZ_free(struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ _res);
/* @internal */
export function CResult_UnsignedChannelUpdateDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_UnsignedChannelUpdateDecodeErrorZ_clone_ptr(LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_UnsignedChannelUpdateDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_clone(const struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_UnsignedChannelUpdateDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_ok(struct LDKChannelUpdate o);
/* @internal */
export function CResult_ChannelUpdateDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelUpdateDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelUpdateDecodeErrorZ_is_ok(const struct LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelUpdateDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelUpdateDecodeErrorZ_free(struct LDKCResult_ChannelUpdateDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelUpdateDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ChannelUpdateDecodeErrorZ_clone_ptr(LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelUpdateDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_clone(const struct LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelUpdateDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_ok(struct LDKErrorMessage o);
/* @internal */
export function CResult_ErrorMessageDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ErrorMessageDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ErrorMessageDecodeErrorZ_is_ok(const struct LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ErrorMessageDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ErrorMessageDecodeErrorZ_free(struct LDKCResult_ErrorMessageDecodeErrorZ _res);
/* @internal */
export function CResult_ErrorMessageDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ErrorMessageDecodeErrorZ_clone_ptr(LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ErrorMessageDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_clone(const struct LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ErrorMessageDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_WarningMessageDecodeErrorZ CResult_WarningMessageDecodeErrorZ_ok(struct LDKWarningMessage o);
/* @internal */
export function CResult_WarningMessageDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WarningMessageDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_WarningMessageDecodeErrorZ CResult_WarningMessageDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_WarningMessageDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WarningMessageDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_WarningMessageDecodeErrorZ_is_ok(const struct LDKCResult_WarningMessageDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_WarningMessageDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WarningMessageDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_WarningMessageDecodeErrorZ_free(struct LDKCResult_WarningMessageDecodeErrorZ _res);
/* @internal */
export function CResult_WarningMessageDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WarningMessageDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_WarningMessageDecodeErrorZ_clone_ptr(LDKCResult_WarningMessageDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_WarningMessageDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WarningMessageDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_WarningMessageDecodeErrorZ CResult_WarningMessageDecodeErrorZ_clone(const struct LDKCResult_WarningMessageDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_WarningMessageDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WarningMessageDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(struct LDKUnsignedNodeAnnouncement o);
/* @internal */
export function CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ _res);
/* @internal */
export function CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone_ptr(LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(const struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_ok(struct LDKNodeAnnouncement o);
/* @internal */
export function CResult_NodeAnnouncementDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_NodeAnnouncementDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NodeAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NodeAnnouncementDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NodeAnnouncementDecodeErrorZ_free(struct LDKCResult_NodeAnnouncementDecodeErrorZ _res);
/* @internal */
export function CResult_NodeAnnouncementDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_NodeAnnouncementDecodeErrorZ_clone_ptr(LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NodeAnnouncementDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_clone(const struct LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NodeAnnouncementDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_ok(struct LDKQueryShortChannelIds o);
/* @internal */
export function CResult_QueryShortChannelIdsDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_QueryShortChannelIdsDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(const struct LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_QueryShortChannelIdsDecodeErrorZ_free(struct LDKCResult_QueryShortChannelIdsDecodeErrorZ _res);
/* @internal */
export function CResult_QueryShortChannelIdsDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_QueryShortChannelIdsDecodeErrorZ_clone_ptr(LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_QueryShortChannelIdsDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_clone(const struct LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_QueryShortChannelIdsDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(struct LDKReplyShortChannelIdsEnd o);
/* @internal */
export function CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(const struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ _res);
/* @internal */
export function CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone_ptr(LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(const struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_ok(struct LDKQueryChannelRange o);
/* @internal */
export function CResult_QueryChannelRangeDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_QueryChannelRangeDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_QueryChannelRangeDecodeErrorZ_is_ok(const struct LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_QueryChannelRangeDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_QueryChannelRangeDecodeErrorZ_free(struct LDKCResult_QueryChannelRangeDecodeErrorZ _res);
/* @internal */
export function CResult_QueryChannelRangeDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_QueryChannelRangeDecodeErrorZ_clone_ptr(LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_QueryChannelRangeDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_clone(const struct LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_QueryChannelRangeDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_ok(struct LDKReplyChannelRange o);
/* @internal */
export function CResult_ReplyChannelRangeDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ReplyChannelRangeDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ReplyChannelRangeDecodeErrorZ_is_ok(const struct LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ReplyChannelRangeDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ReplyChannelRangeDecodeErrorZ_free(struct LDKCResult_ReplyChannelRangeDecodeErrorZ _res);
/* @internal */
export function CResult_ReplyChannelRangeDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_ReplyChannelRangeDecodeErrorZ_clone_ptr(LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ReplyChannelRangeDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_clone(const struct LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ReplyChannelRangeDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_ok(struct LDKGossipTimestampFilter o);
/* @internal */
export function CResult_GossipTimestampFilterDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_GossipTimestampFilterDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_GossipTimestampFilterDecodeErrorZ_is_ok(const struct LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_GossipTimestampFilterDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_GossipTimestampFilterDecodeErrorZ_free(struct LDKCResult_GossipTimestampFilterDecodeErrorZ _res);
/* @internal */
export function CResult_GossipTimestampFilterDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_GossipTimestampFilterDecodeErrorZ_clone_ptr(LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_GossipTimestampFilterDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_clone(const struct LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_GossipTimestampFilterDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_KeyPairZ COption_KeyPairZ_some(struct LDKSecretKey o);
/* @internal */
export function COption_KeyPairZ_some(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_KeyPairZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_KeyPairZ COption_KeyPairZ_none(void);
/* @internal */
export function COption_KeyPairZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_KeyPairZ_none();
	return nativeResponseValue;
}
	// void COption_KeyPairZ_free(struct LDKCOption_KeyPairZ _res);
/* @internal */
export function COption_KeyPairZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_KeyPairZ_free(_res);
	// debug statements here
}
	// uint64_t COption_KeyPairZ_clone_ptr(LDKCOption_KeyPairZ *NONNULL_PTR arg);
/* @internal */
export function COption_KeyPairZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_KeyPairZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_KeyPairZ COption_KeyPairZ_clone(const struct LDKCOption_KeyPairZ *NONNULL_PTR orig);
/* @internal */
export function COption_KeyPairZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_KeyPairZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_KeyPairZNoneZ CResult_COption_KeyPairZNoneZ_ok(struct LDKCOption_KeyPairZ o);
/* @internal */
export function CResult_COption_KeyPairZNoneZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_KeyPairZNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_KeyPairZNoneZ CResult_COption_KeyPairZNoneZ_err(void);
/* @internal */
export function CResult_COption_KeyPairZNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_KeyPairZNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_COption_KeyPairZNoneZ_is_ok(const struct LDKCResult_COption_KeyPairZNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_COption_KeyPairZNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_KeyPairZNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_COption_KeyPairZNoneZ_free(struct LDKCResult_COption_KeyPairZNoneZ _res);
/* @internal */
export function CResult_COption_KeyPairZNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_KeyPairZNoneZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_COption_KeyPairZNoneZ_clone_ptr(LDKCResult_COption_KeyPairZNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_COption_KeyPairZNoneZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_KeyPairZNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_KeyPairZNoneZ CResult_COption_KeyPairZNoneZ_clone(const struct LDKCResult_COption_KeyPairZNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_COption_KeyPairZNoneZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_KeyPairZNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceErrorDecodeErrorZ CResult_InvoiceErrorDecodeErrorZ_ok(struct LDKInvoiceError o);
/* @internal */
export function CResult_InvoiceErrorDecodeErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceErrorDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceErrorDecodeErrorZ CResult_InvoiceErrorDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_InvoiceErrorDecodeErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceErrorDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_InvoiceErrorDecodeErrorZ_is_ok(const struct LDKCResult_InvoiceErrorDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_InvoiceErrorDecodeErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceErrorDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_InvoiceErrorDecodeErrorZ_free(struct LDKCResult_InvoiceErrorDecodeErrorZ _res);
/* @internal */
export function CResult_InvoiceErrorDecodeErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceErrorDecodeErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_InvoiceErrorDecodeErrorZ_clone_ptr(LDKCResult_InvoiceErrorDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_InvoiceErrorDecodeErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceErrorDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceErrorDecodeErrorZ CResult_InvoiceErrorDecodeErrorZ_clone(const struct LDKCResult_InvoiceErrorDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_InvoiceErrorDecodeErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceErrorDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_FilterZ COption_FilterZ_some(struct LDKFilter o);
/* @internal */
export function COption_FilterZ_some(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_FilterZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_FilterZ COption_FilterZ_none(void);
/* @internal */
export function COption_FilterZ_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_FilterZ_none();
	return nativeResponseValue;
}
	// void COption_FilterZ_free(struct LDKCOption_FilterZ _res);
/* @internal */
export function COption_FilterZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_FilterZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_LockedChannelMonitorNoneZ CResult_LockedChannelMonitorNoneZ_ok(struct LDKLockedChannelMonitor o);
/* @internal */
export function CResult_LockedChannelMonitorNoneZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_LockedChannelMonitorNoneZ CResult_LockedChannelMonitorNoneZ_err(void);
/* @internal */
export function CResult_LockedChannelMonitorNoneZ_err(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_LockedChannelMonitorNoneZ_is_ok(const struct LDKCResult_LockedChannelMonitorNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_LockedChannelMonitorNoneZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_LockedChannelMonitorNoneZ_free(struct LDKCResult_LockedChannelMonitorNoneZ _res);
/* @internal */
export function CResult_LockedChannelMonitorNoneZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_free(_res);
	// debug statements here
}
	// void CVec_OutPointZ_free(struct LDKCVec_OutPointZ _res);
/* @internal */
export function CVec_OutPointZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_OutPointZ_free(_res);
	// debug statements here
}
	// void CVec_MonitorUpdateIdZ_free(struct LDKCVec_MonitorUpdateIdZ _res);
/* @internal */
export function CVec_MonitorUpdateIdZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_MonitorUpdateIdZ_free(_res);
	// debug statements here
}
	// uint64_t C2Tuple_OutPointCVec_MonitorUpdateIdZZ_clone_ptr(LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_OutPointCVec_MonitorUpdateIdZZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointCVec_MonitorUpdateIdZZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ C2Tuple_OutPointCVec_MonitorUpdateIdZZ_clone(const struct LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_OutPointCVec_MonitorUpdateIdZZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointCVec_MonitorUpdateIdZZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ C2Tuple_OutPointCVec_MonitorUpdateIdZZ_new(struct LDKOutPoint a, struct LDKCVec_MonitorUpdateIdZ b);
/* @internal */
export function C2Tuple_OutPointCVec_MonitorUpdateIdZZ_new(a: bigint, b: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointCVec_MonitorUpdateIdZZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_OutPointCVec_MonitorUpdateIdZZ_free(struct LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ _res);
/* @internal */
export function C2Tuple_OutPointCVec_MonitorUpdateIdZZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointCVec_MonitorUpdateIdZZ_free(_res);
	// debug statements here
}
	// void CVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ_free(struct LDKCVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ _res);
/* @internal */
export function CVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ_free(_res);
	// debug statements here
}
	// void CVec_PhantomRouteHintsZ_free(struct LDKCVec_PhantomRouteHintsZ _res);
/* @internal */
export function CVec_PhantomRouteHintsZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_PhantomRouteHintsZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ CResult_Bolt11InvoiceSignOrCreationErrorZ_ok(struct LDKBolt11Invoice o);
/* @internal */
export function CResult_Bolt11InvoiceSignOrCreationErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceSignOrCreationErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ CResult_Bolt11InvoiceSignOrCreationErrorZ_err(struct LDKSignOrCreationError e);
/* @internal */
export function CResult_Bolt11InvoiceSignOrCreationErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceSignOrCreationErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_Bolt11InvoiceSignOrCreationErrorZ_is_ok(const struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_Bolt11InvoiceSignOrCreationErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceSignOrCreationErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_Bolt11InvoiceSignOrCreationErrorZ_free(struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ _res);
/* @internal */
export function CResult_Bolt11InvoiceSignOrCreationErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceSignOrCreationErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_Bolt11InvoiceSignOrCreationErrorZ_clone_ptr(LDKCResult_Bolt11InvoiceSignOrCreationErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_Bolt11InvoiceSignOrCreationErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceSignOrCreationErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ CResult_Bolt11InvoiceSignOrCreationErrorZ_clone(const struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_Bolt11InvoiceSignOrCreationErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceSignOrCreationErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_SiPrefixBolt11ParseErrorZ CResult_SiPrefixBolt11ParseErrorZ_ok(enum LDKSiPrefix o);
/* @internal */
export function CResult_SiPrefixBolt11ParseErrorZ_ok(o: SiPrefix): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SiPrefixBolt11ParseErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_SiPrefixBolt11ParseErrorZ CResult_SiPrefixBolt11ParseErrorZ_err(struct LDKBolt11ParseError e);
/* @internal */
export function CResult_SiPrefixBolt11ParseErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SiPrefixBolt11ParseErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_SiPrefixBolt11ParseErrorZ_is_ok(const struct LDKCResult_SiPrefixBolt11ParseErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_SiPrefixBolt11ParseErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SiPrefixBolt11ParseErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_SiPrefixBolt11ParseErrorZ_free(struct LDKCResult_SiPrefixBolt11ParseErrorZ _res);
/* @internal */
export function CResult_SiPrefixBolt11ParseErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SiPrefixBolt11ParseErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_SiPrefixBolt11ParseErrorZ_clone_ptr(LDKCResult_SiPrefixBolt11ParseErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_SiPrefixBolt11ParseErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SiPrefixBolt11ParseErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_SiPrefixBolt11ParseErrorZ CResult_SiPrefixBolt11ParseErrorZ_clone(const struct LDKCResult_SiPrefixBolt11ParseErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_SiPrefixBolt11ParseErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SiPrefixBolt11ParseErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ CResult_Bolt11InvoiceParseOrSemanticErrorZ_ok(struct LDKBolt11Invoice o);
/* @internal */
export function CResult_Bolt11InvoiceParseOrSemanticErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceParseOrSemanticErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ CResult_Bolt11InvoiceParseOrSemanticErrorZ_err(struct LDKParseOrSemanticError e);
/* @internal */
export function CResult_Bolt11InvoiceParseOrSemanticErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceParseOrSemanticErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_Bolt11InvoiceParseOrSemanticErrorZ_is_ok(const struct LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_Bolt11InvoiceParseOrSemanticErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceParseOrSemanticErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_Bolt11InvoiceParseOrSemanticErrorZ_free(struct LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ _res);
/* @internal */
export function CResult_Bolt11InvoiceParseOrSemanticErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceParseOrSemanticErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_Bolt11InvoiceParseOrSemanticErrorZ_clone_ptr(LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_Bolt11InvoiceParseOrSemanticErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceParseOrSemanticErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ CResult_Bolt11InvoiceParseOrSemanticErrorZ_clone(const struct LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_Bolt11InvoiceParseOrSemanticErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceParseOrSemanticErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_ok(struct LDKSignedRawBolt11Invoice o);
/* @internal */
export function CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_err(struct LDKBolt11ParseError e);
/* @internal */
export function CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_err(e: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_is_ok(const struct LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_free(struct LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ _res);
/* @internal */
export function CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_clone_ptr(LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_clone(const struct LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_clone(orig);
	return nativeResponseValue;
}
	// uint64_t C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_clone_ptr(LDKC3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ *NONNULL_PTR arg);
/* @internal */
export function C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_clone(const struct LDKC3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ *NONNULL_PTR orig);
/* @internal */
export function C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_new(struct LDKRawBolt11Invoice a, struct LDKThirtyTwoBytes b, struct LDKBolt11InvoiceSignature c);
/* @internal */
export function C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_new(a: bigint, b: number, c: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_new(a, b, c);
	return nativeResponseValue;
}
	// void C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_free(struct LDKC3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ _res);
/* @internal */
export function C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_ok(struct LDKPayeePubKey o);
/* @internal */
export function CResult_PayeePubKeyErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PayeePubKeyErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_err(enum LDKSecp256k1Error e);
/* @internal */
export function CResult_PayeePubKeyErrorZ_err(e: Secp256k1Error): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PayeePubKeyErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PayeePubKeyErrorZ_is_ok(const struct LDKCResult_PayeePubKeyErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PayeePubKeyErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PayeePubKeyErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PayeePubKeyErrorZ_free(struct LDKCResult_PayeePubKeyErrorZ _res);
/* @internal */
export function CResult_PayeePubKeyErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PayeePubKeyErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_PayeePubKeyErrorZ_clone_ptr(LDKCResult_PayeePubKeyErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PayeePubKeyErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PayeePubKeyErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_clone(const struct LDKCResult_PayeePubKeyErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PayeePubKeyErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PayeePubKeyErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_PrivateRouteZ_free(struct LDKCVec_PrivateRouteZ _res);
/* @internal */
export function CVec_PrivateRouteZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_PrivateRouteZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_ok(struct LDKPositiveTimestamp o);
/* @internal */
export function CResult_PositiveTimestampCreationErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PositiveTimestampCreationErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_err(enum LDKCreationError e);
/* @internal */
export function CResult_PositiveTimestampCreationErrorZ_err(e: CreationError): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PositiveTimestampCreationErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PositiveTimestampCreationErrorZ_is_ok(const struct LDKCResult_PositiveTimestampCreationErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PositiveTimestampCreationErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PositiveTimestampCreationErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PositiveTimestampCreationErrorZ_free(struct LDKCResult_PositiveTimestampCreationErrorZ _res);
/* @internal */
export function CResult_PositiveTimestampCreationErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PositiveTimestampCreationErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_PositiveTimestampCreationErrorZ_clone_ptr(LDKCResult_PositiveTimestampCreationErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PositiveTimestampCreationErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PositiveTimestampCreationErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_clone(const struct LDKCResult_PositiveTimestampCreationErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PositiveTimestampCreationErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PositiveTimestampCreationErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneBolt11SemanticErrorZ CResult_NoneBolt11SemanticErrorZ_ok(void);
/* @internal */
export function CResult_NoneBolt11SemanticErrorZ_ok(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneBolt11SemanticErrorZ_ok();
	return nativeResponseValue;
}
	// struct LDKCResult_NoneBolt11SemanticErrorZ CResult_NoneBolt11SemanticErrorZ_err(enum LDKBolt11SemanticError e);
/* @internal */
export function CResult_NoneBolt11SemanticErrorZ_err(e: Bolt11SemanticError): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneBolt11SemanticErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NoneBolt11SemanticErrorZ_is_ok(const struct LDKCResult_NoneBolt11SemanticErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NoneBolt11SemanticErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneBolt11SemanticErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NoneBolt11SemanticErrorZ_free(struct LDKCResult_NoneBolt11SemanticErrorZ _res);
/* @internal */
export function CResult_NoneBolt11SemanticErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneBolt11SemanticErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_NoneBolt11SemanticErrorZ_clone_ptr(LDKCResult_NoneBolt11SemanticErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NoneBolt11SemanticErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneBolt11SemanticErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneBolt11SemanticErrorZ CResult_NoneBolt11SemanticErrorZ_clone(const struct LDKCResult_NoneBolt11SemanticErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NoneBolt11SemanticErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneBolt11SemanticErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ CResult_Bolt11InvoiceBolt11SemanticErrorZ_ok(struct LDKBolt11Invoice o);
/* @internal */
export function CResult_Bolt11InvoiceBolt11SemanticErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceBolt11SemanticErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ CResult_Bolt11InvoiceBolt11SemanticErrorZ_err(enum LDKBolt11SemanticError e);
/* @internal */
export function CResult_Bolt11InvoiceBolt11SemanticErrorZ_err(e: Bolt11SemanticError): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceBolt11SemanticErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_Bolt11InvoiceBolt11SemanticErrorZ_is_ok(const struct LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_Bolt11InvoiceBolt11SemanticErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceBolt11SemanticErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_Bolt11InvoiceBolt11SemanticErrorZ_free(struct LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ _res);
/* @internal */
export function CResult_Bolt11InvoiceBolt11SemanticErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceBolt11SemanticErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_Bolt11InvoiceBolt11SemanticErrorZ_clone_ptr(LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_Bolt11InvoiceBolt11SemanticErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceBolt11SemanticErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ CResult_Bolt11InvoiceBolt11SemanticErrorZ_clone(const struct LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_Bolt11InvoiceBolt11SemanticErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_Bolt11InvoiceBolt11SemanticErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_AddressZ_free(struct LDKCVec_AddressZ _res);
/* @internal */
export function CVec_AddressZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_AddressZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_ok(struct LDKDescription o);
/* @internal */
export function CResult_DescriptionCreationErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DescriptionCreationErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_err(enum LDKCreationError e);
/* @internal */
export function CResult_DescriptionCreationErrorZ_err(e: CreationError): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DescriptionCreationErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_DescriptionCreationErrorZ_is_ok(const struct LDKCResult_DescriptionCreationErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_DescriptionCreationErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DescriptionCreationErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_DescriptionCreationErrorZ_free(struct LDKCResult_DescriptionCreationErrorZ _res);
/* @internal */
export function CResult_DescriptionCreationErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DescriptionCreationErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_DescriptionCreationErrorZ_clone_ptr(LDKCResult_DescriptionCreationErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_DescriptionCreationErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DescriptionCreationErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_clone(const struct LDKCResult_DescriptionCreationErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_DescriptionCreationErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DescriptionCreationErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_ok(struct LDKPrivateRoute o);
/* @internal */
export function CResult_PrivateRouteCreationErrorZ_ok(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PrivateRouteCreationErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_err(enum LDKCreationError e);
/* @internal */
export function CResult_PrivateRouteCreationErrorZ_err(e: CreationError): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PrivateRouteCreationErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PrivateRouteCreationErrorZ_is_ok(const struct LDKCResult_PrivateRouteCreationErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PrivateRouteCreationErrorZ_is_ok(o: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PrivateRouteCreationErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PrivateRouteCreationErrorZ_free(struct LDKCResult_PrivateRouteCreationErrorZ _res);
/* @internal */
export function CResult_PrivateRouteCreationErrorZ_free(_res: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PrivateRouteCreationErrorZ_free(_res);
	// debug statements here
}
	// uint64_t CResult_PrivateRouteCreationErrorZ_clone_ptr(LDKCResult_PrivateRouteCreationErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PrivateRouteCreationErrorZ_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PrivateRouteCreationErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_clone(const struct LDKCResult_PrivateRouteCreationErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PrivateRouteCreationErrorZ_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PrivateRouteCreationErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void APIError_free(struct LDKAPIError this_ptr);
/* @internal */
export function APIError_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_free(this_ptr);
	// debug statements here
}
	// uint64_t APIError_clone_ptr(LDKAPIError *NONNULL_PTR arg);
/* @internal */
export function APIError_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKAPIError APIError_clone(const struct LDKAPIError *NONNULL_PTR orig);
/* @internal */
export function APIError_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_clone(orig);
	return nativeResponseValue;
}
	// struct LDKAPIError APIError_apimisuse_error(struct LDKStr err);
/* @internal */
export function APIError_apimisuse_error(err: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_apimisuse_error(err);
	return nativeResponseValue;
}
	// struct LDKAPIError APIError_fee_rate_too_high(struct LDKStr err, uint32_t feerate);
/* @internal */
export function APIError_fee_rate_too_high(err: number, feerate: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_fee_rate_too_high(err, feerate);
	return nativeResponseValue;
}
	// struct LDKAPIError APIError_invalid_route(struct LDKStr err);
/* @internal */
export function APIError_invalid_route(err: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_invalid_route(err);
	return nativeResponseValue;
}
	// struct LDKAPIError APIError_channel_unavailable(struct LDKStr err);
/* @internal */
export function APIError_channel_unavailable(err: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_channel_unavailable(err);
	return nativeResponseValue;
}
	// struct LDKAPIError APIError_monitor_update_in_progress(void);
/* @internal */
export function APIError_monitor_update_in_progress(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_monitor_update_in_progress();
	return nativeResponseValue;
}
	// struct LDKAPIError APIError_incompatible_shutdown_script(struct LDKShutdownScript script);
/* @internal */
export function APIError_incompatible_shutdown_script(script: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_incompatible_shutdown_script(script);
	return nativeResponseValue;
}
	// bool APIError_eq(const struct LDKAPIError *NONNULL_PTR a, const struct LDKAPIError *NONNULL_PTR b);
/* @internal */
export function APIError_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z APIError_write(const struct LDKAPIError *NONNULL_PTR obj);
/* @internal */
export function APIError_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_APIErrorZDecodeErrorZ APIError_read(struct LDKu8slice ser);
/* @internal */
export function APIError_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_read(ser);
	return nativeResponseValue;
}
	// void BigSize_free(struct LDKBigSize this_obj);
/* @internal */
export function BigSize_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BigSize_free(this_obj);
	// debug statements here
}
	// uint64_t BigSize_get_a(const struct LDKBigSize *NONNULL_PTR this_ptr);
/* @internal */
export function BigSize_get_a(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BigSize_get_a(this_ptr);
	return nativeResponseValue;
}
	// void BigSize_set_a(struct LDKBigSize *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function BigSize_set_a(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BigSize_set_a(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKBigSize BigSize_new(uint64_t a_arg);
/* @internal */
export function BigSize_new(a_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BigSize_new(a_arg);
	return nativeResponseValue;
}
	// uint64_t BigSize_clone_ptr(LDKBigSize *NONNULL_PTR arg);
/* @internal */
export function BigSize_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BigSize_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBigSize BigSize_clone(const struct LDKBigSize *NONNULL_PTR orig);
/* @internal */
export function BigSize_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BigSize_clone(orig);
	return nativeResponseValue;
}
	// uint64_t BigSize_hash(const struct LDKBigSize *NONNULL_PTR o);
/* @internal */
export function BigSize_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BigSize_hash(o);
	return nativeResponseValue;
}
	// bool BigSize_eq(const struct LDKBigSize *NONNULL_PTR a, const struct LDKBigSize *NONNULL_PTR b);
/* @internal */
export function BigSize_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BigSize_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z BigSize_write(const struct LDKBigSize *NONNULL_PTR obj);
/* @internal */
export function BigSize_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BigSize_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_BigSizeDecodeErrorZ BigSize_read(struct LDKu8slice ser);
/* @internal */
export function BigSize_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BigSize_read(ser);
	return nativeResponseValue;
}
	// void Hostname_free(struct LDKHostname this_obj);
/* @internal */
export function Hostname_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Hostname_free(this_obj);
	// debug statements here
}
	// uint64_t Hostname_clone_ptr(LDKHostname *NONNULL_PTR arg);
/* @internal */
export function Hostname_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Hostname_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKHostname Hostname_clone(const struct LDKHostname *NONNULL_PTR orig);
/* @internal */
export function Hostname_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Hostname_clone(orig);
	return nativeResponseValue;
}
	// bool Hostname_eq(const struct LDKHostname *NONNULL_PTR a, const struct LDKHostname *NONNULL_PTR b);
/* @internal */
export function Hostname_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Hostname_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES uint8_t Hostname_len(const struct LDKHostname *NONNULL_PTR this_arg);
/* @internal */
export function Hostname_len(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Hostname_len(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Hostname_write(const struct LDKHostname *NONNULL_PTR obj);
/* @internal */
export function Hostname_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Hostname_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_HostnameDecodeErrorZ Hostname_read(struct LDKu8slice ser);
/* @internal */
export function Hostname_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Hostname_read(ser);
	return nativeResponseValue;
}
	// void TransactionU16LenLimited_free(struct LDKTransactionU16LenLimited this_obj);
/* @internal */
export function TransactionU16LenLimited_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TransactionU16LenLimited_free(this_obj);
	// debug statements here
}
	// uint64_t TransactionU16LenLimited_clone_ptr(LDKTransactionU16LenLimited *NONNULL_PTR arg);
/* @internal */
export function TransactionU16LenLimited_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TransactionU16LenLimited_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKTransactionU16LenLimited TransactionU16LenLimited_clone(const struct LDKTransactionU16LenLimited *NONNULL_PTR orig);
/* @internal */
export function TransactionU16LenLimited_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TransactionU16LenLimited_clone(orig);
	return nativeResponseValue;
}
	// bool TransactionU16LenLimited_eq(const struct LDKTransactionU16LenLimited *NONNULL_PTR a, const struct LDKTransactionU16LenLimited *NONNULL_PTR b);
/* @internal */
export function TransactionU16LenLimited_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TransactionU16LenLimited_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_TransactionU16LenLimitedNoneZ TransactionU16LenLimited_new(struct LDKTransaction transaction);
/* @internal */
export function TransactionU16LenLimited_new(transaction: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TransactionU16LenLimited_new(transaction);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKTransaction TransactionU16LenLimited_into_transaction(struct LDKTransactionU16LenLimited this_arg);
/* @internal */
export function TransactionU16LenLimited_into_transaction(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TransactionU16LenLimited_into_transaction(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z TransactionU16LenLimited_write(const struct LDKTransactionU16LenLimited *NONNULL_PTR obj);
/* @internal */
export function TransactionU16LenLimited_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TransactionU16LenLimited_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_TransactionU16LenLimitedDecodeErrorZ TransactionU16LenLimited_read(struct LDKu8slice ser);
/* @internal */
export function TransactionU16LenLimited_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TransactionU16LenLimited_read(ser);
	return nativeResponseValue;
}
	// struct LDKCResult_StringErrorZ sign(struct LDKu8slice msg, const uint8_t (*sk)[32]);
/* @internal */
export function sign(msg: number, sk: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_sign(msg, sk);
	return nativeResponseValue;
}
	// struct LDKCResult_PublicKeyErrorZ recover_pk(struct LDKu8slice msg, struct LDKStr sig);
/* @internal */
export function recover_pk(msg: number, sig: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_recover_pk(msg, sig);
	return nativeResponseValue;
}
	// bool verify(struct LDKu8slice msg, struct LDKStr sig, struct LDKPublicKey pk);
/* @internal */
export function verify(msg: number, sig: number, pk: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_verify(msg, sig, pk);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z construct_invoice_preimage(struct LDKu8slice hrp_bytes, struct LDKCVec_U5Z data_without_signature);
/* @internal */
export function construct_invoice_preimage(hrp_bytes: number, data_without_signature: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_construct_invoice_preimage(hrp_bytes, data_without_signature);
	return nativeResponseValue;
}
	// void Persister_free(struct LDKPersister this_ptr);
/* @internal */
export function Persister_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Persister_free(this_ptr);
	// debug statements here
}
	// void UntrustedString_free(struct LDKUntrustedString this_obj);
/* @internal */
export function UntrustedString_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UntrustedString_free(this_obj);
	// debug statements here
}
	// struct LDKStr UntrustedString_get_a(const struct LDKUntrustedString *NONNULL_PTR this_ptr);
/* @internal */
export function UntrustedString_get_a(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UntrustedString_get_a(this_ptr);
	return nativeResponseValue;
}
	// void UntrustedString_set_a(struct LDKUntrustedString *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */
export function UntrustedString_set_a(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UntrustedString_set_a(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKUntrustedString UntrustedString_new(struct LDKStr a_arg);
/* @internal */
export function UntrustedString_new(a_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UntrustedString_new(a_arg);
	return nativeResponseValue;
}
	// uint64_t UntrustedString_clone_ptr(LDKUntrustedString *NONNULL_PTR arg);
/* @internal */
export function UntrustedString_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UntrustedString_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUntrustedString UntrustedString_clone(const struct LDKUntrustedString *NONNULL_PTR orig);
/* @internal */
export function UntrustedString_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UntrustedString_clone(orig);
	return nativeResponseValue;
}
	// bool UntrustedString_eq(const struct LDKUntrustedString *NONNULL_PTR a, const struct LDKUntrustedString *NONNULL_PTR b);
/* @internal */
export function UntrustedString_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UntrustedString_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UntrustedString_write(const struct LDKUntrustedString *NONNULL_PTR obj);
/* @internal */
export function UntrustedString_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UntrustedString_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_UntrustedStringDecodeErrorZ UntrustedString_read(struct LDKu8slice ser);
/* @internal */
export function UntrustedString_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UntrustedString_read(ser);
	return nativeResponseValue;
}
	// void PrintableString_free(struct LDKPrintableString this_obj);
/* @internal */
export function PrintableString_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrintableString_free(this_obj);
	// debug statements here
}
	// struct LDKStr PrintableString_get_a(const struct LDKPrintableString *NONNULL_PTR this_ptr);
/* @internal */
export function PrintableString_get_a(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrintableString_get_a(this_ptr);
	return nativeResponseValue;
}
	// void PrintableString_set_a(struct LDKPrintableString *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */
export function PrintableString_set_a(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrintableString_set_a(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKPrintableString PrintableString_new(struct LDKStr a_arg);
/* @internal */
export function PrintableString_new(a_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrintableString_new(a_arg);
	return nativeResponseValue;
}
	// void FutureCallback_free(struct LDKFutureCallback this_ptr);
/* @internal */
export function FutureCallback_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FutureCallback_free(this_ptr);
	// debug statements here
}
	// void Future_free(struct LDKFuture this_obj);
/* @internal */
export function Future_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Future_free(this_obj);
	// debug statements here
}
	// uint64_t Future_clone_ptr(LDKFuture *NONNULL_PTR arg);
/* @internal */
export function Future_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Future_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKFuture Future_clone(const struct LDKFuture *NONNULL_PTR orig);
/* @internal */
export function Future_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Future_clone(orig);
	return nativeResponseValue;
}
	// void Future_register_callback_fn(const struct LDKFuture *NONNULL_PTR this_arg, struct LDKFutureCallback callback);
/* @internal */
export function Future_register_callback_fn(this_arg: bigint, callback: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Future_register_callback_fn(this_arg, callback);
	// debug statements here
}
	// enum LDKLevel Level_clone(const enum LDKLevel *NONNULL_PTR orig);
/* @internal */
export function Level_clone(orig: bigint): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_clone(orig);
	return nativeResponseValue;
}
	// enum LDKLevel Level_gossip(void);
/* @internal */
export function Level_gossip(): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_gossip();
	return nativeResponseValue;
}
	// enum LDKLevel Level_trace(void);
/* @internal */
export function Level_trace(): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_trace();
	return nativeResponseValue;
}
	// enum LDKLevel Level_debug(void);
/* @internal */
export function Level_debug(): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_debug();
	return nativeResponseValue;
}
	// enum LDKLevel Level_info(void);
/* @internal */
export function Level_info(): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_info();
	return nativeResponseValue;
}
	// enum LDKLevel Level_warn(void);
/* @internal */
export function Level_warn(): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_warn();
	return nativeResponseValue;
}
	// enum LDKLevel Level_error(void);
/* @internal */
export function Level_error(): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_error();
	return nativeResponseValue;
}
	// bool Level_eq(const enum LDKLevel *NONNULL_PTR a, const enum LDKLevel *NONNULL_PTR b);
/* @internal */
export function Level_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_eq(a, b);
	return nativeResponseValue;
}
	// uint64_t Level_hash(const enum LDKLevel *NONNULL_PTR o);
/* @internal */
export function Level_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_hash(o);
	return nativeResponseValue;
}
	// MUST_USE_RES enum LDKLevel Level_max(void);
/* @internal */
export function Level_max(): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_max();
	return nativeResponseValue;
}
	// void Record_free(struct LDKRecord this_obj);
/* @internal */
export function Record_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_free(this_obj);
	// debug statements here
}
	// enum LDKLevel Record_get_level(const struct LDKRecord *NONNULL_PTR this_ptr);
/* @internal */
export function Record_get_level(this_ptr: bigint): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_get_level(this_ptr);
	return nativeResponseValue;
}
	// void Record_set_level(struct LDKRecord *NONNULL_PTR this_ptr, enum LDKLevel val);
/* @internal */
export function Record_set_level(this_ptr: bigint, val: Level): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_set_level(this_ptr, val);
	// debug statements here
}
	// struct LDKStr Record_get_args(const struct LDKRecord *NONNULL_PTR this_ptr);
/* @internal */
export function Record_get_args(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_get_args(this_ptr);
	return nativeResponseValue;
}
	// void Record_set_args(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */
export function Record_set_args(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_set_args(this_ptr, val);
	// debug statements here
}
	// struct LDKStr Record_get_module_path(const struct LDKRecord *NONNULL_PTR this_ptr);
/* @internal */
export function Record_get_module_path(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_get_module_path(this_ptr);
	return nativeResponseValue;
}
	// void Record_set_module_path(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */
export function Record_set_module_path(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_set_module_path(this_ptr, val);
	// debug statements here
}
	// struct LDKStr Record_get_file(const struct LDKRecord *NONNULL_PTR this_ptr);
/* @internal */
export function Record_get_file(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_get_file(this_ptr);
	return nativeResponseValue;
}
	// void Record_set_file(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */
export function Record_set_file(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_set_file(this_ptr, val);
	// debug statements here
}
	// uint32_t Record_get_line(const struct LDKRecord *NONNULL_PTR this_ptr);
/* @internal */
export function Record_get_line(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_get_line(this_ptr);
	return nativeResponseValue;
}
	// void Record_set_line(struct LDKRecord *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function Record_set_line(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_set_line(this_ptr, val);
	// debug statements here
}
	// uint64_t Record_clone_ptr(LDKRecord *NONNULL_PTR arg);
/* @internal */
export function Record_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRecord Record_clone(const struct LDKRecord *NONNULL_PTR orig);
/* @internal */
export function Record_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_clone(orig);
	return nativeResponseValue;
}
	// void Logger_free(struct LDKLogger this_ptr);
/* @internal */
export function Logger_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Logger_free(this_ptr);
	// debug statements here
}
	// void ChannelHandshakeConfig_free(struct LDKChannelHandshakeConfig this_obj);
/* @internal */
export function ChannelHandshakeConfig_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_free(this_obj);
	// debug statements here
}
	// uint32_t ChannelHandshakeConfig_get_minimum_depth(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeConfig_get_minimum_depth(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_get_minimum_depth(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeConfig_set_minimum_depth(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function ChannelHandshakeConfig_set_minimum_depth(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_set_minimum_depth(this_ptr, val);
	// debug statements here
}
	// uint16_t ChannelHandshakeConfig_get_our_to_self_delay(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeConfig_get_our_to_self_delay(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_get_our_to_self_delay(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeConfig_set_our_to_self_delay(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function ChannelHandshakeConfig_set_our_to_self_delay(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_set_our_to_self_delay(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelHandshakeConfig_get_our_htlc_minimum_msat(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeConfig_get_our_htlc_minimum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_get_our_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeConfig_set_our_htlc_minimum_msat(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelHandshakeConfig_set_our_htlc_minimum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_set_our_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// uint8_t ChannelHandshakeConfig_get_max_inbound_htlc_value_in_flight_percent_of_channel(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeConfig_get_max_inbound_htlc_value_in_flight_percent_of_channel(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_get_max_inbound_htlc_value_in_flight_percent_of_channel(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeConfig_set_max_inbound_htlc_value_in_flight_percent_of_channel(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint8_t val);
/* @internal */
export function ChannelHandshakeConfig_set_max_inbound_htlc_value_in_flight_percent_of_channel(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_set_max_inbound_htlc_value_in_flight_percent_of_channel(this_ptr, val);
	// debug statements here
}
	// bool ChannelHandshakeConfig_get_negotiate_scid_privacy(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeConfig_get_negotiate_scid_privacy(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_get_negotiate_scid_privacy(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeConfig_set_negotiate_scid_privacy(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelHandshakeConfig_set_negotiate_scid_privacy(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_set_negotiate_scid_privacy(this_ptr, val);
	// debug statements here
}
	// bool ChannelHandshakeConfig_get_announced_channel(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeConfig_get_announced_channel(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_get_announced_channel(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeConfig_set_announced_channel(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelHandshakeConfig_set_announced_channel(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_set_announced_channel(this_ptr, val);
	// debug statements here
}
	// bool ChannelHandshakeConfig_get_commit_upfront_shutdown_pubkey(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeConfig_get_commit_upfront_shutdown_pubkey(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_get_commit_upfront_shutdown_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeConfig_set_commit_upfront_shutdown_pubkey(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelHandshakeConfig_set_commit_upfront_shutdown_pubkey(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_set_commit_upfront_shutdown_pubkey(this_ptr, val);
	// debug statements here
}
	// uint32_t ChannelHandshakeConfig_get_their_channel_reserve_proportional_millionths(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeConfig_get_their_channel_reserve_proportional_millionths(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_get_their_channel_reserve_proportional_millionths(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeConfig_set_their_channel_reserve_proportional_millionths(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function ChannelHandshakeConfig_set_their_channel_reserve_proportional_millionths(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_set_their_channel_reserve_proportional_millionths(this_ptr, val);
	// debug statements here
}
	// bool ChannelHandshakeConfig_get_negotiate_anchors_zero_fee_htlc_tx(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeConfig_get_negotiate_anchors_zero_fee_htlc_tx(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_get_negotiate_anchors_zero_fee_htlc_tx(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeConfig_set_negotiate_anchors_zero_fee_htlc_tx(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelHandshakeConfig_set_negotiate_anchors_zero_fee_htlc_tx(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_set_negotiate_anchors_zero_fee_htlc_tx(this_ptr, val);
	// debug statements here
}
	// uint16_t ChannelHandshakeConfig_get_our_max_accepted_htlcs(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeConfig_get_our_max_accepted_htlcs(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_get_our_max_accepted_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeConfig_set_our_max_accepted_htlcs(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function ChannelHandshakeConfig_set_our_max_accepted_htlcs(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_set_our_max_accepted_htlcs(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelHandshakeConfig ChannelHandshakeConfig_new(uint32_t minimum_depth_arg, uint16_t our_to_self_delay_arg, uint64_t our_htlc_minimum_msat_arg, uint8_t max_inbound_htlc_value_in_flight_percent_of_channel_arg, bool negotiate_scid_privacy_arg, bool announced_channel_arg, bool commit_upfront_shutdown_pubkey_arg, uint32_t their_channel_reserve_proportional_millionths_arg, bool negotiate_anchors_zero_fee_htlc_tx_arg, uint16_t our_max_accepted_htlcs_arg);
/* @internal */
export function ChannelHandshakeConfig_new(minimum_depth_arg: number, our_to_self_delay_arg: number, our_htlc_minimum_msat_arg: bigint, max_inbound_htlc_value_in_flight_percent_of_channel_arg: number, negotiate_scid_privacy_arg: boolean, announced_channel_arg: boolean, commit_upfront_shutdown_pubkey_arg: boolean, their_channel_reserve_proportional_millionths_arg: number, negotiate_anchors_zero_fee_htlc_tx_arg: boolean, our_max_accepted_htlcs_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_new(minimum_depth_arg, our_to_self_delay_arg, our_htlc_minimum_msat_arg, max_inbound_htlc_value_in_flight_percent_of_channel_arg, negotiate_scid_privacy_arg, announced_channel_arg, commit_upfront_shutdown_pubkey_arg, their_channel_reserve_proportional_millionths_arg, negotiate_anchors_zero_fee_htlc_tx_arg, our_max_accepted_htlcs_arg);
	return nativeResponseValue;
}
	// uint64_t ChannelHandshakeConfig_clone_ptr(LDKChannelHandshakeConfig *NONNULL_PTR arg);
/* @internal */
export function ChannelHandshakeConfig_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelHandshakeConfig ChannelHandshakeConfig_clone(const struct LDKChannelHandshakeConfig *NONNULL_PTR orig);
/* @internal */
export function ChannelHandshakeConfig_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelHandshakeConfig ChannelHandshakeConfig_default(void);
/* @internal */
export function ChannelHandshakeConfig_default(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_default();
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_free(struct LDKChannelHandshakeLimits this_obj);
/* @internal */
export function ChannelHandshakeLimits_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_free(this_obj);
	// debug statements here
}
	// uint64_t ChannelHandshakeLimits_get_min_funding_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_min_funding_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_min_funding_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_min_funding_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelHandshakeLimits_set_min_funding_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_min_funding_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelHandshakeLimits_get_max_funding_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_max_funding_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_max_funding_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_max_funding_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelHandshakeLimits_set_max_funding_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_max_funding_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelHandshakeLimits_get_max_htlc_minimum_msat(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_max_htlc_minimum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_max_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_max_htlc_minimum_msat(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelHandshakeLimits_set_max_htlc_minimum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_max_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelHandshakeLimits_get_max_channel_reserve_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_max_channel_reserve_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_max_channel_reserve_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_max_channel_reserve_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelHandshakeLimits_set_max_channel_reserve_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_max_channel_reserve_satoshis(this_ptr, val);
	// debug statements here
}
	// uint16_t ChannelHandshakeLimits_get_min_max_accepted_htlcs(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_min_max_accepted_htlcs(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_min_max_accepted_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_min_max_accepted_htlcs(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function ChannelHandshakeLimits_set_min_max_accepted_htlcs(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_min_max_accepted_htlcs(this_ptr, val);
	// debug statements here
}
	// uint32_t ChannelHandshakeLimits_get_max_minimum_depth(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_max_minimum_depth(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_max_minimum_depth(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_max_minimum_depth(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function ChannelHandshakeLimits_set_max_minimum_depth(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_max_minimum_depth(this_ptr, val);
	// debug statements here
}
	// bool ChannelHandshakeLimits_get_trust_own_funding_0conf(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_trust_own_funding_0conf(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_trust_own_funding_0conf(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_trust_own_funding_0conf(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelHandshakeLimits_set_trust_own_funding_0conf(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_trust_own_funding_0conf(this_ptr, val);
	// debug statements here
}
	// bool ChannelHandshakeLimits_get_force_announced_channel_preference(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_force_announced_channel_preference(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_force_announced_channel_preference(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_force_announced_channel_preference(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelHandshakeLimits_set_force_announced_channel_preference(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_force_announced_channel_preference(this_ptr, val);
	// debug statements here
}
	// uint16_t ChannelHandshakeLimits_get_their_to_self_delay(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_their_to_self_delay(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_their_to_self_delay(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_their_to_self_delay(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function ChannelHandshakeLimits_set_their_to_self_delay(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_their_to_self_delay(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelHandshakeLimits ChannelHandshakeLimits_new(uint64_t min_funding_satoshis_arg, uint64_t max_funding_satoshis_arg, uint64_t max_htlc_minimum_msat_arg, uint64_t min_max_htlc_value_in_flight_msat_arg, uint64_t max_channel_reserve_satoshis_arg, uint16_t min_max_accepted_htlcs_arg, uint32_t max_minimum_depth_arg, bool trust_own_funding_0conf_arg, bool force_announced_channel_preference_arg, uint16_t their_to_self_delay_arg);
/* @internal */
export function ChannelHandshakeLimits_new(min_funding_satoshis_arg: bigint, max_funding_satoshis_arg: bigint, max_htlc_minimum_msat_arg: bigint, min_max_htlc_value_in_flight_msat_arg: bigint, max_channel_reserve_satoshis_arg: bigint, min_max_accepted_htlcs_arg: number, max_minimum_depth_arg: number, trust_own_funding_0conf_arg: boolean, force_announced_channel_preference_arg: boolean, their_to_self_delay_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_new(min_funding_satoshis_arg, max_funding_satoshis_arg, max_htlc_minimum_msat_arg, min_max_htlc_value_in_flight_msat_arg, max_channel_reserve_satoshis_arg, min_max_accepted_htlcs_arg, max_minimum_depth_arg, trust_own_funding_0conf_arg, force_announced_channel_preference_arg, their_to_self_delay_arg);
	return nativeResponseValue;
}
	// uint64_t ChannelHandshakeLimits_clone_ptr(LDKChannelHandshakeLimits *NONNULL_PTR arg);
/* @internal */
export function ChannelHandshakeLimits_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelHandshakeLimits ChannelHandshakeLimits_clone(const struct LDKChannelHandshakeLimits *NONNULL_PTR orig);
/* @internal */
export function ChannelHandshakeLimits_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelHandshakeLimits ChannelHandshakeLimits_default(void);
/* @internal */
export function ChannelHandshakeLimits_default(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_default();
	return nativeResponseValue;
}
	// void MaxDustHTLCExposure_free(struct LDKMaxDustHTLCExposure this_ptr);
/* @internal */
export function MaxDustHTLCExposure_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MaxDustHTLCExposure_free(this_ptr);
	// debug statements here
}
	// uint64_t MaxDustHTLCExposure_clone_ptr(LDKMaxDustHTLCExposure *NONNULL_PTR arg);
/* @internal */
export function MaxDustHTLCExposure_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MaxDustHTLCExposure_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKMaxDustHTLCExposure MaxDustHTLCExposure_clone(const struct LDKMaxDustHTLCExposure *NONNULL_PTR orig);
/* @internal */
export function MaxDustHTLCExposure_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MaxDustHTLCExposure_clone(orig);
	return nativeResponseValue;
}
	// struct LDKMaxDustHTLCExposure MaxDustHTLCExposure_fixed_limit_msat(uint64_t a);
/* @internal */
export function MaxDustHTLCExposure_fixed_limit_msat(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MaxDustHTLCExposure_fixed_limit_msat(a);
	return nativeResponseValue;
}
	// struct LDKMaxDustHTLCExposure MaxDustHTLCExposure_fee_rate_multiplier(uint64_t a);
/* @internal */
export function MaxDustHTLCExposure_fee_rate_multiplier(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MaxDustHTLCExposure_fee_rate_multiplier(a);
	return nativeResponseValue;
}
	// bool MaxDustHTLCExposure_eq(const struct LDKMaxDustHTLCExposure *NONNULL_PTR a, const struct LDKMaxDustHTLCExposure *NONNULL_PTR b);
/* @internal */
export function MaxDustHTLCExposure_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MaxDustHTLCExposure_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z MaxDustHTLCExposure_write(const struct LDKMaxDustHTLCExposure *NONNULL_PTR obj);
/* @internal */
export function MaxDustHTLCExposure_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MaxDustHTLCExposure_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_MaxDustHTLCExposureDecodeErrorZ MaxDustHTLCExposure_read(struct LDKu8slice ser);
/* @internal */
export function MaxDustHTLCExposure_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MaxDustHTLCExposure_read(ser);
	return nativeResponseValue;
}
	// void ChannelConfig_free(struct LDKChannelConfig this_obj);
/* @internal */
export function ChannelConfig_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_free(this_obj);
	// debug statements here
}
	// uint32_t ChannelConfig_get_forwarding_fee_proportional_millionths(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfig_get_forwarding_fee_proportional_millionths(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_get_forwarding_fee_proportional_millionths(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfig_set_forwarding_fee_proportional_millionths(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function ChannelConfig_set_forwarding_fee_proportional_millionths(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_set_forwarding_fee_proportional_millionths(this_ptr, val);
	// debug statements here
}
	// uint32_t ChannelConfig_get_forwarding_fee_base_msat(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfig_get_forwarding_fee_base_msat(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_get_forwarding_fee_base_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfig_set_forwarding_fee_base_msat(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function ChannelConfig_set_forwarding_fee_base_msat(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_set_forwarding_fee_base_msat(this_ptr, val);
	// debug statements here
}
	// uint16_t ChannelConfig_get_cltv_expiry_delta(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfig_get_cltv_expiry_delta(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_get_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfig_set_cltv_expiry_delta(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function ChannelConfig_set_cltv_expiry_delta(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_set_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// struct LDKMaxDustHTLCExposure ChannelConfig_get_max_dust_htlc_exposure(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfig_get_max_dust_htlc_exposure(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_get_max_dust_htlc_exposure(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfig_set_max_dust_htlc_exposure(struct LDKChannelConfig *NONNULL_PTR this_ptr, struct LDKMaxDustHTLCExposure val);
/* @internal */
export function ChannelConfig_set_max_dust_htlc_exposure(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_set_max_dust_htlc_exposure(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelConfig_get_force_close_avoidance_max_fee_satoshis(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfig_get_force_close_avoidance_max_fee_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_get_force_close_avoidance_max_fee_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfig_set_force_close_avoidance_max_fee_satoshis(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelConfig_set_force_close_avoidance_max_fee_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_set_force_close_avoidance_max_fee_satoshis(this_ptr, val);
	// debug statements here
}
	// bool ChannelConfig_get_accept_underpaying_htlcs(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfig_get_accept_underpaying_htlcs(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_get_accept_underpaying_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfig_set_accept_underpaying_htlcs(struct LDKChannelConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelConfig_set_accept_underpaying_htlcs(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_set_accept_underpaying_htlcs(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelConfig ChannelConfig_new(uint32_t forwarding_fee_proportional_millionths_arg, uint32_t forwarding_fee_base_msat_arg, uint16_t cltv_expiry_delta_arg, struct LDKMaxDustHTLCExposure max_dust_htlc_exposure_arg, uint64_t force_close_avoidance_max_fee_satoshis_arg, bool accept_underpaying_htlcs_arg);
/* @internal */
export function ChannelConfig_new(forwarding_fee_proportional_millionths_arg: number, forwarding_fee_base_msat_arg: number, cltv_expiry_delta_arg: number, max_dust_htlc_exposure_arg: bigint, force_close_avoidance_max_fee_satoshis_arg: bigint, accept_underpaying_htlcs_arg: boolean): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_new(forwarding_fee_proportional_millionths_arg, forwarding_fee_base_msat_arg, cltv_expiry_delta_arg, max_dust_htlc_exposure_arg, force_close_avoidance_max_fee_satoshis_arg, accept_underpaying_htlcs_arg);
	return nativeResponseValue;
}
	// uint64_t ChannelConfig_clone_ptr(LDKChannelConfig *NONNULL_PTR arg);
/* @internal */
export function ChannelConfig_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelConfig ChannelConfig_clone(const struct LDKChannelConfig *NONNULL_PTR orig);
/* @internal */
export function ChannelConfig_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_clone(orig);
	return nativeResponseValue;
}
	// bool ChannelConfig_eq(const struct LDKChannelConfig *NONNULL_PTR a, const struct LDKChannelConfig *NONNULL_PTR b);
/* @internal */
export function ChannelConfig_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_eq(a, b);
	return nativeResponseValue;
}
	// void ChannelConfig_apply(struct LDKChannelConfig *NONNULL_PTR this_arg, const struct LDKChannelConfigUpdate *NONNULL_PTR update);
/* @internal */
export function ChannelConfig_apply(this_arg: bigint, update: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_apply(this_arg, update);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelConfig ChannelConfig_default(void);
/* @internal */
export function ChannelConfig_default(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_default();
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelConfig_write(const struct LDKChannelConfig *NONNULL_PTR obj);
/* @internal */
export function ChannelConfig_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelConfigDecodeErrorZ ChannelConfig_read(struct LDKu8slice ser);
/* @internal */
export function ChannelConfig_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_read(ser);
	return nativeResponseValue;
}
	// void ChannelConfigUpdate_free(struct LDKChannelConfigUpdate this_obj);
/* @internal */
export function ChannelConfigUpdate_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfigUpdate_free(this_obj);
	// debug statements here
}
	// struct LDKCOption_u32Z ChannelConfigUpdate_get_forwarding_fee_proportional_millionths(const struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfigUpdate_get_forwarding_fee_proportional_millionths(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfigUpdate_get_forwarding_fee_proportional_millionths(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfigUpdate_set_forwarding_fee_proportional_millionths(struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);
/* @internal */
export function ChannelConfigUpdate_set_forwarding_fee_proportional_millionths(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfigUpdate_set_forwarding_fee_proportional_millionths(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u32Z ChannelConfigUpdate_get_forwarding_fee_base_msat(const struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfigUpdate_get_forwarding_fee_base_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfigUpdate_get_forwarding_fee_base_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfigUpdate_set_forwarding_fee_base_msat(struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);
/* @internal */
export function ChannelConfigUpdate_set_forwarding_fee_base_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfigUpdate_set_forwarding_fee_base_msat(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u16Z ChannelConfigUpdate_get_cltv_expiry_delta(const struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfigUpdate_get_cltv_expiry_delta(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfigUpdate_get_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfigUpdate_set_cltv_expiry_delta(struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr, struct LDKCOption_u16Z val);
/* @internal */
export function ChannelConfigUpdate_set_cltv_expiry_delta(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfigUpdate_set_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_MaxDustHTLCExposureZ ChannelConfigUpdate_get_max_dust_htlc_exposure_msat(const struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfigUpdate_get_max_dust_htlc_exposure_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfigUpdate_get_max_dust_htlc_exposure_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfigUpdate_set_max_dust_htlc_exposure_msat(struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr, struct LDKCOption_MaxDustHTLCExposureZ val);
/* @internal */
export function ChannelConfigUpdate_set_max_dust_htlc_exposure_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfigUpdate_set_max_dust_htlc_exposure_msat(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z ChannelConfigUpdate_get_force_close_avoidance_max_fee_satoshis(const struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfigUpdate_get_force_close_avoidance_max_fee_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfigUpdate_get_force_close_avoidance_max_fee_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfigUpdate_set_force_close_avoidance_max_fee_satoshis(struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function ChannelConfigUpdate_set_force_close_avoidance_max_fee_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfigUpdate_set_force_close_avoidance_max_fee_satoshis(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelConfigUpdate ChannelConfigUpdate_new(struct LDKCOption_u32Z forwarding_fee_proportional_millionths_arg, struct LDKCOption_u32Z forwarding_fee_base_msat_arg, struct LDKCOption_u16Z cltv_expiry_delta_arg, struct LDKCOption_MaxDustHTLCExposureZ max_dust_htlc_exposure_msat_arg, struct LDKCOption_u64Z force_close_avoidance_max_fee_satoshis_arg);
/* @internal */
export function ChannelConfigUpdate_new(forwarding_fee_proportional_millionths_arg: bigint, forwarding_fee_base_msat_arg: bigint, cltv_expiry_delta_arg: bigint, max_dust_htlc_exposure_msat_arg: bigint, force_close_avoidance_max_fee_satoshis_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfigUpdate_new(forwarding_fee_proportional_millionths_arg, forwarding_fee_base_msat_arg, cltv_expiry_delta_arg, max_dust_htlc_exposure_msat_arg, force_close_avoidance_max_fee_satoshis_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelConfigUpdate ChannelConfigUpdate_default(void);
/* @internal */
export function ChannelConfigUpdate_default(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfigUpdate_default();
	return nativeResponseValue;
}
	// void UserConfig_free(struct LDKUserConfig this_obj);
/* @internal */
export function UserConfig_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_free(this_obj);
	// debug statements here
}
	// struct LDKChannelHandshakeConfig UserConfig_get_channel_handshake_config(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */
export function UserConfig_get_channel_handshake_config(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_get_channel_handshake_config(this_ptr);
	return nativeResponseValue;
}
	// void UserConfig_set_channel_handshake_config(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelHandshakeConfig val);
/* @internal */
export function UserConfig_set_channel_handshake_config(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_set_channel_handshake_config(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelHandshakeLimits UserConfig_get_channel_handshake_limits(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */
export function UserConfig_get_channel_handshake_limits(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_get_channel_handshake_limits(this_ptr);
	return nativeResponseValue;
}
	// void UserConfig_set_channel_handshake_limits(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelHandshakeLimits val);
/* @internal */
export function UserConfig_set_channel_handshake_limits(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_set_channel_handshake_limits(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelConfig UserConfig_get_channel_config(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */
export function UserConfig_get_channel_config(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_get_channel_config(this_ptr);
	return nativeResponseValue;
}
	// void UserConfig_set_channel_config(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelConfig val);
/* @internal */
export function UserConfig_set_channel_config(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_set_channel_config(this_ptr, val);
	// debug statements here
}
	// bool UserConfig_get_accept_forwards_to_priv_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */
export function UserConfig_get_accept_forwards_to_priv_channels(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_get_accept_forwards_to_priv_channels(this_ptr);
	return nativeResponseValue;
}
	// void UserConfig_set_accept_forwards_to_priv_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function UserConfig_set_accept_forwards_to_priv_channels(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_set_accept_forwards_to_priv_channels(this_ptr, val);
	// debug statements here
}
	// bool UserConfig_get_accept_inbound_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */
export function UserConfig_get_accept_inbound_channels(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_get_accept_inbound_channels(this_ptr);
	return nativeResponseValue;
}
	// void UserConfig_set_accept_inbound_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function UserConfig_set_accept_inbound_channels(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_set_accept_inbound_channels(this_ptr, val);
	// debug statements here
}
	// bool UserConfig_get_manually_accept_inbound_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */
export function UserConfig_get_manually_accept_inbound_channels(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_get_manually_accept_inbound_channels(this_ptr);
	return nativeResponseValue;
}
	// void UserConfig_set_manually_accept_inbound_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function UserConfig_set_manually_accept_inbound_channels(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_set_manually_accept_inbound_channels(this_ptr, val);
	// debug statements here
}
	// bool UserConfig_get_accept_intercept_htlcs(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */
export function UserConfig_get_accept_intercept_htlcs(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_get_accept_intercept_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void UserConfig_set_accept_intercept_htlcs(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function UserConfig_set_accept_intercept_htlcs(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_set_accept_intercept_htlcs(this_ptr, val);
	// debug statements here
}
	// bool UserConfig_get_accept_mpp_keysend(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */
export function UserConfig_get_accept_mpp_keysend(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_get_accept_mpp_keysend(this_ptr);
	return nativeResponseValue;
}
	// void UserConfig_set_accept_mpp_keysend(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function UserConfig_set_accept_mpp_keysend(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_set_accept_mpp_keysend(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKUserConfig UserConfig_new(struct LDKChannelHandshakeConfig channel_handshake_config_arg, struct LDKChannelHandshakeLimits channel_handshake_limits_arg, struct LDKChannelConfig channel_config_arg, bool accept_forwards_to_priv_channels_arg, bool accept_inbound_channels_arg, bool manually_accept_inbound_channels_arg, bool accept_intercept_htlcs_arg, bool accept_mpp_keysend_arg);
/* @internal */
export function UserConfig_new(channel_handshake_config_arg: bigint, channel_handshake_limits_arg: bigint, channel_config_arg: bigint, accept_forwards_to_priv_channels_arg: boolean, accept_inbound_channels_arg: boolean, manually_accept_inbound_channels_arg: boolean, accept_intercept_htlcs_arg: boolean, accept_mpp_keysend_arg: boolean): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_new(channel_handshake_config_arg, channel_handshake_limits_arg, channel_config_arg, accept_forwards_to_priv_channels_arg, accept_inbound_channels_arg, manually_accept_inbound_channels_arg, accept_intercept_htlcs_arg, accept_mpp_keysend_arg);
	return nativeResponseValue;
}
	// uint64_t UserConfig_clone_ptr(LDKUserConfig *NONNULL_PTR arg);
/* @internal */
export function UserConfig_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUserConfig UserConfig_clone(const struct LDKUserConfig *NONNULL_PTR orig);
/* @internal */
export function UserConfig_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKUserConfig UserConfig_default(void);
/* @internal */
export function UserConfig_default(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_default();
	return nativeResponseValue;
}
	// void BestBlock_free(struct LDKBestBlock this_obj);
/* @internal */
export function BestBlock_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BestBlock_free(this_obj);
	// debug statements here
}
	// uint64_t BestBlock_clone_ptr(LDKBestBlock *NONNULL_PTR arg);
/* @internal */
export function BestBlock_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BestBlock_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBestBlock BestBlock_clone(const struct LDKBestBlock *NONNULL_PTR orig);
/* @internal */
export function BestBlock_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BestBlock_clone(orig);
	return nativeResponseValue;
}
	// bool BestBlock_eq(const struct LDKBestBlock *NONNULL_PTR a, const struct LDKBestBlock *NONNULL_PTR b);
/* @internal */
export function BestBlock_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BestBlock_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKBestBlock BestBlock_from_network(enum LDKNetwork network);
/* @internal */
export function BestBlock_from_network(network: Network): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BestBlock_from_network(network);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKBestBlock BestBlock_new(struct LDKThirtyTwoBytes block_hash, uint32_t height);
/* @internal */
export function BestBlock_new(block_hash: number, height: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BestBlock_new(block_hash, height);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes BestBlock_block_hash(const struct LDKBestBlock *NONNULL_PTR this_arg);
/* @internal */
export function BestBlock_block_hash(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BestBlock_block_hash(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint32_t BestBlock_height(const struct LDKBestBlock *NONNULL_PTR this_arg);
/* @internal */
export function BestBlock_height(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BestBlock_height(this_arg);
	return nativeResponseValue;
}
	// void Listen_free(struct LDKListen this_ptr);
/* @internal */
export function Listen_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Listen_free(this_ptr);
	// debug statements here
}
	// void Confirm_free(struct LDKConfirm this_ptr);
/* @internal */
export function Confirm_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Confirm_free(this_ptr);
	// debug statements here
}
	// enum LDKChannelMonitorUpdateStatus ChannelMonitorUpdateStatus_clone(const enum LDKChannelMonitorUpdateStatus *NONNULL_PTR orig);
/* @internal */
export function ChannelMonitorUpdateStatus_clone(orig: bigint): ChannelMonitorUpdateStatus {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdateStatus_clone(orig);
	return nativeResponseValue;
}
	// enum LDKChannelMonitorUpdateStatus ChannelMonitorUpdateStatus_completed(void);
/* @internal */
export function ChannelMonitorUpdateStatus_completed(): ChannelMonitorUpdateStatus {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdateStatus_completed();
	return nativeResponseValue;
}
	// enum LDKChannelMonitorUpdateStatus ChannelMonitorUpdateStatus_in_progress(void);
/* @internal */
export function ChannelMonitorUpdateStatus_in_progress(): ChannelMonitorUpdateStatus {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdateStatus_in_progress();
	return nativeResponseValue;
}
	// enum LDKChannelMonitorUpdateStatus ChannelMonitorUpdateStatus_permanent_failure(void);
/* @internal */
export function ChannelMonitorUpdateStatus_permanent_failure(): ChannelMonitorUpdateStatus {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdateStatus_permanent_failure();
	return nativeResponseValue;
}
	// bool ChannelMonitorUpdateStatus_eq(const enum LDKChannelMonitorUpdateStatus *NONNULL_PTR a, const enum LDKChannelMonitorUpdateStatus *NONNULL_PTR b);
/* @internal */
export function ChannelMonitorUpdateStatus_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdateStatus_eq(a, b);
	return nativeResponseValue;
}
	// void Watch_free(struct LDKWatch this_ptr);
/* @internal */
export function Watch_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Watch_free(this_ptr);
	// debug statements here
}
	// void Filter_free(struct LDKFilter this_ptr);
/* @internal */
export function Filter_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Filter_free(this_ptr);
	// debug statements here
}
	// void WatchedOutput_free(struct LDKWatchedOutput this_obj);
/* @internal */
export function WatchedOutput_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_free(this_obj);
	// debug statements here
}
	// struct LDKCOption_BlockHashZ WatchedOutput_get_block_hash(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);
/* @internal */
export function WatchedOutput_get_block_hash(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_get_block_hash(this_ptr);
	return nativeResponseValue;
}
	// void WatchedOutput_set_block_hash(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKCOption_BlockHashZ val);
/* @internal */
export function WatchedOutput_set_block_hash(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_set_block_hash(this_ptr, val);
	// debug statements here
}
	// struct LDKOutPoint WatchedOutput_get_outpoint(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);
/* @internal */
export function WatchedOutput_get_outpoint(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_get_outpoint(this_ptr);
	return nativeResponseValue;
}
	// void WatchedOutput_set_outpoint(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */
export function WatchedOutput_set_outpoint(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_set_outpoint(this_ptr, val);
	// debug statements here
}
	// struct LDKu8slice WatchedOutput_get_script_pubkey(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);
/* @internal */
export function WatchedOutput_get_script_pubkey(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_get_script_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void WatchedOutput_set_script_pubkey(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);
/* @internal */
export function WatchedOutput_set_script_pubkey(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_set_script_pubkey(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKWatchedOutput WatchedOutput_new(struct LDKCOption_BlockHashZ block_hash_arg, struct LDKOutPoint outpoint_arg, struct LDKCVec_u8Z script_pubkey_arg);
/* @internal */
export function WatchedOutput_new(block_hash_arg: bigint, outpoint_arg: bigint, script_pubkey_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_new(block_hash_arg, outpoint_arg, script_pubkey_arg);
	return nativeResponseValue;
}
	// uint64_t WatchedOutput_clone_ptr(LDKWatchedOutput *NONNULL_PTR arg);
/* @internal */
export function WatchedOutput_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKWatchedOutput WatchedOutput_clone(const struct LDKWatchedOutput *NONNULL_PTR orig);
/* @internal */
export function WatchedOutput_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_clone(orig);
	return nativeResponseValue;
}
	// bool WatchedOutput_eq(const struct LDKWatchedOutput *NONNULL_PTR a, const struct LDKWatchedOutput *NONNULL_PTR b);
/* @internal */
export function WatchedOutput_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_eq(a, b);
	return nativeResponseValue;
}
	// uint64_t WatchedOutput_hash(const struct LDKWatchedOutput *NONNULL_PTR o);
/* @internal */
export function WatchedOutput_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_hash(o);
	return nativeResponseValue;
}
	// void BroadcasterInterface_free(struct LDKBroadcasterInterface this_ptr);
/* @internal */
export function BroadcasterInterface_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BroadcasterInterface_free(this_ptr);
	// debug statements here
}
	// enum LDKConfirmationTarget ConfirmationTarget_clone(const enum LDKConfirmationTarget *NONNULL_PTR orig);
/* @internal */
export function ConfirmationTarget_clone(orig: bigint): ConfirmationTarget {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ConfirmationTarget_clone(orig);
	return nativeResponseValue;
}
	// enum LDKConfirmationTarget ConfirmationTarget_mempool_minimum(void);
/* @internal */
export function ConfirmationTarget_mempool_minimum(): ConfirmationTarget {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ConfirmationTarget_mempool_minimum();
	return nativeResponseValue;
}
	// enum LDKConfirmationTarget ConfirmationTarget_background(void);
/* @internal */
export function ConfirmationTarget_background(): ConfirmationTarget {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ConfirmationTarget_background();
	return nativeResponseValue;
}
	// enum LDKConfirmationTarget ConfirmationTarget_normal(void);
/* @internal */
export function ConfirmationTarget_normal(): ConfirmationTarget {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ConfirmationTarget_normal();
	return nativeResponseValue;
}
	// enum LDKConfirmationTarget ConfirmationTarget_high_priority(void);
/* @internal */
export function ConfirmationTarget_high_priority(): ConfirmationTarget {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ConfirmationTarget_high_priority();
	return nativeResponseValue;
}
	// uint64_t ConfirmationTarget_hash(const enum LDKConfirmationTarget *NONNULL_PTR o);
/* @internal */
export function ConfirmationTarget_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ConfirmationTarget_hash(o);
	return nativeResponseValue;
}
	// bool ConfirmationTarget_eq(const enum LDKConfirmationTarget *NONNULL_PTR a, const enum LDKConfirmationTarget *NONNULL_PTR b);
/* @internal */
export function ConfirmationTarget_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ConfirmationTarget_eq(a, b);
	return nativeResponseValue;
}
	// void FeeEstimator_free(struct LDKFeeEstimator this_ptr);
/* @internal */
export function FeeEstimator_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FeeEstimator_free(this_ptr);
	// debug statements here
}
	// void MonitorUpdateId_free(struct LDKMonitorUpdateId this_obj);
/* @internal */
export function MonitorUpdateId_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorUpdateId_free(this_obj);
	// debug statements here
}
	// uint64_t MonitorUpdateId_clone_ptr(LDKMonitorUpdateId *NONNULL_PTR arg);
/* @internal */
export function MonitorUpdateId_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorUpdateId_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKMonitorUpdateId MonitorUpdateId_clone(const struct LDKMonitorUpdateId *NONNULL_PTR orig);
/* @internal */
export function MonitorUpdateId_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorUpdateId_clone(orig);
	return nativeResponseValue;
}
	// uint64_t MonitorUpdateId_hash(const struct LDKMonitorUpdateId *NONNULL_PTR o);
/* @internal */
export function MonitorUpdateId_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorUpdateId_hash(o);
	return nativeResponseValue;
}
	// bool MonitorUpdateId_eq(const struct LDKMonitorUpdateId *NONNULL_PTR a, const struct LDKMonitorUpdateId *NONNULL_PTR b);
/* @internal */
export function MonitorUpdateId_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorUpdateId_eq(a, b);
	return nativeResponseValue;
}
	// void Persist_free(struct LDKPersist this_ptr);
/* @internal */
export function Persist_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Persist_free(this_ptr);
	// debug statements here
}
	// void LockedChannelMonitor_free(struct LDKLockedChannelMonitor this_obj);
/* @internal */
export function LockedChannelMonitor_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LockedChannelMonitor_free(this_obj);
	// debug statements here
}
	// void ChainMonitor_free(struct LDKChainMonitor this_obj);
/* @internal */
export function ChainMonitor_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKChainMonitor ChainMonitor_new(struct LDKCOption_FilterZ chain_source, struct LDKBroadcasterInterface broadcaster, struct LDKLogger logger, struct LDKFeeEstimator feeest, struct LDKPersist persister);
/* @internal */
export function ChainMonitor_new(chain_source: bigint, broadcaster: bigint, logger: bigint, feeest: bigint, persister: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_new(chain_source, broadcaster, logger, feeest, persister);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_BalanceZ ChainMonitor_get_claimable_balances(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKCVec_ChannelDetailsZ ignored_channels);
/* @internal */
export function ChainMonitor_get_claimable_balances(this_arg: bigint, ignored_channels: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_get_claimable_balances(this_arg, ignored_channels);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_LockedChannelMonitorNoneZ ChainMonitor_get_monitor(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo);
/* @internal */
export function ChainMonitor_get_monitor(this_arg: bigint, funding_txo: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_get_monitor(this_arg, funding_txo);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_OutPointZ ChainMonitor_list_monitors(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChainMonitor_list_monitors(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_list_monitors(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ ChainMonitor_list_pending_monitor_updates(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChainMonitor_list_pending_monitor_updates(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_list_pending_monitor_updates(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChainMonitor_channel_monitor_updated(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo, struct LDKMonitorUpdateId completed_update_id);
/* @internal */
export function ChainMonitor_channel_monitor_updated(this_arg: bigint, funding_txo: bigint, completed_update_id: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_channel_monitor_updated(this_arg, funding_txo, completed_update_id);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKFuture ChainMonitor_get_update_future(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChainMonitor_get_update_future(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_get_update_future(this_arg);
	return nativeResponseValue;
}
	// void ChainMonitor_rebroadcast_pending_claims(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChainMonitor_rebroadcast_pending_claims(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_rebroadcast_pending_claims(this_arg);
	// debug statements here
}
	// struct LDKListen ChainMonitor_as_Listen(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChainMonitor_as_Listen(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_as_Listen(this_arg);
	return nativeResponseValue;
}
	// struct LDKConfirm ChainMonitor_as_Confirm(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChainMonitor_as_Confirm(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_as_Confirm(this_arg);
	return nativeResponseValue;
}
	// struct LDKWatch ChainMonitor_as_Watch(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChainMonitor_as_Watch(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_as_Watch(this_arg);
	return nativeResponseValue;
}
	// struct LDKEventsProvider ChainMonitor_as_EventsProvider(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChainMonitor_as_EventsProvider(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_as_EventsProvider(this_arg);
	return nativeResponseValue;
}
	// void ChannelMonitorUpdate_free(struct LDKChannelMonitorUpdate this_obj);
/* @internal */
export function ChannelMonitorUpdate_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_free(this_obj);
	// debug statements here
}
	// uint64_t ChannelMonitorUpdate_get_update_id(const struct LDKChannelMonitorUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelMonitorUpdate_get_update_id(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_get_update_id(this_ptr);
	return nativeResponseValue;
}
	// void ChannelMonitorUpdate_set_update_id(struct LDKChannelMonitorUpdate *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelMonitorUpdate_set_update_id(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_set_update_id(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelMonitorUpdate_clone_ptr(LDKChannelMonitorUpdate *NONNULL_PTR arg);
/* @internal */
export function ChannelMonitorUpdate_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelMonitorUpdate ChannelMonitorUpdate_clone(const struct LDKChannelMonitorUpdate *NONNULL_PTR orig);
/* @internal */
export function ChannelMonitorUpdate_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_clone(orig);
	return nativeResponseValue;
}
	// bool ChannelMonitorUpdate_eq(const struct LDKChannelMonitorUpdate *NONNULL_PTR a, const struct LDKChannelMonitorUpdate *NONNULL_PTR b);
/* @internal */
export function ChannelMonitorUpdate_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelMonitorUpdate_write(const struct LDKChannelMonitorUpdate *NONNULL_PTR obj);
/* @internal */
export function ChannelMonitorUpdate_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ ChannelMonitorUpdate_read(struct LDKu8slice ser);
/* @internal */
export function ChannelMonitorUpdate_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_read(ser);
	return nativeResponseValue;
}
	// void MonitorEvent_free(struct LDKMonitorEvent this_ptr);
/* @internal */
export function MonitorEvent_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_free(this_ptr);
	// debug statements here
}
	// uint64_t MonitorEvent_clone_ptr(LDKMonitorEvent *NONNULL_PTR arg);
/* @internal */
export function MonitorEvent_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKMonitorEvent MonitorEvent_clone(const struct LDKMonitorEvent *NONNULL_PTR orig);
/* @internal */
export function MonitorEvent_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_clone(orig);
	return nativeResponseValue;
}
	// struct LDKMonitorEvent MonitorEvent_htlcevent(struct LDKHTLCUpdate a);
/* @internal */
export function MonitorEvent_htlcevent(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_htlcevent(a);
	return nativeResponseValue;
}
	// struct LDKMonitorEvent MonitorEvent_commitment_tx_confirmed(struct LDKOutPoint a);
/* @internal */
export function MonitorEvent_commitment_tx_confirmed(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_commitment_tx_confirmed(a);
	return nativeResponseValue;
}
	// struct LDKMonitorEvent MonitorEvent_completed(struct LDKOutPoint funding_txo, uint64_t monitor_update_id);
/* @internal */
export function MonitorEvent_completed(funding_txo: bigint, monitor_update_id: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_completed(funding_txo, monitor_update_id);
	return nativeResponseValue;
}
	// struct LDKMonitorEvent MonitorEvent_update_failed(struct LDKOutPoint a);
/* @internal */
export function MonitorEvent_update_failed(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_update_failed(a);
	return nativeResponseValue;
}
	// bool MonitorEvent_eq(const struct LDKMonitorEvent *NONNULL_PTR a, const struct LDKMonitorEvent *NONNULL_PTR b);
/* @internal */
export function MonitorEvent_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z MonitorEvent_write(const struct LDKMonitorEvent *NONNULL_PTR obj);
/* @internal */
export function MonitorEvent_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_MonitorEventZDecodeErrorZ MonitorEvent_read(struct LDKu8slice ser);
/* @internal */
export function MonitorEvent_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_read(ser);
	return nativeResponseValue;
}
	// void HTLCUpdate_free(struct LDKHTLCUpdate this_obj);
/* @internal */
export function HTLCUpdate_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCUpdate_free(this_obj);
	// debug statements here
}
	// uint64_t HTLCUpdate_clone_ptr(LDKHTLCUpdate *NONNULL_PTR arg);
/* @internal */
export function HTLCUpdate_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCUpdate_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKHTLCUpdate HTLCUpdate_clone(const struct LDKHTLCUpdate *NONNULL_PTR orig);
/* @internal */
export function HTLCUpdate_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCUpdate_clone(orig);
	return nativeResponseValue;
}
	// bool HTLCUpdate_eq(const struct LDKHTLCUpdate *NONNULL_PTR a, const struct LDKHTLCUpdate *NONNULL_PTR b);
/* @internal */
export function HTLCUpdate_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCUpdate_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z HTLCUpdate_write(const struct LDKHTLCUpdate *NONNULL_PTR obj);
/* @internal */
export function HTLCUpdate_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCUpdate_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_HTLCUpdateDecodeErrorZ HTLCUpdate_read(struct LDKu8slice ser);
/* @internal */
export function HTLCUpdate_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCUpdate_read(ser);
	return nativeResponseValue;
}
	// void Balance_free(struct LDKBalance this_ptr);
/* @internal */
export function Balance_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_free(this_ptr);
	// debug statements here
}
	// uint64_t Balance_clone_ptr(LDKBalance *NONNULL_PTR arg);
/* @internal */
export function Balance_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBalance Balance_clone(const struct LDKBalance *NONNULL_PTR orig);
/* @internal */
export function Balance_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_clone(orig);
	return nativeResponseValue;
}
	// struct LDKBalance Balance_claimable_on_channel_close(uint64_t amount_satoshis);
/* @internal */
export function Balance_claimable_on_channel_close(amount_satoshis: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_claimable_on_channel_close(amount_satoshis);
	return nativeResponseValue;
}
	// struct LDKBalance Balance_claimable_awaiting_confirmations(uint64_t amount_satoshis, uint32_t confirmation_height);
/* @internal */
export function Balance_claimable_awaiting_confirmations(amount_satoshis: bigint, confirmation_height: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_claimable_awaiting_confirmations(amount_satoshis, confirmation_height);
	return nativeResponseValue;
}
	// struct LDKBalance Balance_contentious_claimable(uint64_t amount_satoshis, uint32_t timeout_height, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_preimage);
/* @internal */
export function Balance_contentious_claimable(amount_satoshis: bigint, timeout_height: number, payment_hash: number, payment_preimage: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_contentious_claimable(amount_satoshis, timeout_height, payment_hash, payment_preimage);
	return nativeResponseValue;
}
	// struct LDKBalance Balance_maybe_timeout_claimable_htlc(uint64_t amount_satoshis, uint32_t claimable_height, struct LDKThirtyTwoBytes payment_hash);
/* @internal */
export function Balance_maybe_timeout_claimable_htlc(amount_satoshis: bigint, claimable_height: number, payment_hash: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_maybe_timeout_claimable_htlc(amount_satoshis, claimable_height, payment_hash);
	return nativeResponseValue;
}
	// struct LDKBalance Balance_maybe_preimage_claimable_htlc(uint64_t amount_satoshis, uint32_t expiry_height, struct LDKThirtyTwoBytes payment_hash);
/* @internal */
export function Balance_maybe_preimage_claimable_htlc(amount_satoshis: bigint, expiry_height: number, payment_hash: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_maybe_preimage_claimable_htlc(amount_satoshis, expiry_height, payment_hash);
	return nativeResponseValue;
}
	// struct LDKBalance Balance_counterparty_revoked_output_claimable(uint64_t amount_satoshis);
/* @internal */
export function Balance_counterparty_revoked_output_claimable(amount_satoshis: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_counterparty_revoked_output_claimable(amount_satoshis);
	return nativeResponseValue;
}
	// bool Balance_eq(const struct LDKBalance *NONNULL_PTR a, const struct LDKBalance *NONNULL_PTR b);
/* @internal */
export function Balance_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Balance_claimable_amount_satoshis(const struct LDKBalance *NONNULL_PTR this_arg);
/* @internal */
export function Balance_claimable_amount_satoshis(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_claimable_amount_satoshis(this_arg);
	return nativeResponseValue;
}
	// void ChannelMonitor_free(struct LDKChannelMonitor this_obj);
/* @internal */
export function ChannelMonitor_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_free(this_obj);
	// debug statements here
}
	// uint64_t ChannelMonitor_clone_ptr(LDKChannelMonitor *NONNULL_PTR arg);
/* @internal */
export function ChannelMonitor_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelMonitor ChannelMonitor_clone(const struct LDKChannelMonitor *NONNULL_PTR orig);
/* @internal */
export function ChannelMonitor_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelMonitor_write(const struct LDKChannelMonitor *NONNULL_PTR obj);
/* @internal */
export function ChannelMonitor_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_write(obj);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelMonitor_update_monitor(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKChannelMonitorUpdate *NONNULL_PTR updates, const struct LDKBroadcasterInterface *NONNULL_PTR broadcaster, struct LDKFeeEstimator fee_estimator, const struct LDKLogger *NONNULL_PTR logger);
/* @internal */
export function ChannelMonitor_update_monitor(this_arg: bigint, updates: bigint, broadcaster: bigint, fee_estimator: bigint, logger: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_update_monitor(this_arg, updates, broadcaster, fee_estimator, logger);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t ChannelMonitor_get_latest_update_id(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChannelMonitor_get_latest_update_id(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_get_latest_update_id(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKC2Tuple_OutPointScriptZ ChannelMonitor_get_funding_txo(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChannelMonitor_get_funding_txo(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_get_funding_txo(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ ChannelMonitor_get_outputs_to_watch(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChannelMonitor_get_outputs_to_watch(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_get_outputs_to_watch(this_arg);
	return nativeResponseValue;
}
	// void ChannelMonitor_load_outputs_to_watch(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKFilter *NONNULL_PTR filter);
/* @internal */
export function ChannelMonitor_load_outputs_to_watch(this_arg: bigint, filter: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_load_outputs_to_watch(this_arg, filter);
	// debug statements here
}
	// MUST_USE_RES struct LDKCVec_MonitorEventZ ChannelMonitor_get_and_clear_pending_monitor_events(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChannelMonitor_get_and_clear_pending_monitor_events(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_get_and_clear_pending_monitor_events(this_arg);
	return nativeResponseValue;
}
	// void ChannelMonitor_process_pending_events(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKEventHandler *NONNULL_PTR handler);
/* @internal */
export function ChannelMonitor_process_pending_events(this_arg: bigint, handler: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_process_pending_events(this_arg, handler);
	// debug statements here
}
	// MUST_USE_RES struct LDKPublicKey ChannelMonitor_get_counterparty_node_id(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChannelMonitor_get_counterparty_node_id(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_get_counterparty_node_id(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_TransactionZ ChannelMonitor_get_latest_holder_commitment_txn(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKLogger *NONNULL_PTR logger);
/* @internal */
export function ChannelMonitor_get_latest_holder_commitment_txn(this_arg: bigint, logger: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_get_latest_holder_commitment_txn(this_arg, logger);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ ChannelMonitor_block_connected(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);
/* @internal */
export function ChannelMonitor_block_connected(this_arg: bigint, header: number, txdata: number, height: number, broadcaster: bigint, fee_estimator: bigint, logger: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_block_connected(this_arg, header, txdata, height, broadcaster, fee_estimator, logger);
	return nativeResponseValue;
}
	// void ChannelMonitor_block_disconnected(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);
/* @internal */
export function ChannelMonitor_block_disconnected(this_arg: bigint, header: number, height: number, broadcaster: bigint, fee_estimator: bigint, logger: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_block_disconnected(this_arg, header, height, broadcaster, fee_estimator, logger);
	// debug statements here
}
	// MUST_USE_RES struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ ChannelMonitor_transactions_confirmed(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);
/* @internal */
export function ChannelMonitor_transactions_confirmed(this_arg: bigint, header: number, txdata: number, height: number, broadcaster: bigint, fee_estimator: bigint, logger: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_transactions_confirmed(this_arg, header, txdata, height, broadcaster, fee_estimator, logger);
	return nativeResponseValue;
}
	// void ChannelMonitor_transaction_unconfirmed(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*txid)[32], struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);
/* @internal */
export function ChannelMonitor_transaction_unconfirmed(this_arg: bigint, txid: number, broadcaster: bigint, fee_estimator: bigint, logger: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_transaction_unconfirmed(this_arg, txid, broadcaster, fee_estimator, logger);
	// debug statements here
}
	// MUST_USE_RES struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ ChannelMonitor_best_block_updated(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);
/* @internal */
export function ChannelMonitor_best_block_updated(this_arg: bigint, header: number, height: number, broadcaster: bigint, fee_estimator: bigint, logger: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_best_block_updated(this_arg, header, height, broadcaster, fee_estimator, logger);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_C2Tuple_TxidCOption_BlockHashZZZ ChannelMonitor_get_relevant_txids(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChannelMonitor_get_relevant_txids(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_get_relevant_txids(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKBestBlock ChannelMonitor_current_best_block(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChannelMonitor_current_best_block(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_current_best_block(this_arg);
	return nativeResponseValue;
}
	// void ChannelMonitor_rebroadcast_pending_claims(const struct LDKChannelMonitor *NONNULL_PTR this_arg, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);
/* @internal */
export function ChannelMonitor_rebroadcast_pending_claims(this_arg: bigint, broadcaster: bigint, fee_estimator: bigint, logger: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_rebroadcast_pending_claims(this_arg, broadcaster, fee_estimator, logger);
	// debug statements here
}
	// MUST_USE_RES struct LDKCVec_BalanceZ ChannelMonitor_get_claimable_balances(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChannelMonitor_get_claimable_balances(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_get_claimable_balances(this_arg);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ C2Tuple_BlockHashChannelMonitorZ_read(struct LDKu8slice ser, const struct LDKEntropySource *NONNULL_PTR arg_a, const struct LDKSignerProvider *NONNULL_PTR arg_b);
/* @internal */
export function C2Tuple_BlockHashChannelMonitorZ_read(ser: number, arg_a: bigint, arg_b: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_read(ser, arg_a, arg_b);
	return nativeResponseValue;
}
	// void OutPoint_free(struct LDKOutPoint this_obj);
/* @internal */
export function OutPoint_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_free(this_obj);
	// debug statements here
}
	// const uint8_t (*OutPoint_get_txid(const struct LDKOutPoint *NONNULL_PTR this_ptr))[32];
/* @internal */
export function OutPoint_get_txid(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_get_txid(this_ptr);
	return nativeResponseValue;
}
	// void OutPoint_set_txid(struct LDKOutPoint *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function OutPoint_set_txid(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_set_txid(this_ptr, val);
	// debug statements here
}
	// uint16_t OutPoint_get_index(const struct LDKOutPoint *NONNULL_PTR this_ptr);
/* @internal */
export function OutPoint_get_index(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_get_index(this_ptr);
	return nativeResponseValue;
}
	// void OutPoint_set_index(struct LDKOutPoint *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function OutPoint_set_index(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_set_index(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKOutPoint OutPoint_new(struct LDKThirtyTwoBytes txid_arg, uint16_t index_arg);
/* @internal */
export function OutPoint_new(txid_arg: number, index_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_new(txid_arg, index_arg);
	return nativeResponseValue;
}
	// uint64_t OutPoint_clone_ptr(LDKOutPoint *NONNULL_PTR arg);
/* @internal */
export function OutPoint_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKOutPoint OutPoint_clone(const struct LDKOutPoint *NONNULL_PTR orig);
/* @internal */
export function OutPoint_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_clone(orig);
	return nativeResponseValue;
}
	// bool OutPoint_eq(const struct LDKOutPoint *NONNULL_PTR a, const struct LDKOutPoint *NONNULL_PTR b);
/* @internal */
export function OutPoint_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_eq(a, b);
	return nativeResponseValue;
}
	// uint64_t OutPoint_hash(const struct LDKOutPoint *NONNULL_PTR o);
/* @internal */
export function OutPoint_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_hash(o);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes OutPoint_to_channel_id(const struct LDKOutPoint *NONNULL_PTR this_arg);
/* @internal */
export function OutPoint_to_channel_id(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_to_channel_id(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z OutPoint_write(const struct LDKOutPoint *NONNULL_PTR obj);
/* @internal */
export function OutPoint_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_OutPointDecodeErrorZ OutPoint_read(struct LDKu8slice ser);
/* @internal */
export function OutPoint_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_read(ser);
	return nativeResponseValue;
}
	// enum LDKFailureCode FailureCode_clone(const enum LDKFailureCode *NONNULL_PTR orig);
/* @internal */
export function FailureCode_clone(orig: bigint): FailureCode {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FailureCode_clone(orig);
	return nativeResponseValue;
}
	// enum LDKFailureCode FailureCode_temporary_node_failure(void);
/* @internal */
export function FailureCode_temporary_node_failure(): FailureCode {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FailureCode_temporary_node_failure();
	return nativeResponseValue;
}
	// enum LDKFailureCode FailureCode_required_node_feature_missing(void);
/* @internal */
export function FailureCode_required_node_feature_missing(): FailureCode {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FailureCode_required_node_feature_missing();
	return nativeResponseValue;
}
	// enum LDKFailureCode FailureCode_incorrect_or_unknown_payment_details(void);
/* @internal */
export function FailureCode_incorrect_or_unknown_payment_details(): FailureCode {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FailureCode_incorrect_or_unknown_payment_details();
	return nativeResponseValue;
}
	// void ChannelManager_free(struct LDKChannelManager this_obj);
/* @internal */
export function ChannelManager_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_free(this_obj);
	// debug statements here
}
	// void ChainParameters_free(struct LDKChainParameters this_obj);
/* @internal */
export function ChainParameters_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainParameters_free(this_obj);
	// debug statements here
}
	// enum LDKNetwork ChainParameters_get_network(const struct LDKChainParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChainParameters_get_network(this_ptr: bigint): Network {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainParameters_get_network(this_ptr);
	return nativeResponseValue;
}
	// void ChainParameters_set_network(struct LDKChainParameters *NONNULL_PTR this_ptr, enum LDKNetwork val);
/* @internal */
export function ChainParameters_set_network(this_ptr: bigint, val: Network): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainParameters_set_network(this_ptr, val);
	// debug statements here
}
	// struct LDKBestBlock ChainParameters_get_best_block(const struct LDKChainParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChainParameters_get_best_block(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainParameters_get_best_block(this_ptr);
	return nativeResponseValue;
}
	// void ChainParameters_set_best_block(struct LDKChainParameters *NONNULL_PTR this_ptr, struct LDKBestBlock val);
/* @internal */
export function ChainParameters_set_best_block(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainParameters_set_best_block(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChainParameters ChainParameters_new(enum LDKNetwork network_arg, struct LDKBestBlock best_block_arg);
/* @internal */
export function ChainParameters_new(network_arg: Network, best_block_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainParameters_new(network_arg, best_block_arg);
	return nativeResponseValue;
}
	// uint64_t ChainParameters_clone_ptr(LDKChainParameters *NONNULL_PTR arg);
/* @internal */
export function ChainParameters_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainParameters_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChainParameters ChainParameters_clone(const struct LDKChainParameters *NONNULL_PTR orig);
/* @internal */
export function ChainParameters_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainParameters_clone(orig);
	return nativeResponseValue;
}
	// void CounterpartyForwardingInfo_free(struct LDKCounterpartyForwardingInfo this_obj);
/* @internal */
export function CounterpartyForwardingInfo_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_free(this_obj);
	// debug statements here
}
	// uint32_t CounterpartyForwardingInfo_get_fee_base_msat(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);
/* @internal */
export function CounterpartyForwardingInfo_get_fee_base_msat(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_get_fee_base_msat(this_ptr);
	return nativeResponseValue;
}
	// void CounterpartyForwardingInfo_set_fee_base_msat(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function CounterpartyForwardingInfo_set_fee_base_msat(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_set_fee_base_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t CounterpartyForwardingInfo_get_fee_proportional_millionths(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);
/* @internal */
export function CounterpartyForwardingInfo_get_fee_proportional_millionths(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_get_fee_proportional_millionths(this_ptr);
	return nativeResponseValue;
}
	// void CounterpartyForwardingInfo_set_fee_proportional_millionths(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function CounterpartyForwardingInfo_set_fee_proportional_millionths(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_set_fee_proportional_millionths(this_ptr, val);
	// debug statements here
}
	// uint16_t CounterpartyForwardingInfo_get_cltv_expiry_delta(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);
/* @internal */
export function CounterpartyForwardingInfo_get_cltv_expiry_delta(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_get_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void CounterpartyForwardingInfo_set_cltv_expiry_delta(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function CounterpartyForwardingInfo_set_cltv_expiry_delta(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_set_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKCounterpartyForwardingInfo CounterpartyForwardingInfo_new(uint32_t fee_base_msat_arg, uint32_t fee_proportional_millionths_arg, uint16_t cltv_expiry_delta_arg);
/* @internal */
export function CounterpartyForwardingInfo_new(fee_base_msat_arg: number, fee_proportional_millionths_arg: number, cltv_expiry_delta_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_new(fee_base_msat_arg, fee_proportional_millionths_arg, cltv_expiry_delta_arg);
	return nativeResponseValue;
}
	// uint64_t CounterpartyForwardingInfo_clone_ptr(LDKCounterpartyForwardingInfo *NONNULL_PTR arg);
/* @internal */
export function CounterpartyForwardingInfo_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCounterpartyForwardingInfo CounterpartyForwardingInfo_clone(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR orig);
/* @internal */
export function CounterpartyForwardingInfo_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_clone(orig);
	return nativeResponseValue;
}
	// void ChannelCounterparty_free(struct LDKChannelCounterparty this_obj);
/* @internal */
export function ChannelCounterparty_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_free(this_obj);
	// debug statements here
}
	// struct LDKPublicKey ChannelCounterparty_get_node_id(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelCounterparty_get_node_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_get_node_id(this_ptr);
	return nativeResponseValue;
}
	// void ChannelCounterparty_set_node_id(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function ChannelCounterparty_set_node_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_set_node_id(this_ptr, val);
	// debug statements here
}
	// struct LDKInitFeatures ChannelCounterparty_get_features(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelCounterparty_get_features(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_get_features(this_ptr);
	return nativeResponseValue;
}
	// void ChannelCounterparty_set_features(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKInitFeatures val);
/* @internal */
export function ChannelCounterparty_set_features(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_set_features(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelCounterparty_get_unspendable_punishment_reserve(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelCounterparty_get_unspendable_punishment_reserve(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_get_unspendable_punishment_reserve(this_ptr);
	return nativeResponseValue;
}
	// void ChannelCounterparty_set_unspendable_punishment_reserve(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelCounterparty_set_unspendable_punishment_reserve(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_set_unspendable_punishment_reserve(this_ptr, val);
	// debug statements here
}
	// struct LDKCounterpartyForwardingInfo ChannelCounterparty_get_forwarding_info(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelCounterparty_get_forwarding_info(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_get_forwarding_info(this_ptr);
	return nativeResponseValue;
}
	// void ChannelCounterparty_set_forwarding_info(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKCounterpartyForwardingInfo val);
/* @internal */
export function ChannelCounterparty_set_forwarding_info(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_set_forwarding_info(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z ChannelCounterparty_get_outbound_htlc_minimum_msat(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelCounterparty_get_outbound_htlc_minimum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_get_outbound_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelCounterparty_set_outbound_htlc_minimum_msat(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function ChannelCounterparty_set_outbound_htlc_minimum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_set_outbound_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z ChannelCounterparty_get_outbound_htlc_maximum_msat(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelCounterparty_get_outbound_htlc_maximum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_get_outbound_htlc_maximum_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelCounterparty_set_outbound_htlc_maximum_msat(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function ChannelCounterparty_set_outbound_htlc_maximum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_set_outbound_htlc_maximum_msat(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelCounterparty ChannelCounterparty_new(struct LDKPublicKey node_id_arg, struct LDKInitFeatures features_arg, uint64_t unspendable_punishment_reserve_arg, struct LDKCounterpartyForwardingInfo forwarding_info_arg, struct LDKCOption_u64Z outbound_htlc_minimum_msat_arg, struct LDKCOption_u64Z outbound_htlc_maximum_msat_arg);
/* @internal */
export function ChannelCounterparty_new(node_id_arg: number, features_arg: bigint, unspendable_punishment_reserve_arg: bigint, forwarding_info_arg: bigint, outbound_htlc_minimum_msat_arg: bigint, outbound_htlc_maximum_msat_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_new(node_id_arg, features_arg, unspendable_punishment_reserve_arg, forwarding_info_arg, outbound_htlc_minimum_msat_arg, outbound_htlc_maximum_msat_arg);
	return nativeResponseValue;
}
	// uint64_t ChannelCounterparty_clone_ptr(LDKChannelCounterparty *NONNULL_PTR arg);
/* @internal */
export function ChannelCounterparty_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelCounterparty ChannelCounterparty_clone(const struct LDKChannelCounterparty *NONNULL_PTR orig);
/* @internal */
export function ChannelCounterparty_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_clone(orig);
	return nativeResponseValue;
}
	// void ChannelDetails_free(struct LDKChannelDetails this_obj);
/* @internal */
export function ChannelDetails_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_free(this_obj);
	// debug statements here
}
	// const uint8_t (*ChannelDetails_get_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr))[32];
/* @internal */
export function ChannelDetails_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function ChannelDetails_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelCounterparty ChannelDetails_get_counterparty(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_counterparty(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_counterparty(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_counterparty(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKChannelCounterparty val);
/* @internal */
export function ChannelDetails_set_counterparty(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_counterparty(this_ptr, val);
	// debug statements here
}
	// struct LDKOutPoint ChannelDetails_get_funding_txo(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_funding_txo(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_funding_txo(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_funding_txo(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */
export function ChannelDetails_set_funding_txo(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_funding_txo(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelTypeFeatures ChannelDetails_get_channel_type(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_channel_type(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_channel_type(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_channel_type(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);
/* @internal */
export function ChannelDetails_set_channel_type(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_channel_type(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z ChannelDetails_get_short_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_short_channel_id(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_short_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_short_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function ChannelDetails_set_short_channel_id(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_short_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z ChannelDetails_get_outbound_scid_alias(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_outbound_scid_alias(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_outbound_scid_alias(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_outbound_scid_alias(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function ChannelDetails_set_outbound_scid_alias(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_outbound_scid_alias(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z ChannelDetails_get_inbound_scid_alias(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_inbound_scid_alias(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_inbound_scid_alias(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_inbound_scid_alias(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function ChannelDetails_set_inbound_scid_alias(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_inbound_scid_alias(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelDetails_get_channel_value_satoshis(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_channel_value_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_channel_value_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_channel_value_satoshis(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelDetails_set_channel_value_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_channel_value_satoshis(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z ChannelDetails_get_unspendable_punishment_reserve(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_unspendable_punishment_reserve(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_unspendable_punishment_reserve(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_unspendable_punishment_reserve(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function ChannelDetails_set_unspendable_punishment_reserve(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_unspendable_punishment_reserve(this_ptr, val);
	// debug statements here
}
	// struct LDKU128 ChannelDetails_get_user_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_user_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_user_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_user_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKU128 val);
/* @internal */
export function ChannelDetails_set_user_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_user_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u32Z ChannelDetails_get_feerate_sat_per_1000_weight(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_feerate_sat_per_1000_weight(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_feerate_sat_per_1000_weight(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_feerate_sat_per_1000_weight(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);
/* @internal */
export function ChannelDetails_set_feerate_sat_per_1000_weight(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_feerate_sat_per_1000_weight(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelDetails_get_balance_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_balance_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_balance_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_balance_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelDetails_set_balance_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_balance_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelDetails_get_outbound_capacity_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_outbound_capacity_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_outbound_capacity_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_outbound_capacity_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelDetails_set_outbound_capacity_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_outbound_capacity_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelDetails_get_next_outbound_htlc_limit_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_next_outbound_htlc_limit_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_next_outbound_htlc_limit_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_next_outbound_htlc_limit_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelDetails_set_next_outbound_htlc_limit_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_next_outbound_htlc_limit_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelDetails_get_next_outbound_htlc_minimum_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_next_outbound_htlc_minimum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_next_outbound_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_next_outbound_htlc_minimum_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelDetails_set_next_outbound_htlc_minimum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_next_outbound_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelDetails_get_inbound_capacity_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_inbound_capacity_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_inbound_capacity_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_inbound_capacity_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelDetails_set_inbound_capacity_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_inbound_capacity_msat(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u32Z ChannelDetails_get_confirmations_required(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_confirmations_required(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_confirmations_required(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_confirmations_required(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);
/* @internal */
export function ChannelDetails_set_confirmations_required(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_confirmations_required(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u32Z ChannelDetails_get_confirmations(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_confirmations(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_confirmations(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_confirmations(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);
/* @internal */
export function ChannelDetails_set_confirmations(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_confirmations(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u16Z ChannelDetails_get_force_close_spend_delay(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_force_close_spend_delay(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_force_close_spend_delay(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_force_close_spend_delay(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u16Z val);
/* @internal */
export function ChannelDetails_set_force_close_spend_delay(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_force_close_spend_delay(this_ptr, val);
	// debug statements here
}
	// bool ChannelDetails_get_is_outbound(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_is_outbound(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_is_outbound(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_is_outbound(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelDetails_set_is_outbound(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_is_outbound(this_ptr, val);
	// debug statements here
}
	// bool ChannelDetails_get_is_channel_ready(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_is_channel_ready(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_is_channel_ready(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_is_channel_ready(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelDetails_set_is_channel_ready(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_is_channel_ready(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_ChannelShutdownStateZ ChannelDetails_get_channel_shutdown_state(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_channel_shutdown_state(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_channel_shutdown_state(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_channel_shutdown_state(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_ChannelShutdownStateZ val);
/* @internal */
export function ChannelDetails_set_channel_shutdown_state(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_channel_shutdown_state(this_ptr, val);
	// debug statements here
}
	// bool ChannelDetails_get_is_usable(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_is_usable(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_is_usable(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_is_usable(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelDetails_set_is_usable(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_is_usable(this_ptr, val);
	// debug statements here
}
	// bool ChannelDetails_get_is_public(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_is_public(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_is_public(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_is_public(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelDetails_set_is_public(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_is_public(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z ChannelDetails_get_inbound_htlc_minimum_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_inbound_htlc_minimum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_inbound_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_inbound_htlc_minimum_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function ChannelDetails_set_inbound_htlc_minimum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_inbound_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z ChannelDetails_get_inbound_htlc_maximum_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_inbound_htlc_maximum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_inbound_htlc_maximum_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_inbound_htlc_maximum_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function ChannelDetails_set_inbound_htlc_maximum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_inbound_htlc_maximum_msat(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelConfig ChannelDetails_get_config(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_config(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_config(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_config(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKChannelConfig val);
/* @internal */
export function ChannelDetails_set_config(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_config(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelDetails ChannelDetails_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKChannelCounterparty counterparty_arg, struct LDKOutPoint funding_txo_arg, struct LDKChannelTypeFeatures channel_type_arg, struct LDKCOption_u64Z short_channel_id_arg, struct LDKCOption_u64Z outbound_scid_alias_arg, struct LDKCOption_u64Z inbound_scid_alias_arg, uint64_t channel_value_satoshis_arg, struct LDKCOption_u64Z unspendable_punishment_reserve_arg, struct LDKU128 user_channel_id_arg, struct LDKCOption_u32Z feerate_sat_per_1000_weight_arg, uint64_t balance_msat_arg, uint64_t outbound_capacity_msat_arg, uint64_t next_outbound_htlc_limit_msat_arg, uint64_t next_outbound_htlc_minimum_msat_arg, uint64_t inbound_capacity_msat_arg, struct LDKCOption_u32Z confirmations_required_arg, struct LDKCOption_u32Z confirmations_arg, struct LDKCOption_u16Z force_close_spend_delay_arg, bool is_outbound_arg, bool is_channel_ready_arg, struct LDKCOption_ChannelShutdownStateZ channel_shutdown_state_arg, bool is_usable_arg, bool is_public_arg, struct LDKCOption_u64Z inbound_htlc_minimum_msat_arg, struct LDKCOption_u64Z inbound_htlc_maximum_msat_arg, struct LDKChannelConfig config_arg);
/* @internal */
export function ChannelDetails_new(channel_id_arg: number, counterparty_arg: bigint, funding_txo_arg: bigint, channel_type_arg: bigint, short_channel_id_arg: bigint, outbound_scid_alias_arg: bigint, inbound_scid_alias_arg: bigint, channel_value_satoshis_arg: bigint, unspendable_punishment_reserve_arg: bigint, user_channel_id_arg: number, feerate_sat_per_1000_weight_arg: bigint, balance_msat_arg: bigint, outbound_capacity_msat_arg: bigint, next_outbound_htlc_limit_msat_arg: bigint, next_outbound_htlc_minimum_msat_arg: bigint, inbound_capacity_msat_arg: bigint, confirmations_required_arg: bigint, confirmations_arg: bigint, force_close_spend_delay_arg: bigint, is_outbound_arg: boolean, is_channel_ready_arg: boolean, channel_shutdown_state_arg: bigint, is_usable_arg: boolean, is_public_arg: boolean, inbound_htlc_minimum_msat_arg: bigint, inbound_htlc_maximum_msat_arg: bigint, config_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_new(channel_id_arg, counterparty_arg, funding_txo_arg, channel_type_arg, short_channel_id_arg, outbound_scid_alias_arg, inbound_scid_alias_arg, channel_value_satoshis_arg, unspendable_punishment_reserve_arg, user_channel_id_arg, feerate_sat_per_1000_weight_arg, balance_msat_arg, outbound_capacity_msat_arg, next_outbound_htlc_limit_msat_arg, next_outbound_htlc_minimum_msat_arg, inbound_capacity_msat_arg, confirmations_required_arg, confirmations_arg, force_close_spend_delay_arg, is_outbound_arg, is_channel_ready_arg, channel_shutdown_state_arg, is_usable_arg, is_public_arg, inbound_htlc_minimum_msat_arg, inbound_htlc_maximum_msat_arg, config_arg);
	return nativeResponseValue;
}
	// uint64_t ChannelDetails_clone_ptr(LDKChannelDetails *NONNULL_PTR arg);
/* @internal */
export function ChannelDetails_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelDetails ChannelDetails_clone(const struct LDKChannelDetails *NONNULL_PTR orig);
/* @internal */
export function ChannelDetails_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_u64Z ChannelDetails_get_inbound_payment_scid(const struct LDKChannelDetails *NONNULL_PTR this_arg);
/* @internal */
export function ChannelDetails_get_inbound_payment_scid(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_inbound_payment_scid(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_u64Z ChannelDetails_get_outbound_payment_scid(const struct LDKChannelDetails *NONNULL_PTR this_arg);
/* @internal */
export function ChannelDetails_get_outbound_payment_scid(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_outbound_payment_scid(this_arg);
	return nativeResponseValue;
}
	// enum LDKChannelShutdownState ChannelShutdownState_clone(const enum LDKChannelShutdownState *NONNULL_PTR orig);
/* @internal */
export function ChannelShutdownState_clone(orig: bigint): ChannelShutdownState {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelShutdownState_clone(orig);
	return nativeResponseValue;
}
	// enum LDKChannelShutdownState ChannelShutdownState_not_shutting_down(void);
/* @internal */
export function ChannelShutdownState_not_shutting_down(): ChannelShutdownState {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelShutdownState_not_shutting_down();
	return nativeResponseValue;
}
	// enum LDKChannelShutdownState ChannelShutdownState_shutdown_initiated(void);
/* @internal */
export function ChannelShutdownState_shutdown_initiated(): ChannelShutdownState {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelShutdownState_shutdown_initiated();
	return nativeResponseValue;
}
	// enum LDKChannelShutdownState ChannelShutdownState_resolving_htlcs(void);
/* @internal */
export function ChannelShutdownState_resolving_htlcs(): ChannelShutdownState {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelShutdownState_resolving_htlcs();
	return nativeResponseValue;
}
	// enum LDKChannelShutdownState ChannelShutdownState_negotiating_closing_fee(void);
/* @internal */
export function ChannelShutdownState_negotiating_closing_fee(): ChannelShutdownState {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelShutdownState_negotiating_closing_fee();
	return nativeResponseValue;
}
	// enum LDKChannelShutdownState ChannelShutdownState_shutdown_complete(void);
/* @internal */
export function ChannelShutdownState_shutdown_complete(): ChannelShutdownState {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelShutdownState_shutdown_complete();
	return nativeResponseValue;
}
	// bool ChannelShutdownState_eq(const enum LDKChannelShutdownState *NONNULL_PTR a, const enum LDKChannelShutdownState *NONNULL_PTR b);
/* @internal */
export function ChannelShutdownState_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelShutdownState_eq(a, b);
	return nativeResponseValue;
}
	// void RecentPaymentDetails_free(struct LDKRecentPaymentDetails this_ptr);
/* @internal */
export function RecentPaymentDetails_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecentPaymentDetails_free(this_ptr);
	// debug statements here
}
	// uint64_t RecentPaymentDetails_clone_ptr(LDKRecentPaymentDetails *NONNULL_PTR arg);
/* @internal */
export function RecentPaymentDetails_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecentPaymentDetails_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRecentPaymentDetails RecentPaymentDetails_clone(const struct LDKRecentPaymentDetails *NONNULL_PTR orig);
/* @internal */
export function RecentPaymentDetails_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecentPaymentDetails_clone(orig);
	return nativeResponseValue;
}
	// struct LDKRecentPaymentDetails RecentPaymentDetails_pending(struct LDKThirtyTwoBytes payment_hash, uint64_t total_msat);
/* @internal */
export function RecentPaymentDetails_pending(payment_hash: number, total_msat: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecentPaymentDetails_pending(payment_hash, total_msat);
	return nativeResponseValue;
}
	// struct LDKRecentPaymentDetails RecentPaymentDetails_fulfilled(struct LDKCOption_PaymentHashZ payment_hash);
/* @internal */
export function RecentPaymentDetails_fulfilled(payment_hash: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecentPaymentDetails_fulfilled(payment_hash);
	return nativeResponseValue;
}
	// struct LDKRecentPaymentDetails RecentPaymentDetails_abandoned(struct LDKThirtyTwoBytes payment_hash);
/* @internal */
export function RecentPaymentDetails_abandoned(payment_hash: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecentPaymentDetails_abandoned(payment_hash);
	return nativeResponseValue;
}
	// void PhantomRouteHints_free(struct LDKPhantomRouteHints this_obj);
/* @internal */
export function PhantomRouteHints_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_free(this_obj);
	// debug statements here
}
	// struct LDKCVec_ChannelDetailsZ PhantomRouteHints_get_channels(const struct LDKPhantomRouteHints *NONNULL_PTR this_ptr);
/* @internal */
export function PhantomRouteHints_get_channels(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_get_channels(this_ptr);
	return nativeResponseValue;
}
	// void PhantomRouteHints_set_channels(struct LDKPhantomRouteHints *NONNULL_PTR this_ptr, struct LDKCVec_ChannelDetailsZ val);
/* @internal */
export function PhantomRouteHints_set_channels(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_set_channels(this_ptr, val);
	// debug statements here
}
	// uint64_t PhantomRouteHints_get_phantom_scid(const struct LDKPhantomRouteHints *NONNULL_PTR this_ptr);
/* @internal */
export function PhantomRouteHints_get_phantom_scid(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_get_phantom_scid(this_ptr);
	return nativeResponseValue;
}
	// void PhantomRouteHints_set_phantom_scid(struct LDKPhantomRouteHints *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function PhantomRouteHints_set_phantom_scid(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_set_phantom_scid(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey PhantomRouteHints_get_real_node_pubkey(const struct LDKPhantomRouteHints *NONNULL_PTR this_ptr);
/* @internal */
export function PhantomRouteHints_get_real_node_pubkey(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_get_real_node_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void PhantomRouteHints_set_real_node_pubkey(struct LDKPhantomRouteHints *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function PhantomRouteHints_set_real_node_pubkey(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_set_real_node_pubkey(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKPhantomRouteHints PhantomRouteHints_new(struct LDKCVec_ChannelDetailsZ channels_arg, uint64_t phantom_scid_arg, struct LDKPublicKey real_node_pubkey_arg);
/* @internal */
export function PhantomRouteHints_new(channels_arg: number, phantom_scid_arg: bigint, real_node_pubkey_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_new(channels_arg, phantom_scid_arg, real_node_pubkey_arg);
	return nativeResponseValue;
}
	// uint64_t PhantomRouteHints_clone_ptr(LDKPhantomRouteHints *NONNULL_PTR arg);
/* @internal */
export function PhantomRouteHints_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPhantomRouteHints PhantomRouteHints_clone(const struct LDKPhantomRouteHints *NONNULL_PTR orig);
/* @internal */
export function PhantomRouteHints_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelManager ChannelManager_new(struct LDKFeeEstimator fee_est, struct LDKWatch chain_monitor, struct LDKBroadcasterInterface tx_broadcaster, struct LDKRouter router, struct LDKLogger logger, struct LDKEntropySource entropy_source, struct LDKNodeSigner node_signer, struct LDKSignerProvider signer_provider, struct LDKUserConfig config, struct LDKChainParameters params, uint32_t current_timestamp);
/* @internal */
export function ChannelManager_new(fee_est: bigint, chain_monitor: bigint, tx_broadcaster: bigint, router: bigint, logger: bigint, entropy_source: bigint, node_signer: bigint, signer_provider: bigint, config: bigint, params: bigint, current_timestamp: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_new(fee_est, chain_monitor, tx_broadcaster, router, logger, entropy_source, node_signer, signer_provider, config, params, current_timestamp);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKUserConfig ChannelManager_get_current_default_configuration(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_get_current_default_configuration(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_get_current_default_configuration(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult__u832APIErrorZ ChannelManager_create_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPublicKey their_network_key, uint64_t channel_value_satoshis, uint64_t push_msat, struct LDKU128 user_channel_id, struct LDKUserConfig override_config);
/* @internal */
export function ChannelManager_create_channel(this_arg: bigint, their_network_key: number, channel_value_satoshis: bigint, push_msat: bigint, user_channel_id: number, override_config: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_create_channel(this_arg, their_network_key, channel_value_satoshis, push_msat, user_channel_id, override_config);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_list_channels(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_list_channels(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_usable_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_list_usable_channels(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_list_usable_channels(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_channels_with_counterparty(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPublicKey counterparty_node_id);
/* @internal */
export function ChannelManager_list_channels_with_counterparty(this_arg: bigint, counterparty_node_id: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_list_channels_with_counterparty(this_arg, counterparty_node_id);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_RecentPaymentDetailsZ ChannelManager_list_recent_payments(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_list_recent_payments(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_list_recent_payments(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_close_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32], struct LDKPublicKey counterparty_node_id);
/* @internal */
export function ChannelManager_close_channel(this_arg: bigint, channel_id: number, counterparty_node_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_close_channel(this_arg, channel_id, counterparty_node_id);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_close_channel_with_feerate_and_script(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32], struct LDKPublicKey counterparty_node_id, struct LDKCOption_u32Z target_feerate_sats_per_1000_weight, struct LDKShutdownScript shutdown_script);
/* @internal */
export function ChannelManager_close_channel_with_feerate_and_script(this_arg: bigint, channel_id: number, counterparty_node_id: number, target_feerate_sats_per_1000_weight: bigint, shutdown_script: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_close_channel_with_feerate_and_script(this_arg, channel_id, counterparty_node_id, target_feerate_sats_per_1000_weight, shutdown_script);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_force_close_broadcasting_latest_txn(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32], struct LDKPublicKey counterparty_node_id);
/* @internal */
export function ChannelManager_force_close_broadcasting_latest_txn(this_arg: bigint, channel_id: number, counterparty_node_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_force_close_broadcasting_latest_txn(this_arg, channel_id, counterparty_node_id);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_force_close_without_broadcasting_txn(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32], struct LDKPublicKey counterparty_node_id);
/* @internal */
export function ChannelManager_force_close_without_broadcasting_txn(this_arg: bigint, channel_id: number, counterparty_node_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_force_close_without_broadcasting_txn(this_arg, channel_id, counterparty_node_id);
	return nativeResponseValue;
}
	// void ChannelManager_force_close_all_channels_broadcasting_latest_txn(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_force_close_all_channels_broadcasting_latest_txn(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_force_close_all_channels_broadcasting_latest_txn(this_arg);
	// debug statements here
}
	// void ChannelManager_force_close_all_channels_without_broadcasting_txn(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_force_close_all_channels_without_broadcasting_txn(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_force_close_all_channels_without_broadcasting_txn(this_arg);
	// debug statements here
}
	// MUST_USE_RES struct LDKCResult_NonePaymentSendFailureZ ChannelManager_send_payment_with_route(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_hash, struct LDKRecipientOnionFields recipient_onion, struct LDKThirtyTwoBytes payment_id);
/* @internal */
export function ChannelManager_send_payment_with_route(this_arg: bigint, route: bigint, payment_hash: number, recipient_onion: bigint, payment_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_send_payment_with_route(this_arg, route, payment_hash, recipient_onion, payment_id);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneRetryableSendFailureZ ChannelManager_send_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKRecipientOnionFields recipient_onion, struct LDKThirtyTwoBytes payment_id, struct LDKRouteParameters route_params, struct LDKRetry retry_strategy);
/* @internal */
export function ChannelManager_send_payment(this_arg: bigint, payment_hash: number, recipient_onion: bigint, payment_id: number, route_params: bigint, retry_strategy: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_send_payment(this_arg, payment_hash, recipient_onion, payment_id, route_params, retry_strategy);
	return nativeResponseValue;
}
	// void ChannelManager_abandon_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_id);
/* @internal */
export function ChannelManager_abandon_payment(this_arg: bigint, payment_id: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_abandon_payment(this_arg, payment_id);
	// debug statements here
}
	// MUST_USE_RES struct LDKCResult_PaymentHashPaymentSendFailureZ ChannelManager_send_spontaneous_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKCOption_PaymentPreimageZ payment_preimage, struct LDKRecipientOnionFields recipient_onion, struct LDKThirtyTwoBytes payment_id);
/* @internal */
export function ChannelManager_send_spontaneous_payment(this_arg: bigint, route: bigint, payment_preimage: bigint, recipient_onion: bigint, payment_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_send_spontaneous_payment(this_arg, route, payment_preimage, recipient_onion, payment_id);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PaymentHashRetryableSendFailureZ ChannelManager_send_spontaneous_payment_with_retry(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKCOption_PaymentPreimageZ payment_preimage, struct LDKRecipientOnionFields recipient_onion, struct LDKThirtyTwoBytes payment_id, struct LDKRouteParameters route_params, struct LDKRetry retry_strategy);
/* @internal */
export function ChannelManager_send_spontaneous_payment_with_retry(this_arg: bigint, payment_preimage: bigint, recipient_onion: bigint, payment_id: number, route_params: bigint, retry_strategy: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_send_spontaneous_payment_with_retry(this_arg, payment_preimage, recipient_onion, payment_id, route_params, retry_strategy);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ ChannelManager_send_probe(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPath path);
/* @internal */
export function ChannelManager_send_probe(this_arg: bigint, path: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_send_probe(this_arg, path);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_funding_transaction_generated(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*temporary_channel_id)[32], struct LDKPublicKey counterparty_node_id, struct LDKTransaction funding_transaction);
/* @internal */
export function ChannelManager_funding_transaction_generated(this_arg: bigint, temporary_channel_id: number, counterparty_node_id: number, funding_transaction: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_funding_transaction_generated(this_arg, temporary_channel_id, counterparty_node_id, funding_transaction);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_update_partial_channel_config(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPublicKey counterparty_node_id, struct LDKCVec_ThirtyTwoBytesZ channel_ids, const struct LDKChannelConfigUpdate *NONNULL_PTR config_update);
/* @internal */
export function ChannelManager_update_partial_channel_config(this_arg: bigint, counterparty_node_id: number, channel_ids: number, config_update: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_update_partial_channel_config(this_arg, counterparty_node_id, channel_ids, config_update);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_update_channel_config(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPublicKey counterparty_node_id, struct LDKCVec_ThirtyTwoBytesZ channel_ids, const struct LDKChannelConfig *NONNULL_PTR config);
/* @internal */
export function ChannelManager_update_channel_config(this_arg: bigint, counterparty_node_id: number, channel_ids: number, config: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_update_channel_config(this_arg, counterparty_node_id, channel_ids, config);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_forward_intercepted_htlc(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes intercept_id, const uint8_t (*next_hop_channel_id)[32], struct LDKPublicKey next_node_id, uint64_t amt_to_forward_msat);
/* @internal */
export function ChannelManager_forward_intercepted_htlc(this_arg: bigint, intercept_id: number, next_hop_channel_id: number, next_node_id: number, amt_to_forward_msat: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_forward_intercepted_htlc(this_arg, intercept_id, next_hop_channel_id, next_node_id, amt_to_forward_msat);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_fail_intercepted_htlc(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes intercept_id);
/* @internal */
export function ChannelManager_fail_intercepted_htlc(this_arg: bigint, intercept_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_fail_intercepted_htlc(this_arg, intercept_id);
	return nativeResponseValue;
}
	// void ChannelManager_process_pending_htlc_forwards(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_process_pending_htlc_forwards(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_process_pending_htlc_forwards(this_arg);
	// debug statements here
}
	// void ChannelManager_timer_tick_occurred(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_timer_tick_occurred(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_timer_tick_occurred(this_arg);
	// debug statements here
}
	// void ChannelManager_fail_htlc_backwards(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*payment_hash)[32]);
/* @internal */
export function ChannelManager_fail_htlc_backwards(this_arg: bigint, payment_hash: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_fail_htlc_backwards(this_arg, payment_hash);
	// debug statements here
}
	// void ChannelManager_fail_htlc_backwards_with_reason(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*payment_hash)[32], enum LDKFailureCode failure_code);
/* @internal */
export function ChannelManager_fail_htlc_backwards_with_reason(this_arg: bigint, payment_hash: number, failure_code: FailureCode): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_fail_htlc_backwards_with_reason(this_arg, payment_hash, failure_code);
	// debug statements here
}
	// void ChannelManager_claim_funds(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_preimage);
/* @internal */
export function ChannelManager_claim_funds(this_arg: bigint, payment_preimage: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_claim_funds(this_arg, payment_preimage);
	// debug statements here
}
	// MUST_USE_RES struct LDKPublicKey ChannelManager_get_our_node_id(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_get_our_node_id(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_get_our_node_id(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_accept_inbound_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*temporary_channel_id)[32], struct LDKPublicKey counterparty_node_id, struct LDKU128 user_channel_id);
/* @internal */
export function ChannelManager_accept_inbound_channel(this_arg: bigint, temporary_channel_id: number, counterparty_node_id: number, user_channel_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_accept_inbound_channel(this_arg, temporary_channel_id, counterparty_node_id, user_channel_id);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_accept_inbound_channel_from_trusted_peer_0conf(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*temporary_channel_id)[32], struct LDKPublicKey counterparty_node_id, struct LDKU128 user_channel_id);
/* @internal */
export function ChannelManager_accept_inbound_channel_from_trusted_peer_0conf(this_arg: bigint, temporary_channel_id: number, counterparty_node_id: number, user_channel_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_accept_inbound_channel_from_trusted_peer_0conf(this_arg, temporary_channel_id, counterparty_node_id, user_channel_id);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ ChannelManager_create_inbound_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs, struct LDKCOption_u16Z min_final_cltv_expiry_delta);
/* @internal */
export function ChannelManager_create_inbound_payment(this_arg: bigint, min_value_msat: bigint, invoice_expiry_delta_secs: number, min_final_cltv_expiry_delta: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_create_inbound_payment(this_arg, min_value_msat, invoice_expiry_delta_secs, min_final_cltv_expiry_delta);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PaymentSecretNoneZ ChannelManager_create_inbound_payment_for_hash(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs, struct LDKCOption_u16Z min_final_cltv_expiry);
/* @internal */
export function ChannelManager_create_inbound_payment_for_hash(this_arg: bigint, payment_hash: number, min_value_msat: bigint, invoice_expiry_delta_secs: number, min_final_cltv_expiry: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_create_inbound_payment_for_hash(this_arg, payment_hash, min_value_msat, invoice_expiry_delta_secs, min_final_cltv_expiry);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PaymentPreimageAPIErrorZ ChannelManager_get_payment_preimage(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_secret);
/* @internal */
export function ChannelManager_get_payment_preimage(this_arg: bigint, payment_hash: number, payment_secret: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_get_payment_preimage(this_arg, payment_hash, payment_secret);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t ChannelManager_get_phantom_scid(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_get_phantom_scid(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_get_phantom_scid(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPhantomRouteHints ChannelManager_get_phantom_route_hints(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_get_phantom_route_hints(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_get_phantom_route_hints(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t ChannelManager_get_intercept_scid(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_get_intercept_scid(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_get_intercept_scid(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInFlightHtlcs ChannelManager_compute_inflight_htlcs(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_compute_inflight_htlcs(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_compute_inflight_htlcs(this_arg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEventsProvider ChannelManager_as_MessageSendEventsProvider(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_as_MessageSendEventsProvider(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_as_MessageSendEventsProvider(this_arg);
	return nativeResponseValue;
}
	// struct LDKEventsProvider ChannelManager_as_EventsProvider(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_as_EventsProvider(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_as_EventsProvider(this_arg);
	return nativeResponseValue;
}
	// struct LDKListen ChannelManager_as_Listen(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_as_Listen(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_as_Listen(this_arg);
	return nativeResponseValue;
}
	// struct LDKConfirm ChannelManager_as_Confirm(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_as_Confirm(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_as_Confirm(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKFuture ChannelManager_get_persistable_update_future(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_get_persistable_update_future(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_get_persistable_update_future(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKBestBlock ChannelManager_current_best_block(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_current_best_block(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_current_best_block(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKNodeFeatures ChannelManager_node_features(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_node_features(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_node_features(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelFeatures ChannelManager_channel_features(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_channel_features(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_channel_features(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelTypeFeatures ChannelManager_channel_type_features(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_channel_type_features(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_channel_type_features(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInitFeatures ChannelManager_init_features(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_init_features(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_init_features(this_arg);
	return nativeResponseValue;
}
	// struct LDKChannelMessageHandler ChannelManager_as_ChannelMessageHandler(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_as_ChannelMessageHandler(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_as_ChannelMessageHandler(this_arg);
	return nativeResponseValue;
}
	// struct LDKInitFeatures provided_init_features(const struct LDKUserConfig *NONNULL_PTR config);
/* @internal */
export function provided_init_features(config: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_provided_init_features(config);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z CounterpartyForwardingInfo_write(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR obj);
/* @internal */
export function CounterpartyForwardingInfo_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CounterpartyForwardingInfo_read(struct LDKu8slice ser);
/* @internal */
export function CounterpartyForwardingInfo_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelCounterparty_write(const struct LDKChannelCounterparty *NONNULL_PTR obj);
/* @internal */
export function ChannelCounterparty_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelCounterpartyDecodeErrorZ ChannelCounterparty_read(struct LDKu8slice ser);
/* @internal */
export function ChannelCounterparty_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelDetails_write(const struct LDKChannelDetails *NONNULL_PTR obj);
/* @internal */
export function ChannelDetails_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelDetailsDecodeErrorZ ChannelDetails_read(struct LDKu8slice ser);
/* @internal */
export function ChannelDetails_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z PhantomRouteHints_write(const struct LDKPhantomRouteHints *NONNULL_PTR obj);
/* @internal */
export function PhantomRouteHints_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_PhantomRouteHintsDecodeErrorZ PhantomRouteHints_read(struct LDKu8slice ser);
/* @internal */
export function PhantomRouteHints_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelManager_write(const struct LDKChannelManager *NONNULL_PTR obj);
/* @internal */
export function ChannelManager_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_write(obj);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelShutdownState_write(const enum LDKChannelShutdownState *NONNULL_PTR obj);
/* @internal */
export function ChannelShutdownState_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelShutdownState_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelShutdownStateDecodeErrorZ ChannelShutdownState_read(struct LDKu8slice ser);
/* @internal */
export function ChannelShutdownState_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelShutdownState_read(ser);
	return nativeResponseValue;
}
	// void ChannelManagerReadArgs_free(struct LDKChannelManagerReadArgs this_obj);
/* @internal */
export function ChannelManagerReadArgs_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_free(this_obj);
	// debug statements here
}
	// const struct LDKEntropySource *ChannelManagerReadArgs_get_entropy_source(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelManagerReadArgs_get_entropy_source(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_entropy_source(this_ptr);
	return nativeResponseValue;
}
	// void ChannelManagerReadArgs_set_entropy_source(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKEntropySource val);
/* @internal */
export function ChannelManagerReadArgs_set_entropy_source(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_entropy_source(this_ptr, val);
	// debug statements here
}
	// const struct LDKNodeSigner *ChannelManagerReadArgs_get_node_signer(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelManagerReadArgs_get_node_signer(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_node_signer(this_ptr);
	return nativeResponseValue;
}
	// void ChannelManagerReadArgs_set_node_signer(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKNodeSigner val);
/* @internal */
export function ChannelManagerReadArgs_set_node_signer(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_node_signer(this_ptr, val);
	// debug statements here
}
	// const struct LDKSignerProvider *ChannelManagerReadArgs_get_signer_provider(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelManagerReadArgs_get_signer_provider(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_signer_provider(this_ptr);
	return nativeResponseValue;
}
	// void ChannelManagerReadArgs_set_signer_provider(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKSignerProvider val);
/* @internal */
export function ChannelManagerReadArgs_set_signer_provider(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_signer_provider(this_ptr, val);
	// debug statements here
}
	// const struct LDKFeeEstimator *ChannelManagerReadArgs_get_fee_estimator(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelManagerReadArgs_get_fee_estimator(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_fee_estimator(this_ptr);
	return nativeResponseValue;
}
	// void ChannelManagerReadArgs_set_fee_estimator(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKFeeEstimator val);
/* @internal */
export function ChannelManagerReadArgs_set_fee_estimator(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_fee_estimator(this_ptr, val);
	// debug statements here
}
	// const struct LDKWatch *ChannelManagerReadArgs_get_chain_monitor(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelManagerReadArgs_get_chain_monitor(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_chain_monitor(this_ptr);
	return nativeResponseValue;
}
	// void ChannelManagerReadArgs_set_chain_monitor(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKWatch val);
/* @internal */
export function ChannelManagerReadArgs_set_chain_monitor(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_chain_monitor(this_ptr, val);
	// debug statements here
}
	// const struct LDKBroadcasterInterface *ChannelManagerReadArgs_get_tx_broadcaster(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelManagerReadArgs_get_tx_broadcaster(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_tx_broadcaster(this_ptr);
	return nativeResponseValue;
}
	// void ChannelManagerReadArgs_set_tx_broadcaster(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKBroadcasterInterface val);
/* @internal */
export function ChannelManagerReadArgs_set_tx_broadcaster(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_tx_broadcaster(this_ptr, val);
	// debug statements here
}
	// const struct LDKRouter *ChannelManagerReadArgs_get_router(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelManagerReadArgs_get_router(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_router(this_ptr);
	return nativeResponseValue;
}
	// void ChannelManagerReadArgs_set_router(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKRouter val);
/* @internal */
export function ChannelManagerReadArgs_set_router(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_router(this_ptr, val);
	// debug statements here
}
	// const struct LDKLogger *ChannelManagerReadArgs_get_logger(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelManagerReadArgs_get_logger(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_logger(this_ptr);
	return nativeResponseValue;
}
	// void ChannelManagerReadArgs_set_logger(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKLogger val);
/* @internal */
export function ChannelManagerReadArgs_set_logger(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_logger(this_ptr, val);
	// debug statements here
}
	// struct LDKUserConfig ChannelManagerReadArgs_get_default_config(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelManagerReadArgs_get_default_config(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_default_config(this_ptr);
	return nativeResponseValue;
}
	// void ChannelManagerReadArgs_set_default_config(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKUserConfig val);
/* @internal */
export function ChannelManagerReadArgs_set_default_config(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_default_config(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelManagerReadArgs ChannelManagerReadArgs_new(struct LDKEntropySource entropy_source, struct LDKNodeSigner node_signer, struct LDKSignerProvider signer_provider, struct LDKFeeEstimator fee_estimator, struct LDKWatch chain_monitor, struct LDKBroadcasterInterface tx_broadcaster, struct LDKRouter router, struct LDKLogger logger, struct LDKUserConfig default_config, struct LDKCVec_ChannelMonitorZ channel_monitors);
/* @internal */
export function ChannelManagerReadArgs_new(entropy_source: bigint, node_signer: bigint, signer_provider: bigint, fee_estimator: bigint, chain_monitor: bigint, tx_broadcaster: bigint, router: bigint, logger: bigint, default_config: bigint, channel_monitors: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_new(entropy_source, node_signer, signer_provider, fee_estimator, chain_monitor, tx_broadcaster, router, logger, default_config, channel_monitors);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ C2Tuple_BlockHashChannelManagerZ_read(struct LDKu8slice ser, struct LDKChannelManagerReadArgs arg);
/* @internal */
export function C2Tuple_BlockHashChannelManagerZ_read(ser: number, arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelManagerZ_read(ser, arg);
	return nativeResponseValue;
}
	// void ExpandedKey_free(struct LDKExpandedKey this_obj);
/* @internal */
export function ExpandedKey_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpandedKey_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKExpandedKey ExpandedKey_new(const uint8_t (*key_material)[32]);
/* @internal */
export function ExpandedKey_new(key_material: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpandedKey_new(key_material);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ create(const struct LDKExpandedKey *NONNULL_PTR keys, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs, const struct LDKEntropySource *NONNULL_PTR entropy_source, uint64_t current_time, struct LDKCOption_u16Z min_final_cltv_expiry_delta);
/* @internal */
export function create(keys: bigint, min_value_msat: bigint, invoice_expiry_delta_secs: number, entropy_source: bigint, current_time: bigint, min_final_cltv_expiry_delta: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_create(keys, min_value_msat, invoice_expiry_delta_secs, entropy_source, current_time, min_final_cltv_expiry_delta);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentSecretNoneZ create_from_hash(const struct LDKExpandedKey *NONNULL_PTR keys, struct LDKCOption_u64Z min_value_msat, struct LDKThirtyTwoBytes payment_hash, uint32_t invoice_expiry_delta_secs, uint64_t current_time, struct LDKCOption_u16Z min_final_cltv_expiry_delta);
/* @internal */
export function create_from_hash(keys: bigint, min_value_msat: bigint, payment_hash: number, invoice_expiry_delta_secs: number, current_time: bigint, min_final_cltv_expiry_delta: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_create_from_hash(keys, min_value_msat, payment_hash, invoice_expiry_delta_secs, current_time, min_final_cltv_expiry_delta);
	return nativeResponseValue;
}
	// void DecodeError_free(struct LDKDecodeError this_ptr);
/* @internal */
export function DecodeError_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DecodeError_free(this_ptr);
	// debug statements here
}
	// uint64_t DecodeError_clone_ptr(LDKDecodeError *NONNULL_PTR arg);
/* @internal */
export function DecodeError_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DecodeError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKDecodeError DecodeError_clone(const struct LDKDecodeError *NONNULL_PTR orig);
/* @internal */
export function DecodeError_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DecodeError_clone(orig);
	return nativeResponseValue;
}
	// struct LDKDecodeError DecodeError_unknown_version(void);
/* @internal */
export function DecodeError_unknown_version(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DecodeError_unknown_version();
	return nativeResponseValue;
}
	// struct LDKDecodeError DecodeError_unknown_required_feature(void);
/* @internal */
export function DecodeError_unknown_required_feature(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DecodeError_unknown_required_feature();
	return nativeResponseValue;
}
	// struct LDKDecodeError DecodeError_invalid_value(void);
/* @internal */
export function DecodeError_invalid_value(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DecodeError_invalid_value();
	return nativeResponseValue;
}
	// struct LDKDecodeError DecodeError_short_read(void);
/* @internal */
export function DecodeError_short_read(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DecodeError_short_read();
	return nativeResponseValue;
}
	// struct LDKDecodeError DecodeError_bad_length_descriptor(void);
/* @internal */
export function DecodeError_bad_length_descriptor(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DecodeError_bad_length_descriptor();
	return nativeResponseValue;
}
	// struct LDKDecodeError DecodeError_io(enum LDKIOError a);
/* @internal */
export function DecodeError_io(a: IOError): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DecodeError_io(a);
	return nativeResponseValue;
}
	// struct LDKDecodeError DecodeError_unsupported_compression(void);
/* @internal */
export function DecodeError_unsupported_compression(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DecodeError_unsupported_compression();
	return nativeResponseValue;
}
	// bool DecodeError_eq(const struct LDKDecodeError *NONNULL_PTR a, const struct LDKDecodeError *NONNULL_PTR b);
/* @internal */
export function DecodeError_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DecodeError_eq(a, b);
	return nativeResponseValue;
}
	// void Init_free(struct LDKInit this_obj);
/* @internal */
export function Init_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_free(this_obj);
	// debug statements here
}
	// struct LDKInitFeatures Init_get_features(const struct LDKInit *NONNULL_PTR this_ptr);
/* @internal */
export function Init_get_features(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_get_features(this_ptr);
	return nativeResponseValue;
}
	// void Init_set_features(struct LDKInit *NONNULL_PTR this_ptr, struct LDKInitFeatures val);
/* @internal */
export function Init_set_features(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_set_features(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_CVec_ChainHashZZ Init_get_networks(const struct LDKInit *NONNULL_PTR this_ptr);
/* @internal */
export function Init_get_networks(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_get_networks(this_ptr);
	return nativeResponseValue;
}
	// void Init_set_networks(struct LDKInit *NONNULL_PTR this_ptr, struct LDKCOption_CVec_ChainHashZZ val);
/* @internal */
export function Init_set_networks(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_set_networks(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_NetAddressZ Init_get_remote_network_address(const struct LDKInit *NONNULL_PTR this_ptr);
/* @internal */
export function Init_get_remote_network_address(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_get_remote_network_address(this_ptr);
	return nativeResponseValue;
}
	// void Init_set_remote_network_address(struct LDKInit *NONNULL_PTR this_ptr, struct LDKCOption_NetAddressZ val);
/* @internal */
export function Init_set_remote_network_address(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_set_remote_network_address(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKInit Init_new(struct LDKInitFeatures features_arg, struct LDKCOption_CVec_ChainHashZZ networks_arg, struct LDKCOption_NetAddressZ remote_network_address_arg);
/* @internal */
export function Init_new(features_arg: bigint, networks_arg: bigint, remote_network_address_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_new(features_arg, networks_arg, remote_network_address_arg);
	return nativeResponseValue;
}
	// uint64_t Init_clone_ptr(LDKInit *NONNULL_PTR arg);
/* @internal */
export function Init_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKInit Init_clone(const struct LDKInit *NONNULL_PTR orig);
/* @internal */
export function Init_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_clone(orig);
	return nativeResponseValue;
}
	// bool Init_eq(const struct LDKInit *NONNULL_PTR a, const struct LDKInit *NONNULL_PTR b);
/* @internal */
export function Init_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_eq(a, b);
	return nativeResponseValue;
}
	// void ErrorMessage_free(struct LDKErrorMessage this_obj);
/* @internal */
export function ErrorMessage_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_free(this_obj);
	// debug statements here
}
	// const uint8_t (*ErrorMessage_get_channel_id(const struct LDKErrorMessage *NONNULL_PTR this_ptr))[32];
/* @internal */
export function ErrorMessage_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void ErrorMessage_set_channel_id(struct LDKErrorMessage *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function ErrorMessage_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_set_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKStr ErrorMessage_get_data(const struct LDKErrorMessage *NONNULL_PTR this_ptr);
/* @internal */
export function ErrorMessage_get_data(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_get_data(this_ptr);
	return nativeResponseValue;
}
	// void ErrorMessage_set_data(struct LDKErrorMessage *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */
export function ErrorMessage_set_data(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_set_data(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKErrorMessage ErrorMessage_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKStr data_arg);
/* @internal */
export function ErrorMessage_new(channel_id_arg: number, data_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_new(channel_id_arg, data_arg);
	return nativeResponseValue;
}
	// uint64_t ErrorMessage_clone_ptr(LDKErrorMessage *NONNULL_PTR arg);
/* @internal */
export function ErrorMessage_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKErrorMessage ErrorMessage_clone(const struct LDKErrorMessage *NONNULL_PTR orig);
/* @internal */
export function ErrorMessage_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_clone(orig);
	return nativeResponseValue;
}
	// bool ErrorMessage_eq(const struct LDKErrorMessage *NONNULL_PTR a, const struct LDKErrorMessage *NONNULL_PTR b);
/* @internal */
export function ErrorMessage_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_eq(a, b);
	return nativeResponseValue;
}
	// void WarningMessage_free(struct LDKWarningMessage this_obj);
/* @internal */
export function WarningMessage_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_free(this_obj);
	// debug statements here
}
	// const uint8_t (*WarningMessage_get_channel_id(const struct LDKWarningMessage *NONNULL_PTR this_ptr))[32];
/* @internal */
export function WarningMessage_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void WarningMessage_set_channel_id(struct LDKWarningMessage *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function WarningMessage_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_set_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKStr WarningMessage_get_data(const struct LDKWarningMessage *NONNULL_PTR this_ptr);
/* @internal */
export function WarningMessage_get_data(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_get_data(this_ptr);
	return nativeResponseValue;
}
	// void WarningMessage_set_data(struct LDKWarningMessage *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */
export function WarningMessage_set_data(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_set_data(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKWarningMessage WarningMessage_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKStr data_arg);
/* @internal */
export function WarningMessage_new(channel_id_arg: number, data_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_new(channel_id_arg, data_arg);
	return nativeResponseValue;
}
	// uint64_t WarningMessage_clone_ptr(LDKWarningMessage *NONNULL_PTR arg);
/* @internal */
export function WarningMessage_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKWarningMessage WarningMessage_clone(const struct LDKWarningMessage *NONNULL_PTR orig);
/* @internal */
export function WarningMessage_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_clone(orig);
	return nativeResponseValue;
}
	// bool WarningMessage_eq(const struct LDKWarningMessage *NONNULL_PTR a, const struct LDKWarningMessage *NONNULL_PTR b);
/* @internal */
export function WarningMessage_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_eq(a, b);
	return nativeResponseValue;
}
	// void Ping_free(struct LDKPing this_obj);
/* @internal */
export function Ping_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_free(this_obj);
	// debug statements here
}
	// uint16_t Ping_get_ponglen(const struct LDKPing *NONNULL_PTR this_ptr);
/* @internal */
export function Ping_get_ponglen(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_get_ponglen(this_ptr);
	return nativeResponseValue;
}
	// void Ping_set_ponglen(struct LDKPing *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function Ping_set_ponglen(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_set_ponglen(this_ptr, val);
	// debug statements here
}
	// uint16_t Ping_get_byteslen(const struct LDKPing *NONNULL_PTR this_ptr);
/* @internal */
export function Ping_get_byteslen(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_get_byteslen(this_ptr);
	return nativeResponseValue;
}
	// void Ping_set_byteslen(struct LDKPing *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function Ping_set_byteslen(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_set_byteslen(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKPing Ping_new(uint16_t ponglen_arg, uint16_t byteslen_arg);
/* @internal */
export function Ping_new(ponglen_arg: number, byteslen_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_new(ponglen_arg, byteslen_arg);
	return nativeResponseValue;
}
	// uint64_t Ping_clone_ptr(LDKPing *NONNULL_PTR arg);
/* @internal */
export function Ping_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPing Ping_clone(const struct LDKPing *NONNULL_PTR orig);
/* @internal */
export function Ping_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_clone(orig);
	return nativeResponseValue;
}
	// bool Ping_eq(const struct LDKPing *NONNULL_PTR a, const struct LDKPing *NONNULL_PTR b);
/* @internal */
export function Ping_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_eq(a, b);
	return nativeResponseValue;
}
	// void Pong_free(struct LDKPong this_obj);
/* @internal */
export function Pong_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Pong_free(this_obj);
	// debug statements here
}
	// uint16_t Pong_get_byteslen(const struct LDKPong *NONNULL_PTR this_ptr);
/* @internal */
export function Pong_get_byteslen(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Pong_get_byteslen(this_ptr);
	return nativeResponseValue;
}
	// void Pong_set_byteslen(struct LDKPong *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function Pong_set_byteslen(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Pong_set_byteslen(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKPong Pong_new(uint16_t byteslen_arg);
/* @internal */
export function Pong_new(byteslen_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Pong_new(byteslen_arg);
	return nativeResponseValue;
}
	// uint64_t Pong_clone_ptr(LDKPong *NONNULL_PTR arg);
/* @internal */
export function Pong_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Pong_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPong Pong_clone(const struct LDKPong *NONNULL_PTR orig);
/* @internal */
export function Pong_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Pong_clone(orig);
	return nativeResponseValue;
}
	// bool Pong_eq(const struct LDKPong *NONNULL_PTR a, const struct LDKPong *NONNULL_PTR b);
/* @internal */
export function Pong_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Pong_eq(a, b);
	return nativeResponseValue;
}
	// void OpenChannel_free(struct LDKOpenChannel this_obj);
/* @internal */
export function OpenChannel_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_free(this_obj);
	// debug statements here
}
	// const uint8_t (*OpenChannel_get_chain_hash(const struct LDKOpenChannel *NONNULL_PTR this_ptr))[32];
/* @internal */
export function OpenChannel_get_chain_hash(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_chain_hash(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_chain_hash(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function OpenChannel_set_chain_hash(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_chain_hash(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*OpenChannel_get_temporary_channel_id(const struct LDKOpenChannel *NONNULL_PTR this_ptr))[32];
/* @internal */
export function OpenChannel_get_temporary_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_temporary_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_temporary_channel_id(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function OpenChannel_set_temporary_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_temporary_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t OpenChannel_get_funding_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_funding_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_funding_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_funding_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function OpenChannel_set_funding_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_funding_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t OpenChannel_get_push_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_push_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_push_msat(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_push_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function OpenChannel_set_push_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_push_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t OpenChannel_get_dust_limit_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_dust_limit_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_dust_limit_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_dust_limit_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function OpenChannel_set_dust_limit_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_dust_limit_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t OpenChannel_get_max_htlc_value_in_flight_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_max_htlc_value_in_flight_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_max_htlc_value_in_flight_msat(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_max_htlc_value_in_flight_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function OpenChannel_set_max_htlc_value_in_flight_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_max_htlc_value_in_flight_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t OpenChannel_get_channel_reserve_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_channel_reserve_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_channel_reserve_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_channel_reserve_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function OpenChannel_set_channel_reserve_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_channel_reserve_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t OpenChannel_get_htlc_minimum_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_htlc_minimum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_htlc_minimum_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function OpenChannel_set_htlc_minimum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t OpenChannel_get_feerate_per_kw(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_feerate_per_kw(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_feerate_per_kw(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_feerate_per_kw(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function OpenChannel_set_feerate_per_kw(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_feerate_per_kw(this_ptr, val);
	// debug statements here
}
	// uint16_t OpenChannel_get_to_self_delay(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_to_self_delay(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_to_self_delay(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_to_self_delay(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function OpenChannel_set_to_self_delay(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_to_self_delay(this_ptr, val);
	// debug statements here
}
	// uint16_t OpenChannel_get_max_accepted_htlcs(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_max_accepted_htlcs(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_max_accepted_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_max_accepted_htlcs(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function OpenChannel_set_max_accepted_htlcs(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_max_accepted_htlcs(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannel_get_funding_pubkey(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_funding_pubkey(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_funding_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_funding_pubkey(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannel_set_funding_pubkey(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_funding_pubkey(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannel_get_revocation_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_revocation_basepoint(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_revocation_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_revocation_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannel_set_revocation_basepoint(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_revocation_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannel_get_payment_point(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_payment_point(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_payment_point(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_payment_point(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannel_set_payment_point(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_payment_point(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannel_get_delayed_payment_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_delayed_payment_basepoint(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_delayed_payment_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_delayed_payment_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannel_set_delayed_payment_basepoint(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_delayed_payment_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannel_get_htlc_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_htlc_basepoint(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_htlc_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_htlc_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannel_set_htlc_basepoint(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_htlc_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannel_get_first_per_commitment_point(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_first_per_commitment_point(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_first_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_first_per_commitment_point(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannel_set_first_per_commitment_point(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_first_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// uint8_t OpenChannel_get_channel_flags(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_channel_flags(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_channel_flags(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_channel_flags(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint8_t val);
/* @internal */
export function OpenChannel_set_channel_flags(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_channel_flags(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_ScriptZ OpenChannel_get_shutdown_scriptpubkey(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_shutdown_scriptpubkey(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_shutdown_scriptpubkey(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_shutdown_scriptpubkey(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKCOption_ScriptZ val);
/* @internal */
export function OpenChannel_set_shutdown_scriptpubkey(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_shutdown_scriptpubkey(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelTypeFeatures OpenChannel_get_channel_type(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_channel_type(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_channel_type(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_channel_type(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);
/* @internal */
export function OpenChannel_set_channel_type(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_channel_type(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKOpenChannel OpenChannel_new(struct LDKThirtyTwoBytes chain_hash_arg, struct LDKThirtyTwoBytes temporary_channel_id_arg, uint64_t funding_satoshis_arg, uint64_t push_msat_arg, uint64_t dust_limit_satoshis_arg, uint64_t max_htlc_value_in_flight_msat_arg, uint64_t channel_reserve_satoshis_arg, uint64_t htlc_minimum_msat_arg, uint32_t feerate_per_kw_arg, uint16_t to_self_delay_arg, uint16_t max_accepted_htlcs_arg, struct LDKPublicKey funding_pubkey_arg, struct LDKPublicKey revocation_basepoint_arg, struct LDKPublicKey payment_point_arg, struct LDKPublicKey delayed_payment_basepoint_arg, struct LDKPublicKey htlc_basepoint_arg, struct LDKPublicKey first_per_commitment_point_arg, uint8_t channel_flags_arg, struct LDKCOption_ScriptZ shutdown_scriptpubkey_arg, struct LDKChannelTypeFeatures channel_type_arg);
/* @internal */
export function OpenChannel_new(chain_hash_arg: number, temporary_channel_id_arg: number, funding_satoshis_arg: bigint, push_msat_arg: bigint, dust_limit_satoshis_arg: bigint, max_htlc_value_in_flight_msat_arg: bigint, channel_reserve_satoshis_arg: bigint, htlc_minimum_msat_arg: bigint, feerate_per_kw_arg: number, to_self_delay_arg: number, max_accepted_htlcs_arg: number, funding_pubkey_arg: number, revocation_basepoint_arg: number, payment_point_arg: number, delayed_payment_basepoint_arg: number, htlc_basepoint_arg: number, first_per_commitment_point_arg: number, channel_flags_arg: number, shutdown_scriptpubkey_arg: bigint, channel_type_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_new(chain_hash_arg, temporary_channel_id_arg, funding_satoshis_arg, push_msat_arg, dust_limit_satoshis_arg, max_htlc_value_in_flight_msat_arg, channel_reserve_satoshis_arg, htlc_minimum_msat_arg, feerate_per_kw_arg, to_self_delay_arg, max_accepted_htlcs_arg, funding_pubkey_arg, revocation_basepoint_arg, payment_point_arg, delayed_payment_basepoint_arg, htlc_basepoint_arg, first_per_commitment_point_arg, channel_flags_arg, shutdown_scriptpubkey_arg, channel_type_arg);
	return nativeResponseValue;
}
	// uint64_t OpenChannel_clone_ptr(LDKOpenChannel *NONNULL_PTR arg);
/* @internal */
export function OpenChannel_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKOpenChannel OpenChannel_clone(const struct LDKOpenChannel *NONNULL_PTR orig);
/* @internal */
export function OpenChannel_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_clone(orig);
	return nativeResponseValue;
}
	// bool OpenChannel_eq(const struct LDKOpenChannel *NONNULL_PTR a, const struct LDKOpenChannel *NONNULL_PTR b);
/* @internal */
export function OpenChannel_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_eq(a, b);
	return nativeResponseValue;
}
	// void OpenChannelV2_free(struct LDKOpenChannelV2 this_obj);
/* @internal */
export function OpenChannelV2_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_free(this_obj);
	// debug statements here
}
	// const uint8_t (*OpenChannelV2_get_chain_hash(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr))[32];
/* @internal */
export function OpenChannelV2_get_chain_hash(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_chain_hash(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_chain_hash(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function OpenChannelV2_set_chain_hash(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_chain_hash(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*OpenChannelV2_get_temporary_channel_id(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr))[32];
/* @internal */
export function OpenChannelV2_get_temporary_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_temporary_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_temporary_channel_id(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function OpenChannelV2_set_temporary_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_temporary_channel_id(this_ptr, val);
	// debug statements here
}
	// uint32_t OpenChannelV2_get_funding_feerate_sat_per_1000_weight(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_funding_feerate_sat_per_1000_weight(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_funding_feerate_sat_per_1000_weight(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_funding_feerate_sat_per_1000_weight(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function OpenChannelV2_set_funding_feerate_sat_per_1000_weight(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_funding_feerate_sat_per_1000_weight(this_ptr, val);
	// debug statements here
}
	// uint32_t OpenChannelV2_get_commitment_feerate_sat_per_1000_weight(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_commitment_feerate_sat_per_1000_weight(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_commitment_feerate_sat_per_1000_weight(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_commitment_feerate_sat_per_1000_weight(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function OpenChannelV2_set_commitment_feerate_sat_per_1000_weight(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_commitment_feerate_sat_per_1000_weight(this_ptr, val);
	// debug statements here
}
	// uint64_t OpenChannelV2_get_funding_satoshis(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_funding_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_funding_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_funding_satoshis(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function OpenChannelV2_set_funding_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_funding_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t OpenChannelV2_get_dust_limit_satoshis(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_dust_limit_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_dust_limit_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_dust_limit_satoshis(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function OpenChannelV2_set_dust_limit_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_dust_limit_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t OpenChannelV2_get_max_htlc_value_in_flight_msat(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_max_htlc_value_in_flight_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_max_htlc_value_in_flight_msat(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_max_htlc_value_in_flight_msat(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function OpenChannelV2_set_max_htlc_value_in_flight_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_max_htlc_value_in_flight_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t OpenChannelV2_get_htlc_minimum_msat(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_htlc_minimum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_htlc_minimum_msat(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function OpenChannelV2_set_htlc_minimum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// uint16_t OpenChannelV2_get_to_self_delay(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_to_self_delay(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_to_self_delay(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_to_self_delay(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function OpenChannelV2_set_to_self_delay(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_to_self_delay(this_ptr, val);
	// debug statements here
}
	// uint16_t OpenChannelV2_get_max_accepted_htlcs(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_max_accepted_htlcs(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_max_accepted_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_max_accepted_htlcs(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function OpenChannelV2_set_max_accepted_htlcs(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_max_accepted_htlcs(this_ptr, val);
	// debug statements here
}
	// uint32_t OpenChannelV2_get_locktime(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_locktime(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_locktime(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_locktime(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function OpenChannelV2_set_locktime(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_locktime(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannelV2_get_funding_pubkey(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_funding_pubkey(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_funding_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_funding_pubkey(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannelV2_set_funding_pubkey(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_funding_pubkey(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannelV2_get_revocation_basepoint(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_revocation_basepoint(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_revocation_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_revocation_basepoint(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannelV2_set_revocation_basepoint(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_revocation_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannelV2_get_payment_basepoint(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_payment_basepoint(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_payment_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_payment_basepoint(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannelV2_set_payment_basepoint(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_payment_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannelV2_get_delayed_payment_basepoint(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_delayed_payment_basepoint(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_delayed_payment_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_delayed_payment_basepoint(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannelV2_set_delayed_payment_basepoint(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_delayed_payment_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannelV2_get_htlc_basepoint(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_htlc_basepoint(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_htlc_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_htlc_basepoint(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannelV2_set_htlc_basepoint(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_htlc_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannelV2_get_first_per_commitment_point(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_first_per_commitment_point(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_first_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_first_per_commitment_point(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannelV2_set_first_per_commitment_point(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_first_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannelV2_get_second_per_commitment_point(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_second_per_commitment_point(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_second_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_second_per_commitment_point(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannelV2_set_second_per_commitment_point(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_second_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// uint8_t OpenChannelV2_get_channel_flags(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_channel_flags(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_channel_flags(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_channel_flags(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint8_t val);
/* @internal */
export function OpenChannelV2_set_channel_flags(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_channel_flags(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_ScriptZ OpenChannelV2_get_shutdown_scriptpubkey(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_shutdown_scriptpubkey(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_shutdown_scriptpubkey(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_shutdown_scriptpubkey(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKCOption_ScriptZ val);
/* @internal */
export function OpenChannelV2_set_shutdown_scriptpubkey(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_shutdown_scriptpubkey(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelTypeFeatures OpenChannelV2_get_channel_type(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_channel_type(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_channel_type(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_channel_type(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);
/* @internal */
export function OpenChannelV2_set_channel_type(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_channel_type(this_ptr, val);
	// debug statements here
}
	// enum LDKCOption_NoneZ OpenChannelV2_get_require_confirmed_inputs(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannelV2_get_require_confirmed_inputs(this_ptr: bigint): COption_NoneZ {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_get_require_confirmed_inputs(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannelV2_set_require_confirmed_inputs(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, enum LDKCOption_NoneZ val);
/* @internal */
export function OpenChannelV2_set_require_confirmed_inputs(this_ptr: bigint, val: COption_NoneZ): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_set_require_confirmed_inputs(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKOpenChannelV2 OpenChannelV2_new(struct LDKThirtyTwoBytes chain_hash_arg, struct LDKThirtyTwoBytes temporary_channel_id_arg, uint32_t funding_feerate_sat_per_1000_weight_arg, uint32_t commitment_feerate_sat_per_1000_weight_arg, uint64_t funding_satoshis_arg, uint64_t dust_limit_satoshis_arg, uint64_t max_htlc_value_in_flight_msat_arg, uint64_t htlc_minimum_msat_arg, uint16_t to_self_delay_arg, uint16_t max_accepted_htlcs_arg, uint32_t locktime_arg, struct LDKPublicKey funding_pubkey_arg, struct LDKPublicKey revocation_basepoint_arg, struct LDKPublicKey payment_basepoint_arg, struct LDKPublicKey delayed_payment_basepoint_arg, struct LDKPublicKey htlc_basepoint_arg, struct LDKPublicKey first_per_commitment_point_arg, struct LDKPublicKey second_per_commitment_point_arg, uint8_t channel_flags_arg, struct LDKCOption_ScriptZ shutdown_scriptpubkey_arg, struct LDKChannelTypeFeatures channel_type_arg, enum LDKCOption_NoneZ require_confirmed_inputs_arg);
/* @internal */
export function OpenChannelV2_new(chain_hash_arg: number, temporary_channel_id_arg: number, funding_feerate_sat_per_1000_weight_arg: number, commitment_feerate_sat_per_1000_weight_arg: number, funding_satoshis_arg: bigint, dust_limit_satoshis_arg: bigint, max_htlc_value_in_flight_msat_arg: bigint, htlc_minimum_msat_arg: bigint, to_self_delay_arg: number, max_accepted_htlcs_arg: number, locktime_arg: number, funding_pubkey_arg: number, revocation_basepoint_arg: number, payment_basepoint_arg: number, delayed_payment_basepoint_arg: number, htlc_basepoint_arg: number, first_per_commitment_point_arg: number, second_per_commitment_point_arg: number, channel_flags_arg: number, shutdown_scriptpubkey_arg: bigint, channel_type_arg: bigint, require_confirmed_inputs_arg: COption_NoneZ): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_new(chain_hash_arg, temporary_channel_id_arg, funding_feerate_sat_per_1000_weight_arg, commitment_feerate_sat_per_1000_weight_arg, funding_satoshis_arg, dust_limit_satoshis_arg, max_htlc_value_in_flight_msat_arg, htlc_minimum_msat_arg, to_self_delay_arg, max_accepted_htlcs_arg, locktime_arg, funding_pubkey_arg, revocation_basepoint_arg, payment_basepoint_arg, delayed_payment_basepoint_arg, htlc_basepoint_arg, first_per_commitment_point_arg, second_per_commitment_point_arg, channel_flags_arg, shutdown_scriptpubkey_arg, channel_type_arg, require_confirmed_inputs_arg);
	return nativeResponseValue;
}
	// uint64_t OpenChannelV2_clone_ptr(LDKOpenChannelV2 *NONNULL_PTR arg);
/* @internal */
export function OpenChannelV2_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKOpenChannelV2 OpenChannelV2_clone(const struct LDKOpenChannelV2 *NONNULL_PTR orig);
/* @internal */
export function OpenChannelV2_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_clone(orig);
	return nativeResponseValue;
}
	// bool OpenChannelV2_eq(const struct LDKOpenChannelV2 *NONNULL_PTR a, const struct LDKOpenChannelV2 *NONNULL_PTR b);
/* @internal */
export function OpenChannelV2_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_eq(a, b);
	return nativeResponseValue;
}
	// void AcceptChannel_free(struct LDKAcceptChannel this_obj);
/* @internal */
export function AcceptChannel_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_free(this_obj);
	// debug statements here
}
	// const uint8_t (*AcceptChannel_get_temporary_channel_id(const struct LDKAcceptChannel *NONNULL_PTR this_ptr))[32];
/* @internal */
export function AcceptChannel_get_temporary_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_temporary_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_temporary_channel_id(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function AcceptChannel_set_temporary_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_temporary_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t AcceptChannel_get_dust_limit_satoshis(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_dust_limit_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_dust_limit_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_dust_limit_satoshis(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function AcceptChannel_set_dust_limit_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_dust_limit_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t AcceptChannel_get_max_htlc_value_in_flight_msat(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_max_htlc_value_in_flight_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_max_htlc_value_in_flight_msat(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_max_htlc_value_in_flight_msat(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function AcceptChannel_set_max_htlc_value_in_flight_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_max_htlc_value_in_flight_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t AcceptChannel_get_channel_reserve_satoshis(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_channel_reserve_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_channel_reserve_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_channel_reserve_satoshis(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function AcceptChannel_set_channel_reserve_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_channel_reserve_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t AcceptChannel_get_htlc_minimum_msat(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_htlc_minimum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_htlc_minimum_msat(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function AcceptChannel_set_htlc_minimum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t AcceptChannel_get_minimum_depth(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_minimum_depth(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_minimum_depth(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_minimum_depth(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function AcceptChannel_set_minimum_depth(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_minimum_depth(this_ptr, val);
	// debug statements here
}
	// uint16_t AcceptChannel_get_to_self_delay(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_to_self_delay(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_to_self_delay(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_to_self_delay(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function AcceptChannel_set_to_self_delay(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_to_self_delay(this_ptr, val);
	// debug statements here
}
	// uint16_t AcceptChannel_get_max_accepted_htlcs(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_max_accepted_htlcs(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_max_accepted_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_max_accepted_htlcs(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function AcceptChannel_set_max_accepted_htlcs(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_max_accepted_htlcs(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannel_get_funding_pubkey(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_funding_pubkey(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_funding_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_funding_pubkey(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannel_set_funding_pubkey(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_funding_pubkey(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannel_get_revocation_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_revocation_basepoint(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_revocation_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_revocation_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannel_set_revocation_basepoint(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_revocation_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannel_get_payment_point(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_payment_point(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_payment_point(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_payment_point(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannel_set_payment_point(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_payment_point(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannel_get_delayed_payment_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_delayed_payment_basepoint(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_delayed_payment_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_delayed_payment_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannel_set_delayed_payment_basepoint(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_delayed_payment_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannel_get_htlc_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_htlc_basepoint(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_htlc_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_htlc_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannel_set_htlc_basepoint(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_htlc_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannel_get_first_per_commitment_point(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_first_per_commitment_point(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_first_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_first_per_commitment_point(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannel_set_first_per_commitment_point(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_first_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_ScriptZ AcceptChannel_get_shutdown_scriptpubkey(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_shutdown_scriptpubkey(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_shutdown_scriptpubkey(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_shutdown_scriptpubkey(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKCOption_ScriptZ val);
/* @internal */
export function AcceptChannel_set_shutdown_scriptpubkey(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_shutdown_scriptpubkey(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelTypeFeatures AcceptChannel_get_channel_type(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_channel_type(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_channel_type(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_channel_type(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);
/* @internal */
export function AcceptChannel_set_channel_type(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_channel_type(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKAcceptChannel AcceptChannel_new(struct LDKThirtyTwoBytes temporary_channel_id_arg, uint64_t dust_limit_satoshis_arg, uint64_t max_htlc_value_in_flight_msat_arg, uint64_t channel_reserve_satoshis_arg, uint64_t htlc_minimum_msat_arg, uint32_t minimum_depth_arg, uint16_t to_self_delay_arg, uint16_t max_accepted_htlcs_arg, struct LDKPublicKey funding_pubkey_arg, struct LDKPublicKey revocation_basepoint_arg, struct LDKPublicKey payment_point_arg, struct LDKPublicKey delayed_payment_basepoint_arg, struct LDKPublicKey htlc_basepoint_arg, struct LDKPublicKey first_per_commitment_point_arg, struct LDKCOption_ScriptZ shutdown_scriptpubkey_arg, struct LDKChannelTypeFeatures channel_type_arg);
/* @internal */
export function AcceptChannel_new(temporary_channel_id_arg: number, dust_limit_satoshis_arg: bigint, max_htlc_value_in_flight_msat_arg: bigint, channel_reserve_satoshis_arg: bigint, htlc_minimum_msat_arg: bigint, minimum_depth_arg: number, to_self_delay_arg: number, max_accepted_htlcs_arg: number, funding_pubkey_arg: number, revocation_basepoint_arg: number, payment_point_arg: number, delayed_payment_basepoint_arg: number, htlc_basepoint_arg: number, first_per_commitment_point_arg: number, shutdown_scriptpubkey_arg: bigint, channel_type_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_new(temporary_channel_id_arg, dust_limit_satoshis_arg, max_htlc_value_in_flight_msat_arg, channel_reserve_satoshis_arg, htlc_minimum_msat_arg, minimum_depth_arg, to_self_delay_arg, max_accepted_htlcs_arg, funding_pubkey_arg, revocation_basepoint_arg, payment_point_arg, delayed_payment_basepoint_arg, htlc_basepoint_arg, first_per_commitment_point_arg, shutdown_scriptpubkey_arg, channel_type_arg);
	return nativeResponseValue;
}
	// uint64_t AcceptChannel_clone_ptr(LDKAcceptChannel *NONNULL_PTR arg);
/* @internal */
export function AcceptChannel_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKAcceptChannel AcceptChannel_clone(const struct LDKAcceptChannel *NONNULL_PTR orig);
/* @internal */
export function AcceptChannel_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_clone(orig);
	return nativeResponseValue;
}
	// bool AcceptChannel_eq(const struct LDKAcceptChannel *NONNULL_PTR a, const struct LDKAcceptChannel *NONNULL_PTR b);
/* @internal */
export function AcceptChannel_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_eq(a, b);
	return nativeResponseValue;
}
	// void AcceptChannelV2_free(struct LDKAcceptChannelV2 this_obj);
/* @internal */
export function AcceptChannelV2_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_free(this_obj);
	// debug statements here
}
	// const uint8_t (*AcceptChannelV2_get_temporary_channel_id(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr))[32];
/* @internal */
export function AcceptChannelV2_get_temporary_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_temporary_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_temporary_channel_id(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function AcceptChannelV2_set_temporary_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_temporary_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t AcceptChannelV2_get_funding_satoshis(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannelV2_get_funding_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_funding_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_funding_satoshis(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function AcceptChannelV2_set_funding_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_funding_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t AcceptChannelV2_get_dust_limit_satoshis(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannelV2_get_dust_limit_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_dust_limit_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_dust_limit_satoshis(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function AcceptChannelV2_set_dust_limit_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_dust_limit_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t AcceptChannelV2_get_max_htlc_value_in_flight_msat(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannelV2_get_max_htlc_value_in_flight_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_max_htlc_value_in_flight_msat(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_max_htlc_value_in_flight_msat(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function AcceptChannelV2_set_max_htlc_value_in_flight_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_max_htlc_value_in_flight_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t AcceptChannelV2_get_htlc_minimum_msat(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannelV2_get_htlc_minimum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_htlc_minimum_msat(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function AcceptChannelV2_set_htlc_minimum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t AcceptChannelV2_get_minimum_depth(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannelV2_get_minimum_depth(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_minimum_depth(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_minimum_depth(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function AcceptChannelV2_set_minimum_depth(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_minimum_depth(this_ptr, val);
	// debug statements here
}
	// uint16_t AcceptChannelV2_get_to_self_delay(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannelV2_get_to_self_delay(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_to_self_delay(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_to_self_delay(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function AcceptChannelV2_set_to_self_delay(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_to_self_delay(this_ptr, val);
	// debug statements here
}
	// uint16_t AcceptChannelV2_get_max_accepted_htlcs(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannelV2_get_max_accepted_htlcs(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_max_accepted_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_max_accepted_htlcs(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function AcceptChannelV2_set_max_accepted_htlcs(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_max_accepted_htlcs(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannelV2_get_funding_pubkey(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannelV2_get_funding_pubkey(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_funding_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_funding_pubkey(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannelV2_set_funding_pubkey(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_funding_pubkey(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannelV2_get_revocation_basepoint(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannelV2_get_revocation_basepoint(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_revocation_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_revocation_basepoint(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannelV2_set_revocation_basepoint(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_revocation_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannelV2_get_payment_basepoint(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannelV2_get_payment_basepoint(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_payment_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_payment_basepoint(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannelV2_set_payment_basepoint(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_payment_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannelV2_get_delayed_payment_basepoint(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannelV2_get_delayed_payment_basepoint(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_delayed_payment_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_delayed_payment_basepoint(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannelV2_set_delayed_payment_basepoint(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_delayed_payment_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannelV2_get_htlc_basepoint(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannelV2_get_htlc_basepoint(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_htlc_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_htlc_basepoint(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannelV2_set_htlc_basepoint(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_htlc_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannelV2_get_first_per_commitment_point(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannelV2_get_first_per_commitment_point(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_first_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_first_per_commitment_point(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannelV2_set_first_per_commitment_point(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_first_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannelV2_get_second_per_commitment_point(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannelV2_get_second_per_commitment_point(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_second_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_second_per_commitment_point(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannelV2_set_second_per_commitment_point(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_second_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_ScriptZ AcceptChannelV2_get_shutdown_scriptpubkey(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannelV2_get_shutdown_scriptpubkey(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_shutdown_scriptpubkey(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_shutdown_scriptpubkey(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKCOption_ScriptZ val);
/* @internal */
export function AcceptChannelV2_set_shutdown_scriptpubkey(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_shutdown_scriptpubkey(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelTypeFeatures AcceptChannelV2_get_channel_type(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannelV2_get_channel_type(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_channel_type(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_channel_type(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);
/* @internal */
export function AcceptChannelV2_set_channel_type(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_channel_type(this_ptr, val);
	// debug statements here
}
	// enum LDKCOption_NoneZ AcceptChannelV2_get_require_confirmed_inputs(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannelV2_get_require_confirmed_inputs(this_ptr: bigint): COption_NoneZ {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_get_require_confirmed_inputs(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannelV2_set_require_confirmed_inputs(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, enum LDKCOption_NoneZ val);
/* @internal */
export function AcceptChannelV2_set_require_confirmed_inputs(this_ptr: bigint, val: COption_NoneZ): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_set_require_confirmed_inputs(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKAcceptChannelV2 AcceptChannelV2_new(struct LDKThirtyTwoBytes temporary_channel_id_arg, uint64_t funding_satoshis_arg, uint64_t dust_limit_satoshis_arg, uint64_t max_htlc_value_in_flight_msat_arg, uint64_t htlc_minimum_msat_arg, uint32_t minimum_depth_arg, uint16_t to_self_delay_arg, uint16_t max_accepted_htlcs_arg, struct LDKPublicKey funding_pubkey_arg, struct LDKPublicKey revocation_basepoint_arg, struct LDKPublicKey payment_basepoint_arg, struct LDKPublicKey delayed_payment_basepoint_arg, struct LDKPublicKey htlc_basepoint_arg, struct LDKPublicKey first_per_commitment_point_arg, struct LDKPublicKey second_per_commitment_point_arg, struct LDKCOption_ScriptZ shutdown_scriptpubkey_arg, struct LDKChannelTypeFeatures channel_type_arg, enum LDKCOption_NoneZ require_confirmed_inputs_arg);
/* @internal */
export function AcceptChannelV2_new(temporary_channel_id_arg: number, funding_satoshis_arg: bigint, dust_limit_satoshis_arg: bigint, max_htlc_value_in_flight_msat_arg: bigint, htlc_minimum_msat_arg: bigint, minimum_depth_arg: number, to_self_delay_arg: number, max_accepted_htlcs_arg: number, funding_pubkey_arg: number, revocation_basepoint_arg: number, payment_basepoint_arg: number, delayed_payment_basepoint_arg: number, htlc_basepoint_arg: number, first_per_commitment_point_arg: number, second_per_commitment_point_arg: number, shutdown_scriptpubkey_arg: bigint, channel_type_arg: bigint, require_confirmed_inputs_arg: COption_NoneZ): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_new(temporary_channel_id_arg, funding_satoshis_arg, dust_limit_satoshis_arg, max_htlc_value_in_flight_msat_arg, htlc_minimum_msat_arg, minimum_depth_arg, to_self_delay_arg, max_accepted_htlcs_arg, funding_pubkey_arg, revocation_basepoint_arg, payment_basepoint_arg, delayed_payment_basepoint_arg, htlc_basepoint_arg, first_per_commitment_point_arg, second_per_commitment_point_arg, shutdown_scriptpubkey_arg, channel_type_arg, require_confirmed_inputs_arg);
	return nativeResponseValue;
}
	// uint64_t AcceptChannelV2_clone_ptr(LDKAcceptChannelV2 *NONNULL_PTR arg);
/* @internal */
export function AcceptChannelV2_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKAcceptChannelV2 AcceptChannelV2_clone(const struct LDKAcceptChannelV2 *NONNULL_PTR orig);
/* @internal */
export function AcceptChannelV2_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_clone(orig);
	return nativeResponseValue;
}
	// bool AcceptChannelV2_eq(const struct LDKAcceptChannelV2 *NONNULL_PTR a, const struct LDKAcceptChannelV2 *NONNULL_PTR b);
/* @internal */
export function AcceptChannelV2_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_eq(a, b);
	return nativeResponseValue;
}
	// void FundingCreated_free(struct LDKFundingCreated this_obj);
/* @internal */
export function FundingCreated_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_free(this_obj);
	// debug statements here
}
	// const uint8_t (*FundingCreated_get_temporary_channel_id(const struct LDKFundingCreated *NONNULL_PTR this_ptr))[32];
/* @internal */
export function FundingCreated_get_temporary_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_get_temporary_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void FundingCreated_set_temporary_channel_id(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function FundingCreated_set_temporary_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_set_temporary_channel_id(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*FundingCreated_get_funding_txid(const struct LDKFundingCreated *NONNULL_PTR this_ptr))[32];
/* @internal */
export function FundingCreated_get_funding_txid(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_get_funding_txid(this_ptr);
	return nativeResponseValue;
}
	// void FundingCreated_set_funding_txid(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function FundingCreated_set_funding_txid(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_set_funding_txid(this_ptr, val);
	// debug statements here
}
	// uint16_t FundingCreated_get_funding_output_index(const struct LDKFundingCreated *NONNULL_PTR this_ptr);
/* @internal */
export function FundingCreated_get_funding_output_index(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_get_funding_output_index(this_ptr);
	return nativeResponseValue;
}
	// void FundingCreated_set_funding_output_index(struct LDKFundingCreated *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function FundingCreated_set_funding_output_index(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_set_funding_output_index(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature FundingCreated_get_signature(const struct LDKFundingCreated *NONNULL_PTR this_ptr);
/* @internal */
export function FundingCreated_get_signature(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_get_signature(this_ptr);
	return nativeResponseValue;
}
	// void FundingCreated_set_signature(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function FundingCreated_set_signature(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_set_signature(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKFundingCreated FundingCreated_new(struct LDKThirtyTwoBytes temporary_channel_id_arg, struct LDKThirtyTwoBytes funding_txid_arg, uint16_t funding_output_index_arg, struct LDKSignature signature_arg);
/* @internal */
export function FundingCreated_new(temporary_channel_id_arg: number, funding_txid_arg: number, funding_output_index_arg: number, signature_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_new(temporary_channel_id_arg, funding_txid_arg, funding_output_index_arg, signature_arg);
	return nativeResponseValue;
}
	// uint64_t FundingCreated_clone_ptr(LDKFundingCreated *NONNULL_PTR arg);
/* @internal */
export function FundingCreated_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKFundingCreated FundingCreated_clone(const struct LDKFundingCreated *NONNULL_PTR orig);
/* @internal */
export function FundingCreated_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_clone(orig);
	return nativeResponseValue;
}
	// bool FundingCreated_eq(const struct LDKFundingCreated *NONNULL_PTR a, const struct LDKFundingCreated *NONNULL_PTR b);
/* @internal */
export function FundingCreated_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_eq(a, b);
	return nativeResponseValue;
}
	// void FundingSigned_free(struct LDKFundingSigned this_obj);
/* @internal */
export function FundingSigned_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_free(this_obj);
	// debug statements here
}
	// const uint8_t (*FundingSigned_get_channel_id(const struct LDKFundingSigned *NONNULL_PTR this_ptr))[32];
/* @internal */
export function FundingSigned_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void FundingSigned_set_channel_id(struct LDKFundingSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function FundingSigned_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_set_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature FundingSigned_get_signature(const struct LDKFundingSigned *NONNULL_PTR this_ptr);
/* @internal */
export function FundingSigned_get_signature(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_get_signature(this_ptr);
	return nativeResponseValue;
}
	// void FundingSigned_set_signature(struct LDKFundingSigned *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function FundingSigned_set_signature(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_set_signature(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKFundingSigned FundingSigned_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKSignature signature_arg);
/* @internal */
export function FundingSigned_new(channel_id_arg: number, signature_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_new(channel_id_arg, signature_arg);
	return nativeResponseValue;
}
	// uint64_t FundingSigned_clone_ptr(LDKFundingSigned *NONNULL_PTR arg);
/* @internal */
export function FundingSigned_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKFundingSigned FundingSigned_clone(const struct LDKFundingSigned *NONNULL_PTR orig);
/* @internal */
export function FundingSigned_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_clone(orig);
	return nativeResponseValue;
}
	// bool FundingSigned_eq(const struct LDKFundingSigned *NONNULL_PTR a, const struct LDKFundingSigned *NONNULL_PTR b);
/* @internal */
export function FundingSigned_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_eq(a, b);
	return nativeResponseValue;
}
	// void ChannelReady_free(struct LDKChannelReady this_obj);
/* @internal */
export function ChannelReady_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReady_free(this_obj);
	// debug statements here
}
	// const uint8_t (*ChannelReady_get_channel_id(const struct LDKChannelReady *NONNULL_PTR this_ptr))[32];
/* @internal */
export function ChannelReady_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReady_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void ChannelReady_set_channel_id(struct LDKChannelReady *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function ChannelReady_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReady_set_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey ChannelReady_get_next_per_commitment_point(const struct LDKChannelReady *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelReady_get_next_per_commitment_point(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReady_get_next_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void ChannelReady_set_next_per_commitment_point(struct LDKChannelReady *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function ChannelReady_set_next_per_commitment_point(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReady_set_next_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z ChannelReady_get_short_channel_id_alias(const struct LDKChannelReady *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelReady_get_short_channel_id_alias(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReady_get_short_channel_id_alias(this_ptr);
	return nativeResponseValue;
}
	// void ChannelReady_set_short_channel_id_alias(struct LDKChannelReady *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function ChannelReady_set_short_channel_id_alias(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReady_set_short_channel_id_alias(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelReady ChannelReady_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKPublicKey next_per_commitment_point_arg, struct LDKCOption_u64Z short_channel_id_alias_arg);
/* @internal */
export function ChannelReady_new(channel_id_arg: number, next_per_commitment_point_arg: number, short_channel_id_alias_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReady_new(channel_id_arg, next_per_commitment_point_arg, short_channel_id_alias_arg);
	return nativeResponseValue;
}
	// uint64_t ChannelReady_clone_ptr(LDKChannelReady *NONNULL_PTR arg);
/* @internal */
export function ChannelReady_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReady_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelReady ChannelReady_clone(const struct LDKChannelReady *NONNULL_PTR orig);
/* @internal */
export function ChannelReady_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReady_clone(orig);
	return nativeResponseValue;
}
	// bool ChannelReady_eq(const struct LDKChannelReady *NONNULL_PTR a, const struct LDKChannelReady *NONNULL_PTR b);
/* @internal */
export function ChannelReady_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReady_eq(a, b);
	return nativeResponseValue;
}
	// void TxAddInput_free(struct LDKTxAddInput this_obj);
/* @internal */
export function TxAddInput_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddInput_free(this_obj);
	// debug statements here
}
	// const uint8_t (*TxAddInput_get_channel_id(const struct LDKTxAddInput *NONNULL_PTR this_ptr))[32];
/* @internal */
export function TxAddInput_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddInput_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void TxAddInput_set_channel_id(struct LDKTxAddInput *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function TxAddInput_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddInput_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t TxAddInput_get_serial_id(const struct LDKTxAddInput *NONNULL_PTR this_ptr);
/* @internal */
export function TxAddInput_get_serial_id(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddInput_get_serial_id(this_ptr);
	return nativeResponseValue;
}
	// void TxAddInput_set_serial_id(struct LDKTxAddInput *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function TxAddInput_set_serial_id(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddInput_set_serial_id(this_ptr, val);
	// debug statements here
}
	// struct LDKTransactionU16LenLimited TxAddInput_get_prevtx(const struct LDKTxAddInput *NONNULL_PTR this_ptr);
/* @internal */
export function TxAddInput_get_prevtx(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddInput_get_prevtx(this_ptr);
	return nativeResponseValue;
}
	// void TxAddInput_set_prevtx(struct LDKTxAddInput *NONNULL_PTR this_ptr, struct LDKTransactionU16LenLimited val);
/* @internal */
export function TxAddInput_set_prevtx(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddInput_set_prevtx(this_ptr, val);
	// debug statements here
}
	// uint32_t TxAddInput_get_prevtx_out(const struct LDKTxAddInput *NONNULL_PTR this_ptr);
/* @internal */
export function TxAddInput_get_prevtx_out(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddInput_get_prevtx_out(this_ptr);
	return nativeResponseValue;
}
	// void TxAddInput_set_prevtx_out(struct LDKTxAddInput *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function TxAddInput_set_prevtx_out(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddInput_set_prevtx_out(this_ptr, val);
	// debug statements here
}
	// uint32_t TxAddInput_get_sequence(const struct LDKTxAddInput *NONNULL_PTR this_ptr);
/* @internal */
export function TxAddInput_get_sequence(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddInput_get_sequence(this_ptr);
	return nativeResponseValue;
}
	// void TxAddInput_set_sequence(struct LDKTxAddInput *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function TxAddInput_set_sequence(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddInput_set_sequence(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKTxAddInput TxAddInput_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t serial_id_arg, struct LDKTransactionU16LenLimited prevtx_arg, uint32_t prevtx_out_arg, uint32_t sequence_arg);
/* @internal */
export function TxAddInput_new(channel_id_arg: number, serial_id_arg: bigint, prevtx_arg: bigint, prevtx_out_arg: number, sequence_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddInput_new(channel_id_arg, serial_id_arg, prevtx_arg, prevtx_out_arg, sequence_arg);
	return nativeResponseValue;
}
	// uint64_t TxAddInput_clone_ptr(LDKTxAddInput *NONNULL_PTR arg);
/* @internal */
export function TxAddInput_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddInput_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKTxAddInput TxAddInput_clone(const struct LDKTxAddInput *NONNULL_PTR orig);
/* @internal */
export function TxAddInput_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddInput_clone(orig);
	return nativeResponseValue;
}
	// bool TxAddInput_eq(const struct LDKTxAddInput *NONNULL_PTR a, const struct LDKTxAddInput *NONNULL_PTR b);
/* @internal */
export function TxAddInput_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddInput_eq(a, b);
	return nativeResponseValue;
}
	// void TxAddOutput_free(struct LDKTxAddOutput this_obj);
/* @internal */
export function TxAddOutput_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddOutput_free(this_obj);
	// debug statements here
}
	// const uint8_t (*TxAddOutput_get_channel_id(const struct LDKTxAddOutput *NONNULL_PTR this_ptr))[32];
/* @internal */
export function TxAddOutput_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddOutput_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void TxAddOutput_set_channel_id(struct LDKTxAddOutput *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function TxAddOutput_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddOutput_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t TxAddOutput_get_serial_id(const struct LDKTxAddOutput *NONNULL_PTR this_ptr);
/* @internal */
export function TxAddOutput_get_serial_id(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddOutput_get_serial_id(this_ptr);
	return nativeResponseValue;
}
	// void TxAddOutput_set_serial_id(struct LDKTxAddOutput *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function TxAddOutput_set_serial_id(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddOutput_set_serial_id(this_ptr, val);
	// debug statements here
}
	// uint64_t TxAddOutput_get_sats(const struct LDKTxAddOutput *NONNULL_PTR this_ptr);
/* @internal */
export function TxAddOutput_get_sats(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddOutput_get_sats(this_ptr);
	return nativeResponseValue;
}
	// void TxAddOutput_set_sats(struct LDKTxAddOutput *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function TxAddOutput_set_sats(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddOutput_set_sats(this_ptr, val);
	// debug statements here
}
	// struct LDKu8slice TxAddOutput_get_script(const struct LDKTxAddOutput *NONNULL_PTR this_ptr);
/* @internal */
export function TxAddOutput_get_script(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddOutput_get_script(this_ptr);
	return nativeResponseValue;
}
	// void TxAddOutput_set_script(struct LDKTxAddOutput *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);
/* @internal */
export function TxAddOutput_set_script(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddOutput_set_script(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKTxAddOutput TxAddOutput_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t serial_id_arg, uint64_t sats_arg, struct LDKCVec_u8Z script_arg);
/* @internal */
export function TxAddOutput_new(channel_id_arg: number, serial_id_arg: bigint, sats_arg: bigint, script_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddOutput_new(channel_id_arg, serial_id_arg, sats_arg, script_arg);
	return nativeResponseValue;
}
	// uint64_t TxAddOutput_clone_ptr(LDKTxAddOutput *NONNULL_PTR arg);
/* @internal */
export function TxAddOutput_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddOutput_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKTxAddOutput TxAddOutput_clone(const struct LDKTxAddOutput *NONNULL_PTR orig);
/* @internal */
export function TxAddOutput_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddOutput_clone(orig);
	return nativeResponseValue;
}
	// bool TxAddOutput_eq(const struct LDKTxAddOutput *NONNULL_PTR a, const struct LDKTxAddOutput *NONNULL_PTR b);
/* @internal */
export function TxAddOutput_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddOutput_eq(a, b);
	return nativeResponseValue;
}
	// void TxRemoveInput_free(struct LDKTxRemoveInput this_obj);
/* @internal */
export function TxRemoveInput_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveInput_free(this_obj);
	// debug statements here
}
	// const uint8_t (*TxRemoveInput_get_channel_id(const struct LDKTxRemoveInput *NONNULL_PTR this_ptr))[32];
/* @internal */
export function TxRemoveInput_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveInput_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void TxRemoveInput_set_channel_id(struct LDKTxRemoveInput *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function TxRemoveInput_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveInput_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t TxRemoveInput_get_serial_id(const struct LDKTxRemoveInput *NONNULL_PTR this_ptr);
/* @internal */
export function TxRemoveInput_get_serial_id(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveInput_get_serial_id(this_ptr);
	return nativeResponseValue;
}
	// void TxRemoveInput_set_serial_id(struct LDKTxRemoveInput *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function TxRemoveInput_set_serial_id(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveInput_set_serial_id(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKTxRemoveInput TxRemoveInput_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t serial_id_arg);
/* @internal */
export function TxRemoveInput_new(channel_id_arg: number, serial_id_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveInput_new(channel_id_arg, serial_id_arg);
	return nativeResponseValue;
}
	// uint64_t TxRemoveInput_clone_ptr(LDKTxRemoveInput *NONNULL_PTR arg);
/* @internal */
export function TxRemoveInput_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveInput_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKTxRemoveInput TxRemoveInput_clone(const struct LDKTxRemoveInput *NONNULL_PTR orig);
/* @internal */
export function TxRemoveInput_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveInput_clone(orig);
	return nativeResponseValue;
}
	// bool TxRemoveInput_eq(const struct LDKTxRemoveInput *NONNULL_PTR a, const struct LDKTxRemoveInput *NONNULL_PTR b);
/* @internal */
export function TxRemoveInput_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveInput_eq(a, b);
	return nativeResponseValue;
}
	// void TxRemoveOutput_free(struct LDKTxRemoveOutput this_obj);
/* @internal */
export function TxRemoveOutput_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveOutput_free(this_obj);
	// debug statements here
}
	// const uint8_t (*TxRemoveOutput_get_channel_id(const struct LDKTxRemoveOutput *NONNULL_PTR this_ptr))[32];
/* @internal */
export function TxRemoveOutput_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveOutput_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void TxRemoveOutput_set_channel_id(struct LDKTxRemoveOutput *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function TxRemoveOutput_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveOutput_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t TxRemoveOutput_get_serial_id(const struct LDKTxRemoveOutput *NONNULL_PTR this_ptr);
/* @internal */
export function TxRemoveOutput_get_serial_id(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveOutput_get_serial_id(this_ptr);
	return nativeResponseValue;
}
	// void TxRemoveOutput_set_serial_id(struct LDKTxRemoveOutput *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function TxRemoveOutput_set_serial_id(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveOutput_set_serial_id(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKTxRemoveOutput TxRemoveOutput_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t serial_id_arg);
/* @internal */
export function TxRemoveOutput_new(channel_id_arg: number, serial_id_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveOutput_new(channel_id_arg, serial_id_arg);
	return nativeResponseValue;
}
	// uint64_t TxRemoveOutput_clone_ptr(LDKTxRemoveOutput *NONNULL_PTR arg);
/* @internal */
export function TxRemoveOutput_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveOutput_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKTxRemoveOutput TxRemoveOutput_clone(const struct LDKTxRemoveOutput *NONNULL_PTR orig);
/* @internal */
export function TxRemoveOutput_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveOutput_clone(orig);
	return nativeResponseValue;
}
	// bool TxRemoveOutput_eq(const struct LDKTxRemoveOutput *NONNULL_PTR a, const struct LDKTxRemoveOutput *NONNULL_PTR b);
/* @internal */
export function TxRemoveOutput_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveOutput_eq(a, b);
	return nativeResponseValue;
}
	// void TxComplete_free(struct LDKTxComplete this_obj);
/* @internal */
export function TxComplete_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxComplete_free(this_obj);
	// debug statements here
}
	// const uint8_t (*TxComplete_get_channel_id(const struct LDKTxComplete *NONNULL_PTR this_ptr))[32];
/* @internal */
export function TxComplete_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxComplete_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void TxComplete_set_channel_id(struct LDKTxComplete *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function TxComplete_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxComplete_set_channel_id(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKTxComplete TxComplete_new(struct LDKThirtyTwoBytes channel_id_arg);
/* @internal */
export function TxComplete_new(channel_id_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxComplete_new(channel_id_arg);
	return nativeResponseValue;
}
	// uint64_t TxComplete_clone_ptr(LDKTxComplete *NONNULL_PTR arg);
/* @internal */
export function TxComplete_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxComplete_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKTxComplete TxComplete_clone(const struct LDKTxComplete *NONNULL_PTR orig);
/* @internal */
export function TxComplete_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxComplete_clone(orig);
	return nativeResponseValue;
}
	// bool TxComplete_eq(const struct LDKTxComplete *NONNULL_PTR a, const struct LDKTxComplete *NONNULL_PTR b);
/* @internal */
export function TxComplete_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxComplete_eq(a, b);
	return nativeResponseValue;
}
	// void TxSignatures_free(struct LDKTxSignatures this_obj);
/* @internal */
export function TxSignatures_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxSignatures_free(this_obj);
	// debug statements here
}
	// const uint8_t (*TxSignatures_get_channel_id(const struct LDKTxSignatures *NONNULL_PTR this_ptr))[32];
/* @internal */
export function TxSignatures_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxSignatures_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void TxSignatures_set_channel_id(struct LDKTxSignatures *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function TxSignatures_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxSignatures_set_channel_id(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*TxSignatures_get_tx_hash(const struct LDKTxSignatures *NONNULL_PTR this_ptr))[32];
/* @internal */
export function TxSignatures_get_tx_hash(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxSignatures_get_tx_hash(this_ptr);
	return nativeResponseValue;
}
	// void TxSignatures_set_tx_hash(struct LDKTxSignatures *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function TxSignatures_set_tx_hash(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxSignatures_set_tx_hash(this_ptr, val);
	// debug statements here
}
	// struct LDKCVec_WitnessZ TxSignatures_get_witnesses(const struct LDKTxSignatures *NONNULL_PTR this_ptr);
/* @internal */
export function TxSignatures_get_witnesses(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxSignatures_get_witnesses(this_ptr);
	return nativeResponseValue;
}
	// void TxSignatures_set_witnesses(struct LDKTxSignatures *NONNULL_PTR this_ptr, struct LDKCVec_WitnessZ val);
/* @internal */
export function TxSignatures_set_witnesses(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxSignatures_set_witnesses(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKTxSignatures TxSignatures_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKThirtyTwoBytes tx_hash_arg, struct LDKCVec_WitnessZ witnesses_arg);
/* @internal */
export function TxSignatures_new(channel_id_arg: number, tx_hash_arg: number, witnesses_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxSignatures_new(channel_id_arg, tx_hash_arg, witnesses_arg);
	return nativeResponseValue;
}
	// uint64_t TxSignatures_clone_ptr(LDKTxSignatures *NONNULL_PTR arg);
/* @internal */
export function TxSignatures_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxSignatures_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKTxSignatures TxSignatures_clone(const struct LDKTxSignatures *NONNULL_PTR orig);
/* @internal */
export function TxSignatures_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxSignatures_clone(orig);
	return nativeResponseValue;
}
	// bool TxSignatures_eq(const struct LDKTxSignatures *NONNULL_PTR a, const struct LDKTxSignatures *NONNULL_PTR b);
/* @internal */
export function TxSignatures_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxSignatures_eq(a, b);
	return nativeResponseValue;
}
	// void TxInitRbf_free(struct LDKTxInitRbf this_obj);
/* @internal */
export function TxInitRbf_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxInitRbf_free(this_obj);
	// debug statements here
}
	// const uint8_t (*TxInitRbf_get_channel_id(const struct LDKTxInitRbf *NONNULL_PTR this_ptr))[32];
/* @internal */
export function TxInitRbf_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxInitRbf_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void TxInitRbf_set_channel_id(struct LDKTxInitRbf *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function TxInitRbf_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxInitRbf_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint32_t TxInitRbf_get_locktime(const struct LDKTxInitRbf *NONNULL_PTR this_ptr);
/* @internal */
export function TxInitRbf_get_locktime(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxInitRbf_get_locktime(this_ptr);
	return nativeResponseValue;
}
	// void TxInitRbf_set_locktime(struct LDKTxInitRbf *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function TxInitRbf_set_locktime(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxInitRbf_set_locktime(this_ptr, val);
	// debug statements here
}
	// uint32_t TxInitRbf_get_feerate_sat_per_1000_weight(const struct LDKTxInitRbf *NONNULL_PTR this_ptr);
/* @internal */
export function TxInitRbf_get_feerate_sat_per_1000_weight(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxInitRbf_get_feerate_sat_per_1000_weight(this_ptr);
	return nativeResponseValue;
}
	// void TxInitRbf_set_feerate_sat_per_1000_weight(struct LDKTxInitRbf *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function TxInitRbf_set_feerate_sat_per_1000_weight(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxInitRbf_set_feerate_sat_per_1000_weight(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_i64Z TxInitRbf_get_funding_output_contribution(const struct LDKTxInitRbf *NONNULL_PTR this_ptr);
/* @internal */
export function TxInitRbf_get_funding_output_contribution(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxInitRbf_get_funding_output_contribution(this_ptr);
	return nativeResponseValue;
}
	// void TxInitRbf_set_funding_output_contribution(struct LDKTxInitRbf *NONNULL_PTR this_ptr, struct LDKCOption_i64Z val);
/* @internal */
export function TxInitRbf_set_funding_output_contribution(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxInitRbf_set_funding_output_contribution(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKTxInitRbf TxInitRbf_new(struct LDKThirtyTwoBytes channel_id_arg, uint32_t locktime_arg, uint32_t feerate_sat_per_1000_weight_arg, struct LDKCOption_i64Z funding_output_contribution_arg);
/* @internal */
export function TxInitRbf_new(channel_id_arg: number, locktime_arg: number, feerate_sat_per_1000_weight_arg: number, funding_output_contribution_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxInitRbf_new(channel_id_arg, locktime_arg, feerate_sat_per_1000_weight_arg, funding_output_contribution_arg);
	return nativeResponseValue;
}
	// uint64_t TxInitRbf_clone_ptr(LDKTxInitRbf *NONNULL_PTR arg);
/* @internal */
export function TxInitRbf_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxInitRbf_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKTxInitRbf TxInitRbf_clone(const struct LDKTxInitRbf *NONNULL_PTR orig);
/* @internal */
export function TxInitRbf_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxInitRbf_clone(orig);
	return nativeResponseValue;
}
	// bool TxInitRbf_eq(const struct LDKTxInitRbf *NONNULL_PTR a, const struct LDKTxInitRbf *NONNULL_PTR b);
/* @internal */
export function TxInitRbf_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxInitRbf_eq(a, b);
	return nativeResponseValue;
}
	// void TxAckRbf_free(struct LDKTxAckRbf this_obj);
/* @internal */
export function TxAckRbf_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAckRbf_free(this_obj);
	// debug statements here
}
	// const uint8_t (*TxAckRbf_get_channel_id(const struct LDKTxAckRbf *NONNULL_PTR this_ptr))[32];
/* @internal */
export function TxAckRbf_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAckRbf_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void TxAckRbf_set_channel_id(struct LDKTxAckRbf *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function TxAckRbf_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAckRbf_set_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_i64Z TxAckRbf_get_funding_output_contribution(const struct LDKTxAckRbf *NONNULL_PTR this_ptr);
/* @internal */
export function TxAckRbf_get_funding_output_contribution(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAckRbf_get_funding_output_contribution(this_ptr);
	return nativeResponseValue;
}
	// void TxAckRbf_set_funding_output_contribution(struct LDKTxAckRbf *NONNULL_PTR this_ptr, struct LDKCOption_i64Z val);
/* @internal */
export function TxAckRbf_set_funding_output_contribution(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAckRbf_set_funding_output_contribution(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKTxAckRbf TxAckRbf_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKCOption_i64Z funding_output_contribution_arg);
/* @internal */
export function TxAckRbf_new(channel_id_arg: number, funding_output_contribution_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAckRbf_new(channel_id_arg, funding_output_contribution_arg);
	return nativeResponseValue;
}
	// uint64_t TxAckRbf_clone_ptr(LDKTxAckRbf *NONNULL_PTR arg);
/* @internal */
export function TxAckRbf_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAckRbf_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKTxAckRbf TxAckRbf_clone(const struct LDKTxAckRbf *NONNULL_PTR orig);
/* @internal */
export function TxAckRbf_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAckRbf_clone(orig);
	return nativeResponseValue;
}
	// bool TxAckRbf_eq(const struct LDKTxAckRbf *NONNULL_PTR a, const struct LDKTxAckRbf *NONNULL_PTR b);
/* @internal */
export function TxAckRbf_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAckRbf_eq(a, b);
	return nativeResponseValue;
}
	// void TxAbort_free(struct LDKTxAbort this_obj);
/* @internal */
export function TxAbort_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAbort_free(this_obj);
	// debug statements here
}
	// const uint8_t (*TxAbort_get_channel_id(const struct LDKTxAbort *NONNULL_PTR this_ptr))[32];
/* @internal */
export function TxAbort_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAbort_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void TxAbort_set_channel_id(struct LDKTxAbort *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function TxAbort_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAbort_set_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKCVec_u8Z TxAbort_get_data(const struct LDKTxAbort *NONNULL_PTR this_ptr);
/* @internal */
export function TxAbort_get_data(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAbort_get_data(this_ptr);
	return nativeResponseValue;
}
	// void TxAbort_set_data(struct LDKTxAbort *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);
/* @internal */
export function TxAbort_set_data(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAbort_set_data(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKTxAbort TxAbort_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKCVec_u8Z data_arg);
/* @internal */
export function TxAbort_new(channel_id_arg: number, data_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAbort_new(channel_id_arg, data_arg);
	return nativeResponseValue;
}
	// uint64_t TxAbort_clone_ptr(LDKTxAbort *NONNULL_PTR arg);
/* @internal */
export function TxAbort_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAbort_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKTxAbort TxAbort_clone(const struct LDKTxAbort *NONNULL_PTR orig);
/* @internal */
export function TxAbort_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAbort_clone(orig);
	return nativeResponseValue;
}
	// bool TxAbort_eq(const struct LDKTxAbort *NONNULL_PTR a, const struct LDKTxAbort *NONNULL_PTR b);
/* @internal */
export function TxAbort_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAbort_eq(a, b);
	return nativeResponseValue;
}
	// void Shutdown_free(struct LDKShutdown this_obj);
/* @internal */
export function Shutdown_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_free(this_obj);
	// debug statements here
}
	// const uint8_t (*Shutdown_get_channel_id(const struct LDKShutdown *NONNULL_PTR this_ptr))[32];
/* @internal */
export function Shutdown_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void Shutdown_set_channel_id(struct LDKShutdown *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function Shutdown_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_set_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKu8slice Shutdown_get_scriptpubkey(const struct LDKShutdown *NONNULL_PTR this_ptr);
/* @internal */
export function Shutdown_get_scriptpubkey(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_get_scriptpubkey(this_ptr);
	return nativeResponseValue;
}
	// void Shutdown_set_scriptpubkey(struct LDKShutdown *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);
/* @internal */
export function Shutdown_set_scriptpubkey(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_set_scriptpubkey(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKShutdown Shutdown_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKCVec_u8Z scriptpubkey_arg);
/* @internal */
export function Shutdown_new(channel_id_arg: number, scriptpubkey_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_new(channel_id_arg, scriptpubkey_arg);
	return nativeResponseValue;
}
	// uint64_t Shutdown_clone_ptr(LDKShutdown *NONNULL_PTR arg);
/* @internal */
export function Shutdown_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKShutdown Shutdown_clone(const struct LDKShutdown *NONNULL_PTR orig);
/* @internal */
export function Shutdown_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_clone(orig);
	return nativeResponseValue;
}
	// bool Shutdown_eq(const struct LDKShutdown *NONNULL_PTR a, const struct LDKShutdown *NONNULL_PTR b);
/* @internal */
export function Shutdown_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_eq(a, b);
	return nativeResponseValue;
}
	// void ClosingSignedFeeRange_free(struct LDKClosingSignedFeeRange this_obj);
/* @internal */
export function ClosingSignedFeeRange_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_free(this_obj);
	// debug statements here
}
	// uint64_t ClosingSignedFeeRange_get_min_fee_satoshis(const struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr);
/* @internal */
export function ClosingSignedFeeRange_get_min_fee_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_get_min_fee_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void ClosingSignedFeeRange_set_min_fee_satoshis(struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ClosingSignedFeeRange_set_min_fee_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_set_min_fee_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t ClosingSignedFeeRange_get_max_fee_satoshis(const struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr);
/* @internal */
export function ClosingSignedFeeRange_get_max_fee_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_get_max_fee_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void ClosingSignedFeeRange_set_max_fee_satoshis(struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ClosingSignedFeeRange_set_max_fee_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_set_max_fee_satoshis(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKClosingSignedFeeRange ClosingSignedFeeRange_new(uint64_t min_fee_satoshis_arg, uint64_t max_fee_satoshis_arg);
/* @internal */
export function ClosingSignedFeeRange_new(min_fee_satoshis_arg: bigint, max_fee_satoshis_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_new(min_fee_satoshis_arg, max_fee_satoshis_arg);
	return nativeResponseValue;
}
	// uint64_t ClosingSignedFeeRange_clone_ptr(LDKClosingSignedFeeRange *NONNULL_PTR arg);
/* @internal */
export function ClosingSignedFeeRange_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKClosingSignedFeeRange ClosingSignedFeeRange_clone(const struct LDKClosingSignedFeeRange *NONNULL_PTR orig);
/* @internal */
export function ClosingSignedFeeRange_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_clone(orig);
	return nativeResponseValue;
}
	// bool ClosingSignedFeeRange_eq(const struct LDKClosingSignedFeeRange *NONNULL_PTR a, const struct LDKClosingSignedFeeRange *NONNULL_PTR b);
/* @internal */
export function ClosingSignedFeeRange_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_eq(a, b);
	return nativeResponseValue;
}
	// void ClosingSigned_free(struct LDKClosingSigned this_obj);
/* @internal */
export function ClosingSigned_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_free(this_obj);
	// debug statements here
}
	// const uint8_t (*ClosingSigned_get_channel_id(const struct LDKClosingSigned *NONNULL_PTR this_ptr))[32];
/* @internal */
export function ClosingSigned_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void ClosingSigned_set_channel_id(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function ClosingSigned_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t ClosingSigned_get_fee_satoshis(const struct LDKClosingSigned *NONNULL_PTR this_ptr);
/* @internal */
export function ClosingSigned_get_fee_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_get_fee_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void ClosingSigned_set_fee_satoshis(struct LDKClosingSigned *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ClosingSigned_set_fee_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_set_fee_satoshis(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature ClosingSigned_get_signature(const struct LDKClosingSigned *NONNULL_PTR this_ptr);
/* @internal */
export function ClosingSigned_get_signature(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_get_signature(this_ptr);
	return nativeResponseValue;
}
	// void ClosingSigned_set_signature(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function ClosingSigned_set_signature(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_set_signature(this_ptr, val);
	// debug statements here
}
	// struct LDKClosingSignedFeeRange ClosingSigned_get_fee_range(const struct LDKClosingSigned *NONNULL_PTR this_ptr);
/* @internal */
export function ClosingSigned_get_fee_range(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_get_fee_range(this_ptr);
	return nativeResponseValue;
}
	// void ClosingSigned_set_fee_range(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKClosingSignedFeeRange val);
/* @internal */
export function ClosingSigned_set_fee_range(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_set_fee_range(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKClosingSigned ClosingSigned_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t fee_satoshis_arg, struct LDKSignature signature_arg, struct LDKClosingSignedFeeRange fee_range_arg);
/* @internal */
export function ClosingSigned_new(channel_id_arg: number, fee_satoshis_arg: bigint, signature_arg: number, fee_range_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_new(channel_id_arg, fee_satoshis_arg, signature_arg, fee_range_arg);
	return nativeResponseValue;
}
	// uint64_t ClosingSigned_clone_ptr(LDKClosingSigned *NONNULL_PTR arg);
/* @internal */
export function ClosingSigned_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKClosingSigned ClosingSigned_clone(const struct LDKClosingSigned *NONNULL_PTR orig);
/* @internal */
export function ClosingSigned_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_clone(orig);
	return nativeResponseValue;
}
	// bool ClosingSigned_eq(const struct LDKClosingSigned *NONNULL_PTR a, const struct LDKClosingSigned *NONNULL_PTR b);
/* @internal */
export function ClosingSigned_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_eq(a, b);
	return nativeResponseValue;
}
	// void UpdateAddHTLC_free(struct LDKUpdateAddHTLC this_obj);
/* @internal */
export function UpdateAddHTLC_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_free(this_obj);
	// debug statements here
}
	// const uint8_t (*UpdateAddHTLC_get_channel_id(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UpdateAddHTLC_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateAddHTLC_set_channel_id(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UpdateAddHTLC_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t UpdateAddHTLC_get_htlc_id(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);
/* @internal */
export function UpdateAddHTLC_get_htlc_id(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_get_htlc_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateAddHTLC_set_htlc_id(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function UpdateAddHTLC_set_htlc_id(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_set_htlc_id(this_ptr, val);
	// debug statements here
}
	// uint64_t UpdateAddHTLC_get_amount_msat(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);
/* @internal */
export function UpdateAddHTLC_get_amount_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_get_amount_msat(this_ptr);
	return nativeResponseValue;
}
	// void UpdateAddHTLC_set_amount_msat(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function UpdateAddHTLC_set_amount_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_set_amount_msat(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*UpdateAddHTLC_get_payment_hash(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UpdateAddHTLC_get_payment_hash(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_get_payment_hash(this_ptr);
	return nativeResponseValue;
}
	// void UpdateAddHTLC_set_payment_hash(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UpdateAddHTLC_set_payment_hash(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_set_payment_hash(this_ptr, val);
	// debug statements here
}
	// uint32_t UpdateAddHTLC_get_cltv_expiry(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);
/* @internal */
export function UpdateAddHTLC_get_cltv_expiry(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_get_cltv_expiry(this_ptr);
	return nativeResponseValue;
}
	// void UpdateAddHTLC_set_cltv_expiry(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function UpdateAddHTLC_set_cltv_expiry(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_set_cltv_expiry(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z UpdateAddHTLC_get_skimmed_fee_msat(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);
/* @internal */
export function UpdateAddHTLC_get_skimmed_fee_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_get_skimmed_fee_msat(this_ptr);
	return nativeResponseValue;
}
	// void UpdateAddHTLC_set_skimmed_fee_msat(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function UpdateAddHTLC_set_skimmed_fee_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_set_skimmed_fee_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t UpdateAddHTLC_clone_ptr(LDKUpdateAddHTLC *NONNULL_PTR arg);
/* @internal */
export function UpdateAddHTLC_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUpdateAddHTLC UpdateAddHTLC_clone(const struct LDKUpdateAddHTLC *NONNULL_PTR orig);
/* @internal */
export function UpdateAddHTLC_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_clone(orig);
	return nativeResponseValue;
}
	// bool UpdateAddHTLC_eq(const struct LDKUpdateAddHTLC *NONNULL_PTR a, const struct LDKUpdateAddHTLC *NONNULL_PTR b);
/* @internal */
export function UpdateAddHTLC_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_eq(a, b);
	return nativeResponseValue;
}
	// void OnionMessage_free(struct LDKOnionMessage this_obj);
/* @internal */
export function OnionMessage_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessage_free(this_obj);
	// debug statements here
}
	// struct LDKPublicKey OnionMessage_get_blinding_point(const struct LDKOnionMessage *NONNULL_PTR this_ptr);
/* @internal */
export function OnionMessage_get_blinding_point(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessage_get_blinding_point(this_ptr);
	return nativeResponseValue;
}
	// void OnionMessage_set_blinding_point(struct LDKOnionMessage *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OnionMessage_set_blinding_point(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessage_set_blinding_point(this_ptr, val);
	// debug statements here
}
	// uint64_t OnionMessage_clone_ptr(LDKOnionMessage *NONNULL_PTR arg);
/* @internal */
export function OnionMessage_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessage_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKOnionMessage OnionMessage_clone(const struct LDKOnionMessage *NONNULL_PTR orig);
/* @internal */
export function OnionMessage_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessage_clone(orig);
	return nativeResponseValue;
}
	// bool OnionMessage_eq(const struct LDKOnionMessage *NONNULL_PTR a, const struct LDKOnionMessage *NONNULL_PTR b);
/* @internal */
export function OnionMessage_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessage_eq(a, b);
	return nativeResponseValue;
}
	// void UpdateFulfillHTLC_free(struct LDKUpdateFulfillHTLC this_obj);
/* @internal */
export function UpdateFulfillHTLC_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_free(this_obj);
	// debug statements here
}
	// const uint8_t (*UpdateFulfillHTLC_get_channel_id(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UpdateFulfillHTLC_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFulfillHTLC_set_channel_id(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UpdateFulfillHTLC_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t UpdateFulfillHTLC_get_htlc_id(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr);
/* @internal */
export function UpdateFulfillHTLC_get_htlc_id(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_get_htlc_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFulfillHTLC_set_htlc_id(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function UpdateFulfillHTLC_set_htlc_id(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_set_htlc_id(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*UpdateFulfillHTLC_get_payment_preimage(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UpdateFulfillHTLC_get_payment_preimage(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_get_payment_preimage(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFulfillHTLC_set_payment_preimage(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UpdateFulfillHTLC_set_payment_preimage(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_set_payment_preimage(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKUpdateFulfillHTLC UpdateFulfillHTLC_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t htlc_id_arg, struct LDKThirtyTwoBytes payment_preimage_arg);
/* @internal */
export function UpdateFulfillHTLC_new(channel_id_arg: number, htlc_id_arg: bigint, payment_preimage_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_new(channel_id_arg, htlc_id_arg, payment_preimage_arg);
	return nativeResponseValue;
}
	// uint64_t UpdateFulfillHTLC_clone_ptr(LDKUpdateFulfillHTLC *NONNULL_PTR arg);
/* @internal */
export function UpdateFulfillHTLC_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUpdateFulfillHTLC UpdateFulfillHTLC_clone(const struct LDKUpdateFulfillHTLC *NONNULL_PTR orig);
/* @internal */
export function UpdateFulfillHTLC_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_clone(orig);
	return nativeResponseValue;
}
	// bool UpdateFulfillHTLC_eq(const struct LDKUpdateFulfillHTLC *NONNULL_PTR a, const struct LDKUpdateFulfillHTLC *NONNULL_PTR b);
/* @internal */
export function UpdateFulfillHTLC_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_eq(a, b);
	return nativeResponseValue;
}
	// void UpdateFailHTLC_free(struct LDKUpdateFailHTLC this_obj);
/* @internal */
export function UpdateFailHTLC_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_free(this_obj);
	// debug statements here
}
	// const uint8_t (*UpdateFailHTLC_get_channel_id(const struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UpdateFailHTLC_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFailHTLC_set_channel_id(struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UpdateFailHTLC_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t UpdateFailHTLC_get_htlc_id(const struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr);
/* @internal */
export function UpdateFailHTLC_get_htlc_id(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_get_htlc_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFailHTLC_set_htlc_id(struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function UpdateFailHTLC_set_htlc_id(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_set_htlc_id(this_ptr, val);
	// debug statements here
}
	// uint64_t UpdateFailHTLC_clone_ptr(LDKUpdateFailHTLC *NONNULL_PTR arg);
/* @internal */
export function UpdateFailHTLC_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUpdateFailHTLC UpdateFailHTLC_clone(const struct LDKUpdateFailHTLC *NONNULL_PTR orig);
/* @internal */
export function UpdateFailHTLC_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_clone(orig);
	return nativeResponseValue;
}
	// bool UpdateFailHTLC_eq(const struct LDKUpdateFailHTLC *NONNULL_PTR a, const struct LDKUpdateFailHTLC *NONNULL_PTR b);
/* @internal */
export function UpdateFailHTLC_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_eq(a, b);
	return nativeResponseValue;
}
	// void UpdateFailMalformedHTLC_free(struct LDKUpdateFailMalformedHTLC this_obj);
/* @internal */
export function UpdateFailMalformedHTLC_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_free(this_obj);
	// debug statements here
}
	// const uint8_t (*UpdateFailMalformedHTLC_get_channel_id(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UpdateFailMalformedHTLC_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFailMalformedHTLC_set_channel_id(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UpdateFailMalformedHTLC_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t UpdateFailMalformedHTLC_get_htlc_id(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr);
/* @internal */
export function UpdateFailMalformedHTLC_get_htlc_id(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_get_htlc_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFailMalformedHTLC_set_htlc_id(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function UpdateFailMalformedHTLC_set_htlc_id(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_set_htlc_id(this_ptr, val);
	// debug statements here
}
	// uint16_t UpdateFailMalformedHTLC_get_failure_code(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr);
/* @internal */
export function UpdateFailMalformedHTLC_get_failure_code(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_get_failure_code(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFailMalformedHTLC_set_failure_code(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function UpdateFailMalformedHTLC_set_failure_code(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_set_failure_code(this_ptr, val);
	// debug statements here
}
	// uint64_t UpdateFailMalformedHTLC_clone_ptr(LDKUpdateFailMalformedHTLC *NONNULL_PTR arg);
/* @internal */
export function UpdateFailMalformedHTLC_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUpdateFailMalformedHTLC UpdateFailMalformedHTLC_clone(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR orig);
/* @internal */
export function UpdateFailMalformedHTLC_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_clone(orig);
	return nativeResponseValue;
}
	// bool UpdateFailMalformedHTLC_eq(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR a, const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR b);
/* @internal */
export function UpdateFailMalformedHTLC_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_eq(a, b);
	return nativeResponseValue;
}
	// void CommitmentSigned_free(struct LDKCommitmentSigned this_obj);
/* @internal */
export function CommitmentSigned_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_free(this_obj);
	// debug statements here
}
	// const uint8_t (*CommitmentSigned_get_channel_id(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr))[32];
/* @internal */
export function CommitmentSigned_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void CommitmentSigned_set_channel_id(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function CommitmentSigned_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_set_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature CommitmentSigned_get_signature(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr);
/* @internal */
export function CommitmentSigned_get_signature(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_get_signature(this_ptr);
	return nativeResponseValue;
}
	// void CommitmentSigned_set_signature(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function CommitmentSigned_set_signature(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_set_signature(this_ptr, val);
	// debug statements here
}
	// struct LDKCVec_SignatureZ CommitmentSigned_get_htlc_signatures(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr);
/* @internal */
export function CommitmentSigned_get_htlc_signatures(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_get_htlc_signatures(this_ptr);
	return nativeResponseValue;
}
	// void CommitmentSigned_set_htlc_signatures(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKCVec_SignatureZ val);
/* @internal */
export function CommitmentSigned_set_htlc_signatures(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_set_htlc_signatures(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKCommitmentSigned CommitmentSigned_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKSignature signature_arg, struct LDKCVec_SignatureZ htlc_signatures_arg);
/* @internal */
export function CommitmentSigned_new(channel_id_arg: number, signature_arg: number, htlc_signatures_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_new(channel_id_arg, signature_arg, htlc_signatures_arg);
	return nativeResponseValue;
}
	// uint64_t CommitmentSigned_clone_ptr(LDKCommitmentSigned *NONNULL_PTR arg);
/* @internal */
export function CommitmentSigned_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCommitmentSigned CommitmentSigned_clone(const struct LDKCommitmentSigned *NONNULL_PTR orig);
/* @internal */
export function CommitmentSigned_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_clone(orig);
	return nativeResponseValue;
}
	// bool CommitmentSigned_eq(const struct LDKCommitmentSigned *NONNULL_PTR a, const struct LDKCommitmentSigned *NONNULL_PTR b);
/* @internal */
export function CommitmentSigned_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_eq(a, b);
	return nativeResponseValue;
}
	// void RevokeAndACK_free(struct LDKRevokeAndACK this_obj);
/* @internal */
export function RevokeAndACK_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_free(this_obj);
	// debug statements here
}
	// const uint8_t (*RevokeAndACK_get_channel_id(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr))[32];
/* @internal */
export function RevokeAndACK_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void RevokeAndACK_set_channel_id(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function RevokeAndACK_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_set_channel_id(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*RevokeAndACK_get_per_commitment_secret(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr))[32];
/* @internal */
export function RevokeAndACK_get_per_commitment_secret(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_get_per_commitment_secret(this_ptr);
	return nativeResponseValue;
}
	// void RevokeAndACK_set_per_commitment_secret(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function RevokeAndACK_set_per_commitment_secret(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_set_per_commitment_secret(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey RevokeAndACK_get_next_per_commitment_point(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr);
/* @internal */
export function RevokeAndACK_get_next_per_commitment_point(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_get_next_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void RevokeAndACK_set_next_per_commitment_point(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function RevokeAndACK_set_next_per_commitment_point(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_set_next_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKRevokeAndACK RevokeAndACK_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKThirtyTwoBytes per_commitment_secret_arg, struct LDKPublicKey next_per_commitment_point_arg);
/* @internal */
export function RevokeAndACK_new(channel_id_arg: number, per_commitment_secret_arg: number, next_per_commitment_point_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_new(channel_id_arg, per_commitment_secret_arg, next_per_commitment_point_arg);
	return nativeResponseValue;
}
	// uint64_t RevokeAndACK_clone_ptr(LDKRevokeAndACK *NONNULL_PTR arg);
/* @internal */
export function RevokeAndACK_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRevokeAndACK RevokeAndACK_clone(const struct LDKRevokeAndACK *NONNULL_PTR orig);
/* @internal */
export function RevokeAndACK_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_clone(orig);
	return nativeResponseValue;
}
	// bool RevokeAndACK_eq(const struct LDKRevokeAndACK *NONNULL_PTR a, const struct LDKRevokeAndACK *NONNULL_PTR b);
/* @internal */
export function RevokeAndACK_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_eq(a, b);
	return nativeResponseValue;
}
	// void UpdateFee_free(struct LDKUpdateFee this_obj);
/* @internal */
export function UpdateFee_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_free(this_obj);
	// debug statements here
}
	// const uint8_t (*UpdateFee_get_channel_id(const struct LDKUpdateFee *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UpdateFee_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFee_set_channel_id(struct LDKUpdateFee *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UpdateFee_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint32_t UpdateFee_get_feerate_per_kw(const struct LDKUpdateFee *NONNULL_PTR this_ptr);
/* @internal */
export function UpdateFee_get_feerate_per_kw(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_get_feerate_per_kw(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFee_set_feerate_per_kw(struct LDKUpdateFee *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function UpdateFee_set_feerate_per_kw(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_set_feerate_per_kw(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKUpdateFee UpdateFee_new(struct LDKThirtyTwoBytes channel_id_arg, uint32_t feerate_per_kw_arg);
/* @internal */
export function UpdateFee_new(channel_id_arg: number, feerate_per_kw_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_new(channel_id_arg, feerate_per_kw_arg);
	return nativeResponseValue;
}
	// uint64_t UpdateFee_clone_ptr(LDKUpdateFee *NONNULL_PTR arg);
/* @internal */
export function UpdateFee_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUpdateFee UpdateFee_clone(const struct LDKUpdateFee *NONNULL_PTR orig);
/* @internal */
export function UpdateFee_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_clone(orig);
	return nativeResponseValue;
}
	// bool UpdateFee_eq(const struct LDKUpdateFee *NONNULL_PTR a, const struct LDKUpdateFee *NONNULL_PTR b);
/* @internal */
export function UpdateFee_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_eq(a, b);
	return nativeResponseValue;
}
	// void ChannelReestablish_free(struct LDKChannelReestablish this_obj);
/* @internal */
export function ChannelReestablish_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_free(this_obj);
	// debug statements here
}
	// const uint8_t (*ChannelReestablish_get_channel_id(const struct LDKChannelReestablish *NONNULL_PTR this_ptr))[32];
/* @internal */
export function ChannelReestablish_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void ChannelReestablish_set_channel_id(struct LDKChannelReestablish *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function ChannelReestablish_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelReestablish_get_next_local_commitment_number(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelReestablish_get_next_local_commitment_number(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_get_next_local_commitment_number(this_ptr);
	return nativeResponseValue;
}
	// void ChannelReestablish_set_next_local_commitment_number(struct LDKChannelReestablish *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelReestablish_set_next_local_commitment_number(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_set_next_local_commitment_number(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelReestablish_get_next_remote_commitment_number(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelReestablish_get_next_remote_commitment_number(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_get_next_remote_commitment_number(this_ptr);
	return nativeResponseValue;
}
	// void ChannelReestablish_set_next_remote_commitment_number(struct LDKChannelReestablish *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelReestablish_set_next_remote_commitment_number(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_set_next_remote_commitment_number(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*ChannelReestablish_get_your_last_per_commitment_secret(const struct LDKChannelReestablish *NONNULL_PTR this_ptr))[32];
/* @internal */
export function ChannelReestablish_get_your_last_per_commitment_secret(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_get_your_last_per_commitment_secret(this_ptr);
	return nativeResponseValue;
}
	// void ChannelReestablish_set_your_last_per_commitment_secret(struct LDKChannelReestablish *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function ChannelReestablish_set_your_last_per_commitment_secret(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_set_your_last_per_commitment_secret(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey ChannelReestablish_get_my_current_per_commitment_point(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelReestablish_get_my_current_per_commitment_point(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_get_my_current_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void ChannelReestablish_set_my_current_per_commitment_point(struct LDKChannelReestablish *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function ChannelReestablish_set_my_current_per_commitment_point(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_set_my_current_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_TxidZ ChannelReestablish_get_next_funding_txid(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelReestablish_get_next_funding_txid(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_get_next_funding_txid(this_ptr);
	return nativeResponseValue;
}
	// void ChannelReestablish_set_next_funding_txid(struct LDKChannelReestablish *NONNULL_PTR this_ptr, struct LDKCOption_TxidZ val);
/* @internal */
export function ChannelReestablish_set_next_funding_txid(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_set_next_funding_txid(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelReestablish ChannelReestablish_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t next_local_commitment_number_arg, uint64_t next_remote_commitment_number_arg, struct LDKThirtyTwoBytes your_last_per_commitment_secret_arg, struct LDKPublicKey my_current_per_commitment_point_arg, struct LDKCOption_TxidZ next_funding_txid_arg);
/* @internal */
export function ChannelReestablish_new(channel_id_arg: number, next_local_commitment_number_arg: bigint, next_remote_commitment_number_arg: bigint, your_last_per_commitment_secret_arg: number, my_current_per_commitment_point_arg: number, next_funding_txid_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_new(channel_id_arg, next_local_commitment_number_arg, next_remote_commitment_number_arg, your_last_per_commitment_secret_arg, my_current_per_commitment_point_arg, next_funding_txid_arg);
	return nativeResponseValue;
}
	// uint64_t ChannelReestablish_clone_ptr(LDKChannelReestablish *NONNULL_PTR arg);
/* @internal */
export function ChannelReestablish_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelReestablish ChannelReestablish_clone(const struct LDKChannelReestablish *NONNULL_PTR orig);
/* @internal */
export function ChannelReestablish_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_clone(orig);
	return nativeResponseValue;
}
	// bool ChannelReestablish_eq(const struct LDKChannelReestablish *NONNULL_PTR a, const struct LDKChannelReestablish *NONNULL_PTR b);
/* @internal */
export function ChannelReestablish_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_eq(a, b);
	return nativeResponseValue;
}
	// void AnnouncementSignatures_free(struct LDKAnnouncementSignatures this_obj);
/* @internal */
export function AnnouncementSignatures_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_free(this_obj);
	// debug statements here
}
	// const uint8_t (*AnnouncementSignatures_get_channel_id(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr))[32];
/* @internal */
export function AnnouncementSignatures_get_channel_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void AnnouncementSignatures_set_channel_id(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function AnnouncementSignatures_set_channel_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t AnnouncementSignatures_get_short_channel_id(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);
/* @internal */
export function AnnouncementSignatures_get_short_channel_id(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_get_short_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void AnnouncementSignatures_set_short_channel_id(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function AnnouncementSignatures_set_short_channel_id(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_set_short_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature AnnouncementSignatures_get_node_signature(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);
/* @internal */
export function AnnouncementSignatures_get_node_signature(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_get_node_signature(this_ptr);
	return nativeResponseValue;
}
	// void AnnouncementSignatures_set_node_signature(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function AnnouncementSignatures_set_node_signature(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_set_node_signature(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature AnnouncementSignatures_get_bitcoin_signature(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);
/* @internal */
export function AnnouncementSignatures_get_bitcoin_signature(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_get_bitcoin_signature(this_ptr);
	return nativeResponseValue;
}
	// void AnnouncementSignatures_set_bitcoin_signature(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function AnnouncementSignatures_set_bitcoin_signature(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_set_bitcoin_signature(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKAnnouncementSignatures AnnouncementSignatures_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t short_channel_id_arg, struct LDKSignature node_signature_arg, struct LDKSignature bitcoin_signature_arg);
/* @internal */
export function AnnouncementSignatures_new(channel_id_arg: number, short_channel_id_arg: bigint, node_signature_arg: number, bitcoin_signature_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_new(channel_id_arg, short_channel_id_arg, node_signature_arg, bitcoin_signature_arg);
	return nativeResponseValue;
}
	// uint64_t AnnouncementSignatures_clone_ptr(LDKAnnouncementSignatures *NONNULL_PTR arg);
/* @internal */
export function AnnouncementSignatures_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKAnnouncementSignatures AnnouncementSignatures_clone(const struct LDKAnnouncementSignatures *NONNULL_PTR orig);
/* @internal */
export function AnnouncementSignatures_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_clone(orig);
	return nativeResponseValue;
}
	// bool AnnouncementSignatures_eq(const struct LDKAnnouncementSignatures *NONNULL_PTR a, const struct LDKAnnouncementSignatures *NONNULL_PTR b);
/* @internal */
export function AnnouncementSignatures_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_eq(a, b);
	return nativeResponseValue;
}
	// void NetAddress_free(struct LDKNetAddress this_ptr);
/* @internal */
export function NetAddress_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_free(this_ptr);
	// debug statements here
}
	// uint64_t NetAddress_clone_ptr(LDKNetAddress *NONNULL_PTR arg);
/* @internal */
export function NetAddress_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKNetAddress NetAddress_clone(const struct LDKNetAddress *NONNULL_PTR orig);
/* @internal */
export function NetAddress_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_clone(orig);
	return nativeResponseValue;
}
	// struct LDKNetAddress NetAddress_ipv4(struct LDKFourBytes addr, uint16_t port);
/* @internal */
export function NetAddress_ipv4(addr: number, port: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_ipv4(addr, port);
	return nativeResponseValue;
}
	// struct LDKNetAddress NetAddress_ipv6(struct LDKSixteenBytes addr, uint16_t port);
/* @internal */
export function NetAddress_ipv6(addr: number, port: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_ipv6(addr, port);
	return nativeResponseValue;
}
	// struct LDKNetAddress NetAddress_onion_v2(struct LDKTwelveBytes a);
/* @internal */
export function NetAddress_onion_v2(a: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_onion_v2(a);
	return nativeResponseValue;
}
	// struct LDKNetAddress NetAddress_onion_v3(struct LDKThirtyTwoBytes ed25519_pubkey, uint16_t checksum, uint8_t version, uint16_t port);
/* @internal */
export function NetAddress_onion_v3(ed25519_pubkey: number, checksum: number, version: number, port: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_onion_v3(ed25519_pubkey, checksum, version, port);
	return nativeResponseValue;
}
	// struct LDKNetAddress NetAddress_hostname(struct LDKHostname hostname, uint16_t port);
/* @internal */
export function NetAddress_hostname(hostname: bigint, port: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_hostname(hostname, port);
	return nativeResponseValue;
}
	// bool NetAddress_eq(const struct LDKNetAddress *NONNULL_PTR a, const struct LDKNetAddress *NONNULL_PTR b);
/* @internal */
export function NetAddress_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z NetAddress_write(const struct LDKNetAddress *NONNULL_PTR obj);
/* @internal */
export function NetAddress_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_NetAddressDecodeErrorZ NetAddress_read(struct LDKu8slice ser);
/* @internal */
export function NetAddress_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_read(ser);
	return nativeResponseValue;
}
	// void UnsignedGossipMessage_free(struct LDKUnsignedGossipMessage this_ptr);
/* @internal */
export function UnsignedGossipMessage_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedGossipMessage_free(this_ptr);
	// debug statements here
}
	// uint64_t UnsignedGossipMessage_clone_ptr(LDKUnsignedGossipMessage *NONNULL_PTR arg);
/* @internal */
export function UnsignedGossipMessage_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedGossipMessage_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUnsignedGossipMessage UnsignedGossipMessage_clone(const struct LDKUnsignedGossipMessage *NONNULL_PTR orig);
/* @internal */
export function UnsignedGossipMessage_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedGossipMessage_clone(orig);
	return nativeResponseValue;
}
	// struct LDKUnsignedGossipMessage UnsignedGossipMessage_channel_announcement(struct LDKUnsignedChannelAnnouncement a);
/* @internal */
export function UnsignedGossipMessage_channel_announcement(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedGossipMessage_channel_announcement(a);
	return nativeResponseValue;
}
	// struct LDKUnsignedGossipMessage UnsignedGossipMessage_channel_update(struct LDKUnsignedChannelUpdate a);
/* @internal */
export function UnsignedGossipMessage_channel_update(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedGossipMessage_channel_update(a);
	return nativeResponseValue;
}
	// struct LDKUnsignedGossipMessage UnsignedGossipMessage_node_announcement(struct LDKUnsignedNodeAnnouncement a);
/* @internal */
export function UnsignedGossipMessage_node_announcement(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedGossipMessage_node_announcement(a);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UnsignedGossipMessage_write(const struct LDKUnsignedGossipMessage *NONNULL_PTR obj);
/* @internal */
export function UnsignedGossipMessage_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedGossipMessage_write(obj);
	return nativeResponseValue;
}
	// void UnsignedNodeAnnouncement_free(struct LDKUnsignedNodeAnnouncement this_obj);
/* @internal */
export function UnsignedNodeAnnouncement_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_free(this_obj);
	// debug statements here
}
	// struct LDKNodeFeatures UnsignedNodeAnnouncement_get_features(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedNodeAnnouncement_get_features(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_get_features(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedNodeAnnouncement_set_features(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);
/* @internal */
export function UnsignedNodeAnnouncement_set_features(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_features(this_ptr, val);
	// debug statements here
}
	// uint32_t UnsignedNodeAnnouncement_get_timestamp(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedNodeAnnouncement_get_timestamp(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_get_timestamp(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedNodeAnnouncement_set_timestamp(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function UnsignedNodeAnnouncement_set_timestamp(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_timestamp(this_ptr, val);
	// debug statements here
}
	// struct LDKNodeId UnsignedNodeAnnouncement_get_node_id(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedNodeAnnouncement_get_node_id(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_get_node_id(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedNodeAnnouncement_set_node_id(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeId val);
/* @internal */
export function UnsignedNodeAnnouncement_set_node_id(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_node_id(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*UnsignedNodeAnnouncement_get_rgb(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr))[3];
/* @internal */
export function UnsignedNodeAnnouncement_get_rgb(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_get_rgb(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedNodeAnnouncement_set_rgb(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKThreeBytes val);
/* @internal */
export function UnsignedNodeAnnouncement_set_rgb(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_rgb(this_ptr, val);
	// debug statements here
}
	// struct LDKNodeAlias UnsignedNodeAnnouncement_get_alias(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedNodeAnnouncement_get_alias(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_get_alias(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedNodeAnnouncement_set_alias(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeAlias val);
/* @internal */
export function UnsignedNodeAnnouncement_set_alias(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_alias(this_ptr, val);
	// debug statements here
}
	// struct LDKCVec_NetAddressZ UnsignedNodeAnnouncement_get_addresses(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedNodeAnnouncement_get_addresses(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_get_addresses(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedNodeAnnouncement_set_addresses(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKCVec_NetAddressZ val);
/* @internal */
export function UnsignedNodeAnnouncement_set_addresses(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_addresses(this_ptr, val);
	// debug statements here
}
	// uint64_t UnsignedNodeAnnouncement_clone_ptr(LDKUnsignedNodeAnnouncement *NONNULL_PTR arg);
/* @internal */
export function UnsignedNodeAnnouncement_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUnsignedNodeAnnouncement UnsignedNodeAnnouncement_clone(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR orig);
/* @internal */
export function UnsignedNodeAnnouncement_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_clone(orig);
	return nativeResponseValue;
}
	// bool UnsignedNodeAnnouncement_eq(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR a, const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR b);
/* @internal */
export function UnsignedNodeAnnouncement_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_eq(a, b);
	return nativeResponseValue;
}
	// void NodeAnnouncement_free(struct LDKNodeAnnouncement this_obj);
/* @internal */
export function NodeAnnouncement_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_free(this_obj);
	// debug statements here
}
	// struct LDKSignature NodeAnnouncement_get_signature(const struct LDKNodeAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function NodeAnnouncement_get_signature(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_get_signature(this_ptr);
	return nativeResponseValue;
}
	// void NodeAnnouncement_set_signature(struct LDKNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function NodeAnnouncement_set_signature(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_set_signature(this_ptr, val);
	// debug statements here
}
	// struct LDKUnsignedNodeAnnouncement NodeAnnouncement_get_contents(const struct LDKNodeAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function NodeAnnouncement_get_contents(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_get_contents(this_ptr);
	return nativeResponseValue;
}
	// void NodeAnnouncement_set_contents(struct LDKNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKUnsignedNodeAnnouncement val);
/* @internal */
export function NodeAnnouncement_set_contents(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_set_contents(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKNodeAnnouncement NodeAnnouncement_new(struct LDKSignature signature_arg, struct LDKUnsignedNodeAnnouncement contents_arg);
/* @internal */
export function NodeAnnouncement_new(signature_arg: number, contents_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_new(signature_arg, contents_arg);
	return nativeResponseValue;
}
	// uint64_t NodeAnnouncement_clone_ptr(LDKNodeAnnouncement *NONNULL_PTR arg);
/* @internal */
export function NodeAnnouncement_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKNodeAnnouncement NodeAnnouncement_clone(const struct LDKNodeAnnouncement *NONNULL_PTR orig);
/* @internal */
export function NodeAnnouncement_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_clone(orig);
	return nativeResponseValue;
}
	// bool NodeAnnouncement_eq(const struct LDKNodeAnnouncement *NONNULL_PTR a, const struct LDKNodeAnnouncement *NONNULL_PTR b);
/* @internal */
export function NodeAnnouncement_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_eq(a, b);
	return nativeResponseValue;
}
	// void UnsignedChannelAnnouncement_free(struct LDKUnsignedChannelAnnouncement this_obj);
/* @internal */
export function UnsignedChannelAnnouncement_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_free(this_obj);
	// debug statements here
}
	// struct LDKChannelFeatures UnsignedChannelAnnouncement_get_features(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelAnnouncement_get_features(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_features(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelAnnouncement_set_features(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);
/* @internal */
export function UnsignedChannelAnnouncement_set_features(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_features(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*UnsignedChannelAnnouncement_get_chain_hash(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UnsignedChannelAnnouncement_get_chain_hash(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_chain_hash(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelAnnouncement_set_chain_hash(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UnsignedChannelAnnouncement_set_chain_hash(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_chain_hash(this_ptr, val);
	// debug statements here
}
	// uint64_t UnsignedChannelAnnouncement_get_short_channel_id(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelAnnouncement_get_short_channel_id(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_short_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelAnnouncement_set_short_channel_id(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function UnsignedChannelAnnouncement_set_short_channel_id(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_short_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKNodeId UnsignedChannelAnnouncement_get_node_id_1(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelAnnouncement_get_node_id_1(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_node_id_1(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelAnnouncement_set_node_id_1(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeId val);
/* @internal */
export function UnsignedChannelAnnouncement_set_node_id_1(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_node_id_1(this_ptr, val);
	// debug statements here
}
	// struct LDKNodeId UnsignedChannelAnnouncement_get_node_id_2(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelAnnouncement_get_node_id_2(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_node_id_2(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelAnnouncement_set_node_id_2(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeId val);
/* @internal */
export function UnsignedChannelAnnouncement_set_node_id_2(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_node_id_2(this_ptr, val);
	// debug statements here
}
	// struct LDKNodeId UnsignedChannelAnnouncement_get_bitcoin_key_1(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelAnnouncement_get_bitcoin_key_1(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_bitcoin_key_1(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelAnnouncement_set_bitcoin_key_1(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeId val);
/* @internal */
export function UnsignedChannelAnnouncement_set_bitcoin_key_1(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_bitcoin_key_1(this_ptr, val);
	// debug statements here
}
	// struct LDKNodeId UnsignedChannelAnnouncement_get_bitcoin_key_2(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelAnnouncement_get_bitcoin_key_2(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_bitcoin_key_2(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelAnnouncement_set_bitcoin_key_2(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeId val);
/* @internal */
export function UnsignedChannelAnnouncement_set_bitcoin_key_2(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_bitcoin_key_2(this_ptr, val);
	// debug statements here
}
	// uint64_t UnsignedChannelAnnouncement_clone_ptr(LDKUnsignedChannelAnnouncement *NONNULL_PTR arg);
/* @internal */
export function UnsignedChannelAnnouncement_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUnsignedChannelAnnouncement UnsignedChannelAnnouncement_clone(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR orig);
/* @internal */
export function UnsignedChannelAnnouncement_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_clone(orig);
	return nativeResponseValue;
}
	// bool UnsignedChannelAnnouncement_eq(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR a, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR b);
/* @internal */
export function UnsignedChannelAnnouncement_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_eq(a, b);
	return nativeResponseValue;
}
	// void ChannelAnnouncement_free(struct LDKChannelAnnouncement this_obj);
/* @internal */
export function ChannelAnnouncement_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_free(this_obj);
	// debug statements here
}
	// struct LDKSignature ChannelAnnouncement_get_node_signature_1(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelAnnouncement_get_node_signature_1(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_get_node_signature_1(this_ptr);
	return nativeResponseValue;
}
	// void ChannelAnnouncement_set_node_signature_1(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function ChannelAnnouncement_set_node_signature_1(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_set_node_signature_1(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature ChannelAnnouncement_get_node_signature_2(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelAnnouncement_get_node_signature_2(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_get_node_signature_2(this_ptr);
	return nativeResponseValue;
}
	// void ChannelAnnouncement_set_node_signature_2(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function ChannelAnnouncement_set_node_signature_2(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_set_node_signature_2(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature ChannelAnnouncement_get_bitcoin_signature_1(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelAnnouncement_get_bitcoin_signature_1(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_get_bitcoin_signature_1(this_ptr);
	return nativeResponseValue;
}
	// void ChannelAnnouncement_set_bitcoin_signature_1(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function ChannelAnnouncement_set_bitcoin_signature_1(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_set_bitcoin_signature_1(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature ChannelAnnouncement_get_bitcoin_signature_2(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelAnnouncement_get_bitcoin_signature_2(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_get_bitcoin_signature_2(this_ptr);
	return nativeResponseValue;
}
	// void ChannelAnnouncement_set_bitcoin_signature_2(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function ChannelAnnouncement_set_bitcoin_signature_2(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_set_bitcoin_signature_2(this_ptr, val);
	// debug statements here
}
	// struct LDKUnsignedChannelAnnouncement ChannelAnnouncement_get_contents(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelAnnouncement_get_contents(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_get_contents(this_ptr);
	return nativeResponseValue;
}
	// void ChannelAnnouncement_set_contents(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKUnsignedChannelAnnouncement val);
/* @internal */
export function ChannelAnnouncement_set_contents(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_set_contents(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelAnnouncement ChannelAnnouncement_new(struct LDKSignature node_signature_1_arg, struct LDKSignature node_signature_2_arg, struct LDKSignature bitcoin_signature_1_arg, struct LDKSignature bitcoin_signature_2_arg, struct LDKUnsignedChannelAnnouncement contents_arg);
/* @internal */
export function ChannelAnnouncement_new(node_signature_1_arg: number, node_signature_2_arg: number, bitcoin_signature_1_arg: number, bitcoin_signature_2_arg: number, contents_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_new(node_signature_1_arg, node_signature_2_arg, bitcoin_signature_1_arg, bitcoin_signature_2_arg, contents_arg);
	return nativeResponseValue;
}
	// uint64_t ChannelAnnouncement_clone_ptr(LDKChannelAnnouncement *NONNULL_PTR arg);
/* @internal */
export function ChannelAnnouncement_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelAnnouncement ChannelAnnouncement_clone(const struct LDKChannelAnnouncement *NONNULL_PTR orig);
/* @internal */
export function ChannelAnnouncement_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_clone(orig);
	return nativeResponseValue;
}
	// bool ChannelAnnouncement_eq(const struct LDKChannelAnnouncement *NONNULL_PTR a, const struct LDKChannelAnnouncement *NONNULL_PTR b);
/* @internal */
export function ChannelAnnouncement_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_eq(a, b);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_free(struct LDKUnsignedChannelUpdate this_obj);
/* @internal */
export function UnsignedChannelUpdate_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_free(this_obj);
	// debug statements here
}
	// const uint8_t (*UnsignedChannelUpdate_get_chain_hash(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UnsignedChannelUpdate_get_chain_hash(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_chain_hash(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_chain_hash(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UnsignedChannelUpdate_set_chain_hash(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_chain_hash(this_ptr, val);
	// debug statements here
}
	// uint64_t UnsignedChannelUpdate_get_short_channel_id(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelUpdate_get_short_channel_id(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_short_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_short_channel_id(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function UnsignedChannelUpdate_set_short_channel_id(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_short_channel_id(this_ptr, val);
	// debug statements here
}
	// uint32_t UnsignedChannelUpdate_get_timestamp(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelUpdate_get_timestamp(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_timestamp(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_timestamp(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function UnsignedChannelUpdate_set_timestamp(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_timestamp(this_ptr, val);
	// debug statements here
}
	// uint8_t UnsignedChannelUpdate_get_flags(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelUpdate_get_flags(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_flags(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_flags(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint8_t val);
/* @internal */
export function UnsignedChannelUpdate_set_flags(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_flags(this_ptr, val);
	// debug statements here
}
	// uint16_t UnsignedChannelUpdate_get_cltv_expiry_delta(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelUpdate_get_cltv_expiry_delta(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_cltv_expiry_delta(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function UnsignedChannelUpdate_set_cltv_expiry_delta(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// uint64_t UnsignedChannelUpdate_get_htlc_minimum_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelUpdate_get_htlc_minimum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_htlc_minimum_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function UnsignedChannelUpdate_set_htlc_minimum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t UnsignedChannelUpdate_get_htlc_maximum_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelUpdate_get_htlc_maximum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_htlc_maximum_msat(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_htlc_maximum_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function UnsignedChannelUpdate_set_htlc_maximum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_htlc_maximum_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t UnsignedChannelUpdate_get_fee_base_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelUpdate_get_fee_base_msat(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_fee_base_msat(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_fee_base_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function UnsignedChannelUpdate_set_fee_base_msat(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_fee_base_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t UnsignedChannelUpdate_get_fee_proportional_millionths(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelUpdate_get_fee_proportional_millionths(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_fee_proportional_millionths(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_fee_proportional_millionths(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function UnsignedChannelUpdate_set_fee_proportional_millionths(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_fee_proportional_millionths(this_ptr, val);
	// debug statements here
}
	// struct LDKCVec_u8Z UnsignedChannelUpdate_get_excess_data(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelUpdate_get_excess_data(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_excess_data(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_excess_data(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);
/* @internal */
export function UnsignedChannelUpdate_set_excess_data(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_excess_data(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKUnsignedChannelUpdate UnsignedChannelUpdate_new(struct LDKThirtyTwoBytes chain_hash_arg, uint64_t short_channel_id_arg, uint32_t timestamp_arg, uint8_t flags_arg, uint16_t cltv_expiry_delta_arg, uint64_t htlc_minimum_msat_arg, uint64_t htlc_maximum_msat_arg, uint32_t fee_base_msat_arg, uint32_t fee_proportional_millionths_arg, struct LDKCVec_u8Z excess_data_arg);
/* @internal */
export function UnsignedChannelUpdate_new(chain_hash_arg: number, short_channel_id_arg: bigint, timestamp_arg: number, flags_arg: number, cltv_expiry_delta_arg: number, htlc_minimum_msat_arg: bigint, htlc_maximum_msat_arg: bigint, fee_base_msat_arg: number, fee_proportional_millionths_arg: number, excess_data_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_new(chain_hash_arg, short_channel_id_arg, timestamp_arg, flags_arg, cltv_expiry_delta_arg, htlc_minimum_msat_arg, htlc_maximum_msat_arg, fee_base_msat_arg, fee_proportional_millionths_arg, excess_data_arg);
	return nativeResponseValue;
}
	// uint64_t UnsignedChannelUpdate_clone_ptr(LDKUnsignedChannelUpdate *NONNULL_PTR arg);
/* @internal */
export function UnsignedChannelUpdate_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUnsignedChannelUpdate UnsignedChannelUpdate_clone(const struct LDKUnsignedChannelUpdate *NONNULL_PTR orig);
/* @internal */
export function UnsignedChannelUpdate_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_clone(orig);
	return nativeResponseValue;
}
	// bool UnsignedChannelUpdate_eq(const struct LDKUnsignedChannelUpdate *NONNULL_PTR a, const struct LDKUnsignedChannelUpdate *NONNULL_PTR b);
/* @internal */
export function UnsignedChannelUpdate_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_eq(a, b);
	return nativeResponseValue;
}
	// void ChannelUpdate_free(struct LDKChannelUpdate this_obj);
/* @internal */
export function ChannelUpdate_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_free(this_obj);
	// debug statements here
}
	// struct LDKSignature ChannelUpdate_get_signature(const struct LDKChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdate_get_signature(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_get_signature(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdate_set_signature(struct LDKChannelUpdate *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function ChannelUpdate_set_signature(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_set_signature(this_ptr, val);
	// debug statements here
}
	// struct LDKUnsignedChannelUpdate ChannelUpdate_get_contents(const struct LDKChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdate_get_contents(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_get_contents(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdate_set_contents(struct LDKChannelUpdate *NONNULL_PTR this_ptr, struct LDKUnsignedChannelUpdate val);
/* @internal */
export function ChannelUpdate_set_contents(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_set_contents(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelUpdate ChannelUpdate_new(struct LDKSignature signature_arg, struct LDKUnsignedChannelUpdate contents_arg);
/* @internal */
export function ChannelUpdate_new(signature_arg: number, contents_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_new(signature_arg, contents_arg);
	return nativeResponseValue;
}
	// uint64_t ChannelUpdate_clone_ptr(LDKChannelUpdate *NONNULL_PTR arg);
/* @internal */
export function ChannelUpdate_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelUpdate ChannelUpdate_clone(const struct LDKChannelUpdate *NONNULL_PTR orig);
/* @internal */
export function ChannelUpdate_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_clone(orig);
	return nativeResponseValue;
}
	// bool ChannelUpdate_eq(const struct LDKChannelUpdate *NONNULL_PTR a, const struct LDKChannelUpdate *NONNULL_PTR b);
/* @internal */
export function ChannelUpdate_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_eq(a, b);
	return nativeResponseValue;
}
	// void QueryChannelRange_free(struct LDKQueryChannelRange this_obj);
/* @internal */
export function QueryChannelRange_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_free(this_obj);
	// debug statements here
}
	// const uint8_t (*QueryChannelRange_get_chain_hash(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr))[32];
/* @internal */
export function QueryChannelRange_get_chain_hash(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_get_chain_hash(this_ptr);
	return nativeResponseValue;
}
	// void QueryChannelRange_set_chain_hash(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function QueryChannelRange_set_chain_hash(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_set_chain_hash(this_ptr, val);
	// debug statements here
}
	// uint32_t QueryChannelRange_get_first_blocknum(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr);
/* @internal */
export function QueryChannelRange_get_first_blocknum(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_get_first_blocknum(this_ptr);
	return nativeResponseValue;
}
	// void QueryChannelRange_set_first_blocknum(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function QueryChannelRange_set_first_blocknum(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_set_first_blocknum(this_ptr, val);
	// debug statements here
}
	// uint32_t QueryChannelRange_get_number_of_blocks(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr);
/* @internal */
export function QueryChannelRange_get_number_of_blocks(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_get_number_of_blocks(this_ptr);
	return nativeResponseValue;
}
	// void QueryChannelRange_set_number_of_blocks(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function QueryChannelRange_set_number_of_blocks(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_set_number_of_blocks(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKQueryChannelRange QueryChannelRange_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_blocknum_arg, uint32_t number_of_blocks_arg);
/* @internal */
export function QueryChannelRange_new(chain_hash_arg: number, first_blocknum_arg: number, number_of_blocks_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_new(chain_hash_arg, first_blocknum_arg, number_of_blocks_arg);
	return nativeResponseValue;
}
	// uint64_t QueryChannelRange_clone_ptr(LDKQueryChannelRange *NONNULL_PTR arg);
/* @internal */
export function QueryChannelRange_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKQueryChannelRange QueryChannelRange_clone(const struct LDKQueryChannelRange *NONNULL_PTR orig);
/* @internal */
export function QueryChannelRange_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_clone(orig);
	return nativeResponseValue;
}
	// bool QueryChannelRange_eq(const struct LDKQueryChannelRange *NONNULL_PTR a, const struct LDKQueryChannelRange *NONNULL_PTR b);
/* @internal */
export function QueryChannelRange_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_eq(a, b);
	return nativeResponseValue;
}
	// void ReplyChannelRange_free(struct LDKReplyChannelRange this_obj);
/* @internal */
export function ReplyChannelRange_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_free(this_obj);
	// debug statements here
}
	// const uint8_t (*ReplyChannelRange_get_chain_hash(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr))[32];
/* @internal */
export function ReplyChannelRange_get_chain_hash(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_get_chain_hash(this_ptr);
	return nativeResponseValue;
}
	// void ReplyChannelRange_set_chain_hash(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function ReplyChannelRange_set_chain_hash(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_set_chain_hash(this_ptr, val);
	// debug statements here
}
	// uint32_t ReplyChannelRange_get_first_blocknum(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);
/* @internal */
export function ReplyChannelRange_get_first_blocknum(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_get_first_blocknum(this_ptr);
	return nativeResponseValue;
}
	// void ReplyChannelRange_set_first_blocknum(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function ReplyChannelRange_set_first_blocknum(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_set_first_blocknum(this_ptr, val);
	// debug statements here
}
	// uint32_t ReplyChannelRange_get_number_of_blocks(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);
/* @internal */
export function ReplyChannelRange_get_number_of_blocks(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_get_number_of_blocks(this_ptr);
	return nativeResponseValue;
}
	// void ReplyChannelRange_set_number_of_blocks(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function ReplyChannelRange_set_number_of_blocks(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_set_number_of_blocks(this_ptr, val);
	// debug statements here
}
	// bool ReplyChannelRange_get_sync_complete(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);
/* @internal */
export function ReplyChannelRange_get_sync_complete(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_get_sync_complete(this_ptr);
	return nativeResponseValue;
}
	// void ReplyChannelRange_set_sync_complete(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ReplyChannelRange_set_sync_complete(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_set_sync_complete(this_ptr, val);
	// debug statements here
}
	// struct LDKCVec_u64Z ReplyChannelRange_get_short_channel_ids(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);
/* @internal */
export function ReplyChannelRange_get_short_channel_ids(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_get_short_channel_ids(this_ptr);
	return nativeResponseValue;
}
	// void ReplyChannelRange_set_short_channel_ids(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);
/* @internal */
export function ReplyChannelRange_set_short_channel_ids(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_set_short_channel_ids(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKReplyChannelRange ReplyChannelRange_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_blocknum_arg, uint32_t number_of_blocks_arg, bool sync_complete_arg, struct LDKCVec_u64Z short_channel_ids_arg);
/* @internal */
export function ReplyChannelRange_new(chain_hash_arg: number, first_blocknum_arg: number, number_of_blocks_arg: number, sync_complete_arg: boolean, short_channel_ids_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_new(chain_hash_arg, first_blocknum_arg, number_of_blocks_arg, sync_complete_arg, short_channel_ids_arg);
	return nativeResponseValue;
}
	// uint64_t ReplyChannelRange_clone_ptr(LDKReplyChannelRange *NONNULL_PTR arg);
/* @internal */
export function ReplyChannelRange_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKReplyChannelRange ReplyChannelRange_clone(const struct LDKReplyChannelRange *NONNULL_PTR orig);
/* @internal */
export function ReplyChannelRange_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_clone(orig);
	return nativeResponseValue;
}
	// bool ReplyChannelRange_eq(const struct LDKReplyChannelRange *NONNULL_PTR a, const struct LDKReplyChannelRange *NONNULL_PTR b);
/* @internal */
export function ReplyChannelRange_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_eq(a, b);
	return nativeResponseValue;
}
	// void QueryShortChannelIds_free(struct LDKQueryShortChannelIds this_obj);
/* @internal */
export function QueryShortChannelIds_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_free(this_obj);
	// debug statements here
}
	// const uint8_t (*QueryShortChannelIds_get_chain_hash(const struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr))[32];
/* @internal */
export function QueryShortChannelIds_get_chain_hash(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_get_chain_hash(this_ptr);
	return nativeResponseValue;
}
	// void QueryShortChannelIds_set_chain_hash(struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function QueryShortChannelIds_set_chain_hash(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_set_chain_hash(this_ptr, val);
	// debug statements here
}
	// struct LDKCVec_u64Z QueryShortChannelIds_get_short_channel_ids(const struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr);
/* @internal */
export function QueryShortChannelIds_get_short_channel_ids(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_get_short_channel_ids(this_ptr);
	return nativeResponseValue;
}
	// void QueryShortChannelIds_set_short_channel_ids(struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);
/* @internal */
export function QueryShortChannelIds_set_short_channel_ids(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_set_short_channel_ids(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKQueryShortChannelIds QueryShortChannelIds_new(struct LDKThirtyTwoBytes chain_hash_arg, struct LDKCVec_u64Z short_channel_ids_arg);
/* @internal */
export function QueryShortChannelIds_new(chain_hash_arg: number, short_channel_ids_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_new(chain_hash_arg, short_channel_ids_arg);
	return nativeResponseValue;
}
	// uint64_t QueryShortChannelIds_clone_ptr(LDKQueryShortChannelIds *NONNULL_PTR arg);
/* @internal */
export function QueryShortChannelIds_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKQueryShortChannelIds QueryShortChannelIds_clone(const struct LDKQueryShortChannelIds *NONNULL_PTR orig);
/* @internal */
export function QueryShortChannelIds_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_clone(orig);
	return nativeResponseValue;
}
	// bool QueryShortChannelIds_eq(const struct LDKQueryShortChannelIds *NONNULL_PTR a, const struct LDKQueryShortChannelIds *NONNULL_PTR b);
/* @internal */
export function QueryShortChannelIds_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_eq(a, b);
	return nativeResponseValue;
}
	// void ReplyShortChannelIdsEnd_free(struct LDKReplyShortChannelIdsEnd this_obj);
/* @internal */
export function ReplyShortChannelIdsEnd_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_free(this_obj);
	// debug statements here
}
	// const uint8_t (*ReplyShortChannelIdsEnd_get_chain_hash(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr))[32];
/* @internal */
export function ReplyShortChannelIdsEnd_get_chain_hash(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_get_chain_hash(this_ptr);
	return nativeResponseValue;
}
	// void ReplyShortChannelIdsEnd_set_chain_hash(struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function ReplyShortChannelIdsEnd_set_chain_hash(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_set_chain_hash(this_ptr, val);
	// debug statements here
}
	// bool ReplyShortChannelIdsEnd_get_full_information(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr);
/* @internal */
export function ReplyShortChannelIdsEnd_get_full_information(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_get_full_information(this_ptr);
	return nativeResponseValue;
}
	// void ReplyShortChannelIdsEnd_set_full_information(struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ReplyShortChannelIdsEnd_set_full_information(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_set_full_information(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_new(struct LDKThirtyTwoBytes chain_hash_arg, bool full_information_arg);
/* @internal */
export function ReplyShortChannelIdsEnd_new(chain_hash_arg: number, full_information_arg: boolean): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_new(chain_hash_arg, full_information_arg);
	return nativeResponseValue;
}
	// uint64_t ReplyShortChannelIdsEnd_clone_ptr(LDKReplyShortChannelIdsEnd *NONNULL_PTR arg);
/* @internal */
export function ReplyShortChannelIdsEnd_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_clone(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR orig);
/* @internal */
export function ReplyShortChannelIdsEnd_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_clone(orig);
	return nativeResponseValue;
}
	// bool ReplyShortChannelIdsEnd_eq(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR a, const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR b);
/* @internal */
export function ReplyShortChannelIdsEnd_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_eq(a, b);
	return nativeResponseValue;
}
	// void GossipTimestampFilter_free(struct LDKGossipTimestampFilter this_obj);
/* @internal */
export function GossipTimestampFilter_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_free(this_obj);
	// debug statements here
}
	// const uint8_t (*GossipTimestampFilter_get_chain_hash(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr))[32];
/* @internal */
export function GossipTimestampFilter_get_chain_hash(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_get_chain_hash(this_ptr);
	return nativeResponseValue;
}
	// void GossipTimestampFilter_set_chain_hash(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function GossipTimestampFilter_set_chain_hash(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_set_chain_hash(this_ptr, val);
	// debug statements here
}
	// uint32_t GossipTimestampFilter_get_first_timestamp(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr);
/* @internal */
export function GossipTimestampFilter_get_first_timestamp(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_get_first_timestamp(this_ptr);
	return nativeResponseValue;
}
	// void GossipTimestampFilter_set_first_timestamp(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function GossipTimestampFilter_set_first_timestamp(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_set_first_timestamp(this_ptr, val);
	// debug statements here
}
	// uint32_t GossipTimestampFilter_get_timestamp_range(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr);
/* @internal */
export function GossipTimestampFilter_get_timestamp_range(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_get_timestamp_range(this_ptr);
	return nativeResponseValue;
}
	// void GossipTimestampFilter_set_timestamp_range(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function GossipTimestampFilter_set_timestamp_range(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_set_timestamp_range(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKGossipTimestampFilter GossipTimestampFilter_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_timestamp_arg, uint32_t timestamp_range_arg);
/* @internal */
export function GossipTimestampFilter_new(chain_hash_arg: number, first_timestamp_arg: number, timestamp_range_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_new(chain_hash_arg, first_timestamp_arg, timestamp_range_arg);
	return nativeResponseValue;
}
	// uint64_t GossipTimestampFilter_clone_ptr(LDKGossipTimestampFilter *NONNULL_PTR arg);
/* @internal */
export function GossipTimestampFilter_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKGossipTimestampFilter GossipTimestampFilter_clone(const struct LDKGossipTimestampFilter *NONNULL_PTR orig);
/* @internal */
export function GossipTimestampFilter_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_clone(orig);
	return nativeResponseValue;
}
	// bool GossipTimestampFilter_eq(const struct LDKGossipTimestampFilter *NONNULL_PTR a, const struct LDKGossipTimestampFilter *NONNULL_PTR b);
/* @internal */
export function GossipTimestampFilter_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_eq(a, b);
	return nativeResponseValue;
}
	// void ErrorAction_free(struct LDKErrorAction this_ptr);
/* @internal */
export function ErrorAction_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_free(this_ptr);
	// debug statements here
}
	// uint64_t ErrorAction_clone_ptr(LDKErrorAction *NONNULL_PTR arg);
/* @internal */
export function ErrorAction_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKErrorAction ErrorAction_clone(const struct LDKErrorAction *NONNULL_PTR orig);
/* @internal */
export function ErrorAction_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_clone(orig);
	return nativeResponseValue;
}
	// struct LDKErrorAction ErrorAction_disconnect_peer(struct LDKErrorMessage msg);
/* @internal */
export function ErrorAction_disconnect_peer(msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_disconnect_peer(msg);
	return nativeResponseValue;
}
	// struct LDKErrorAction ErrorAction_disconnect_peer_with_warning(struct LDKWarningMessage msg);
/* @internal */
export function ErrorAction_disconnect_peer_with_warning(msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_disconnect_peer_with_warning(msg);
	return nativeResponseValue;
}
	// struct LDKErrorAction ErrorAction_ignore_error(void);
/* @internal */
export function ErrorAction_ignore_error(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_ignore_error();
	return nativeResponseValue;
}
	// struct LDKErrorAction ErrorAction_ignore_and_log(enum LDKLevel a);
/* @internal */
export function ErrorAction_ignore_and_log(a: Level): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_ignore_and_log(a);
	return nativeResponseValue;
}
	// struct LDKErrorAction ErrorAction_ignore_duplicate_gossip(void);
/* @internal */
export function ErrorAction_ignore_duplicate_gossip(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_ignore_duplicate_gossip();
	return nativeResponseValue;
}
	// struct LDKErrorAction ErrorAction_send_error_message(struct LDKErrorMessage msg);
/* @internal */
export function ErrorAction_send_error_message(msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_send_error_message(msg);
	return nativeResponseValue;
}
	// struct LDKErrorAction ErrorAction_send_warning_message(struct LDKWarningMessage msg, enum LDKLevel log_level);
/* @internal */
export function ErrorAction_send_warning_message(msg: bigint, log_level: Level): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_send_warning_message(msg, log_level);
	return nativeResponseValue;
}
	// void LightningError_free(struct LDKLightningError this_obj);
/* @internal */
export function LightningError_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LightningError_free(this_obj);
	// debug statements here
}
	// struct LDKStr LightningError_get_err(const struct LDKLightningError *NONNULL_PTR this_ptr);
/* @internal */
export function LightningError_get_err(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LightningError_get_err(this_ptr);
	return nativeResponseValue;
}
	// void LightningError_set_err(struct LDKLightningError *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */
export function LightningError_set_err(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LightningError_set_err(this_ptr, val);
	// debug statements here
}
	// struct LDKErrorAction LightningError_get_action(const struct LDKLightningError *NONNULL_PTR this_ptr);
/* @internal */
export function LightningError_get_action(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LightningError_get_action(this_ptr);
	return nativeResponseValue;
}
	// void LightningError_set_action(struct LDKLightningError *NONNULL_PTR this_ptr, struct LDKErrorAction val);
/* @internal */
export function LightningError_set_action(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LightningError_set_action(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKLightningError LightningError_new(struct LDKStr err_arg, struct LDKErrorAction action_arg);
/* @internal */
export function LightningError_new(err_arg: number, action_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LightningError_new(err_arg, action_arg);
	return nativeResponseValue;
}
	// uint64_t LightningError_clone_ptr(LDKLightningError *NONNULL_PTR arg);
/* @internal */
export function LightningError_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LightningError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKLightningError LightningError_clone(const struct LDKLightningError *NONNULL_PTR orig);
/* @internal */
export function LightningError_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LightningError_clone(orig);
	return nativeResponseValue;
}
	// void CommitmentUpdate_free(struct LDKCommitmentUpdate this_obj);
/* @internal */
export function CommitmentUpdate_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_free(this_obj);
	// debug statements here
}
	// struct LDKCVec_UpdateAddHTLCZ CommitmentUpdate_get_update_add_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function CommitmentUpdate_get_update_add_htlcs(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_get_update_add_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void CommitmentUpdate_set_update_add_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateAddHTLCZ val);
/* @internal */
export function CommitmentUpdate_set_update_add_htlcs(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_set_update_add_htlcs(this_ptr, val);
	// debug statements here
}
	// struct LDKCVec_UpdateFulfillHTLCZ CommitmentUpdate_get_update_fulfill_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function CommitmentUpdate_get_update_fulfill_htlcs(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_get_update_fulfill_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void CommitmentUpdate_set_update_fulfill_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFulfillHTLCZ val);
/* @internal */
export function CommitmentUpdate_set_update_fulfill_htlcs(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_set_update_fulfill_htlcs(this_ptr, val);
	// debug statements here
}
	// struct LDKCVec_UpdateFailHTLCZ CommitmentUpdate_get_update_fail_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function CommitmentUpdate_get_update_fail_htlcs(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_get_update_fail_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void CommitmentUpdate_set_update_fail_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFailHTLCZ val);
/* @internal */
export function CommitmentUpdate_set_update_fail_htlcs(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_set_update_fail_htlcs(this_ptr, val);
	// debug statements here
}
	// struct LDKCVec_UpdateFailMalformedHTLCZ CommitmentUpdate_get_update_fail_malformed_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function CommitmentUpdate_get_update_fail_malformed_htlcs(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_get_update_fail_malformed_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void CommitmentUpdate_set_update_fail_malformed_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFailMalformedHTLCZ val);
/* @internal */
export function CommitmentUpdate_set_update_fail_malformed_htlcs(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_set_update_fail_malformed_htlcs(this_ptr, val);
	// debug statements here
}
	// struct LDKUpdateFee CommitmentUpdate_get_update_fee(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function CommitmentUpdate_get_update_fee(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_get_update_fee(this_ptr);
	return nativeResponseValue;
}
	// void CommitmentUpdate_set_update_fee(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKUpdateFee val);
/* @internal */
export function CommitmentUpdate_set_update_fee(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_set_update_fee(this_ptr, val);
	// debug statements here
}
	// struct LDKCommitmentSigned CommitmentUpdate_get_commitment_signed(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function CommitmentUpdate_get_commitment_signed(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_get_commitment_signed(this_ptr);
	return nativeResponseValue;
}
	// void CommitmentUpdate_set_commitment_signed(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCommitmentSigned val);
/* @internal */
export function CommitmentUpdate_set_commitment_signed(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_set_commitment_signed(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKCommitmentUpdate CommitmentUpdate_new(struct LDKCVec_UpdateAddHTLCZ update_add_htlcs_arg, struct LDKCVec_UpdateFulfillHTLCZ update_fulfill_htlcs_arg, struct LDKCVec_UpdateFailHTLCZ update_fail_htlcs_arg, struct LDKCVec_UpdateFailMalformedHTLCZ update_fail_malformed_htlcs_arg, struct LDKUpdateFee update_fee_arg, struct LDKCommitmentSigned commitment_signed_arg);
/* @internal */
export function CommitmentUpdate_new(update_add_htlcs_arg: number, update_fulfill_htlcs_arg: number, update_fail_htlcs_arg: number, update_fail_malformed_htlcs_arg: number, update_fee_arg: bigint, commitment_signed_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_new(update_add_htlcs_arg, update_fulfill_htlcs_arg, update_fail_htlcs_arg, update_fail_malformed_htlcs_arg, update_fee_arg, commitment_signed_arg);
	return nativeResponseValue;
}
	// uint64_t CommitmentUpdate_clone_ptr(LDKCommitmentUpdate *NONNULL_PTR arg);
/* @internal */
export function CommitmentUpdate_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCommitmentUpdate CommitmentUpdate_clone(const struct LDKCommitmentUpdate *NONNULL_PTR orig);
/* @internal */
export function CommitmentUpdate_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_clone(orig);
	return nativeResponseValue;
}
	// bool CommitmentUpdate_eq(const struct LDKCommitmentUpdate *NONNULL_PTR a, const struct LDKCommitmentUpdate *NONNULL_PTR b);
/* @internal */
export function CommitmentUpdate_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_eq(a, b);
	return nativeResponseValue;
}
	// void ChannelMessageHandler_free(struct LDKChannelMessageHandler this_ptr);
/* @internal */
export function ChannelMessageHandler_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_free(this_ptr);
	// debug statements here
}
	// void RoutingMessageHandler_free(struct LDKRoutingMessageHandler this_ptr);
/* @internal */
export function RoutingMessageHandler_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_free(this_ptr);
	// debug statements here
}
	// void OnionMessageHandler_free(struct LDKOnionMessageHandler this_ptr);
/* @internal */
export function OnionMessageHandler_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessageHandler_free(this_ptr);
	// debug statements here
}
	// struct LDKCVec_u8Z AcceptChannel_write(const struct LDKAcceptChannel *NONNULL_PTR obj);
/* @internal */
export function AcceptChannel_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_AcceptChannelDecodeErrorZ AcceptChannel_read(struct LDKu8slice ser);
/* @internal */
export function AcceptChannel_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z AcceptChannelV2_write(const struct LDKAcceptChannelV2 *NONNULL_PTR obj);
/* @internal */
export function AcceptChannelV2_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_AcceptChannelV2DecodeErrorZ AcceptChannelV2_read(struct LDKu8slice ser);
/* @internal */
export function AcceptChannelV2_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannelV2_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z TxAddInput_write(const struct LDKTxAddInput *NONNULL_PTR obj);
/* @internal */
export function TxAddInput_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddInput_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_TxAddInputDecodeErrorZ TxAddInput_read(struct LDKu8slice ser);
/* @internal */
export function TxAddInput_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddInput_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z TxAddOutput_write(const struct LDKTxAddOutput *NONNULL_PTR obj);
/* @internal */
export function TxAddOutput_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddOutput_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_TxAddOutputDecodeErrorZ TxAddOutput_read(struct LDKu8slice ser);
/* @internal */
export function TxAddOutput_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAddOutput_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z TxRemoveInput_write(const struct LDKTxRemoveInput *NONNULL_PTR obj);
/* @internal */
export function TxRemoveInput_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveInput_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_TxRemoveInputDecodeErrorZ TxRemoveInput_read(struct LDKu8slice ser);
/* @internal */
export function TxRemoveInput_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveInput_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z TxRemoveOutput_write(const struct LDKTxRemoveOutput *NONNULL_PTR obj);
/* @internal */
export function TxRemoveOutput_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveOutput_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_TxRemoveOutputDecodeErrorZ TxRemoveOutput_read(struct LDKu8slice ser);
/* @internal */
export function TxRemoveOutput_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxRemoveOutput_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z TxComplete_write(const struct LDKTxComplete *NONNULL_PTR obj);
/* @internal */
export function TxComplete_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxComplete_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_TxCompleteDecodeErrorZ TxComplete_read(struct LDKu8slice ser);
/* @internal */
export function TxComplete_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxComplete_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z TxSignatures_write(const struct LDKTxSignatures *NONNULL_PTR obj);
/* @internal */
export function TxSignatures_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxSignatures_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_TxSignaturesDecodeErrorZ TxSignatures_read(struct LDKu8slice ser);
/* @internal */
export function TxSignatures_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxSignatures_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z TxInitRbf_write(const struct LDKTxInitRbf *NONNULL_PTR obj);
/* @internal */
export function TxInitRbf_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxInitRbf_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_TxInitRbfDecodeErrorZ TxInitRbf_read(struct LDKu8slice ser);
/* @internal */
export function TxInitRbf_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxInitRbf_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z TxAckRbf_write(const struct LDKTxAckRbf *NONNULL_PTR obj);
/* @internal */
export function TxAckRbf_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAckRbf_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_TxAckRbfDecodeErrorZ TxAckRbf_read(struct LDKu8slice ser);
/* @internal */
export function TxAckRbf_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAckRbf_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z TxAbort_write(const struct LDKTxAbort *NONNULL_PTR obj);
/* @internal */
export function TxAbort_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAbort_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_TxAbortDecodeErrorZ TxAbort_read(struct LDKu8slice ser);
/* @internal */
export function TxAbort_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxAbort_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z AnnouncementSignatures_write(const struct LDKAnnouncementSignatures *NONNULL_PTR obj);
/* @internal */
export function AnnouncementSignatures_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_AnnouncementSignaturesDecodeErrorZ AnnouncementSignatures_read(struct LDKu8slice ser);
/* @internal */
export function AnnouncementSignatures_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelReestablish_write(const struct LDKChannelReestablish *NONNULL_PTR obj);
/* @internal */
export function ChannelReestablish_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelReestablishDecodeErrorZ ChannelReestablish_read(struct LDKu8slice ser);
/* @internal */
export function ChannelReestablish_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ClosingSigned_write(const struct LDKClosingSigned *NONNULL_PTR obj);
/* @internal */
export function ClosingSigned_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ClosingSignedDecodeErrorZ ClosingSigned_read(struct LDKu8slice ser);
/* @internal */
export function ClosingSigned_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ClosingSignedFeeRange_write(const struct LDKClosingSignedFeeRange *NONNULL_PTR obj);
/* @internal */
export function ClosingSignedFeeRange_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ ClosingSignedFeeRange_read(struct LDKu8slice ser);
/* @internal */
export function ClosingSignedFeeRange_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z CommitmentSigned_write(const struct LDKCommitmentSigned *NONNULL_PTR obj);
/* @internal */
export function CommitmentSigned_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_CommitmentSignedDecodeErrorZ CommitmentSigned_read(struct LDKu8slice ser);
/* @internal */
export function CommitmentSigned_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z FundingCreated_write(const struct LDKFundingCreated *NONNULL_PTR obj);
/* @internal */
export function FundingCreated_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingCreatedDecodeErrorZ FundingCreated_read(struct LDKu8slice ser);
/* @internal */
export function FundingCreated_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z FundingSigned_write(const struct LDKFundingSigned *NONNULL_PTR obj);
/* @internal */
export function FundingSigned_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingSignedDecodeErrorZ FundingSigned_read(struct LDKu8slice ser);
/* @internal */
export function FundingSigned_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelReady_write(const struct LDKChannelReady *NONNULL_PTR obj);
/* @internal */
export function ChannelReady_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReady_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelReadyDecodeErrorZ ChannelReady_read(struct LDKu8slice ser);
/* @internal */
export function ChannelReady_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReady_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Init_write(const struct LDKInit *NONNULL_PTR obj);
/* @internal */
export function Init_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_InitDecodeErrorZ Init_read(struct LDKu8slice ser);
/* @internal */
export function Init_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z OpenChannel_write(const struct LDKOpenChannel *NONNULL_PTR obj);
/* @internal */
export function OpenChannel_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_OpenChannelDecodeErrorZ OpenChannel_read(struct LDKu8slice ser);
/* @internal */
export function OpenChannel_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z OpenChannelV2_write(const struct LDKOpenChannelV2 *NONNULL_PTR obj);
/* @internal */
export function OpenChannelV2_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_OpenChannelV2DecodeErrorZ OpenChannelV2_read(struct LDKu8slice ser);
/* @internal */
export function OpenChannelV2_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannelV2_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z RevokeAndACK_write(const struct LDKRevokeAndACK *NONNULL_PTR obj);
/* @internal */
export function RevokeAndACK_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_RevokeAndACKDecodeErrorZ RevokeAndACK_read(struct LDKu8slice ser);
/* @internal */
export function RevokeAndACK_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Shutdown_write(const struct LDKShutdown *NONNULL_PTR obj);
/* @internal */
export function Shutdown_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownDecodeErrorZ Shutdown_read(struct LDKu8slice ser);
/* @internal */
export function Shutdown_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UpdateFailHTLC_write(const struct LDKUpdateFailHTLC *NONNULL_PTR obj);
/* @internal */
export function UpdateFailHTLC_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFailHTLCDecodeErrorZ UpdateFailHTLC_read(struct LDKu8slice ser);
/* @internal */
export function UpdateFailHTLC_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UpdateFailMalformedHTLC_write(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR obj);
/* @internal */
export function UpdateFailMalformedHTLC_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ UpdateFailMalformedHTLC_read(struct LDKu8slice ser);
/* @internal */
export function UpdateFailMalformedHTLC_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UpdateFee_write(const struct LDKUpdateFee *NONNULL_PTR obj);
/* @internal */
export function UpdateFee_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFeeDecodeErrorZ UpdateFee_read(struct LDKu8slice ser);
/* @internal */
export function UpdateFee_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UpdateFulfillHTLC_write(const struct LDKUpdateFulfillHTLC *NONNULL_PTR obj);
/* @internal */
export function UpdateFulfillHTLC_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ UpdateFulfillHTLC_read(struct LDKu8slice ser);
/* @internal */
export function UpdateFulfillHTLC_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UpdateAddHTLC_write(const struct LDKUpdateAddHTLC *NONNULL_PTR obj);
/* @internal */
export function UpdateAddHTLC_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateAddHTLCDecodeErrorZ UpdateAddHTLC_read(struct LDKu8slice ser);
/* @internal */
export function UpdateAddHTLC_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_read(ser);
	return nativeResponseValue;
}
	// struct LDKCResult_OnionMessageDecodeErrorZ OnionMessage_read(struct LDKu8slice ser);
/* @internal */
export function OnionMessage_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessage_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z OnionMessage_write(const struct LDKOnionMessage *NONNULL_PTR obj);
/* @internal */
export function OnionMessage_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessage_write(obj);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Ping_write(const struct LDKPing *NONNULL_PTR obj);
/* @internal */
export function Ping_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_PingDecodeErrorZ Ping_read(struct LDKu8slice ser);
/* @internal */
export function Ping_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Pong_write(const struct LDKPong *NONNULL_PTR obj);
/* @internal */
export function Pong_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Pong_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_PongDecodeErrorZ Pong_read(struct LDKu8slice ser);
/* @internal */
export function Pong_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Pong_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UnsignedChannelAnnouncement_write(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR obj);
/* @internal */
export function UnsignedChannelAnnouncement_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ UnsignedChannelAnnouncement_read(struct LDKu8slice ser);
/* @internal */
export function UnsignedChannelAnnouncement_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelAnnouncement_write(const struct LDKChannelAnnouncement *NONNULL_PTR obj);
/* @internal */
export function ChannelAnnouncement_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelAnnouncementDecodeErrorZ ChannelAnnouncement_read(struct LDKu8slice ser);
/* @internal */
export function ChannelAnnouncement_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UnsignedChannelUpdate_write(const struct LDKUnsignedChannelUpdate *NONNULL_PTR obj);
/* @internal */
export function UnsignedChannelUpdate_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ UnsignedChannelUpdate_read(struct LDKu8slice ser);
/* @internal */
export function UnsignedChannelUpdate_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelUpdate_write(const struct LDKChannelUpdate *NONNULL_PTR obj);
/* @internal */
export function ChannelUpdate_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelUpdateDecodeErrorZ ChannelUpdate_read(struct LDKu8slice ser);
/* @internal */
export function ChannelUpdate_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ErrorMessage_write(const struct LDKErrorMessage *NONNULL_PTR obj);
/* @internal */
export function ErrorMessage_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ErrorMessageDecodeErrorZ ErrorMessage_read(struct LDKu8slice ser);
/* @internal */
export function ErrorMessage_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z WarningMessage_write(const struct LDKWarningMessage *NONNULL_PTR obj);
/* @internal */
export function WarningMessage_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_WarningMessageDecodeErrorZ WarningMessage_read(struct LDKu8slice ser);
/* @internal */
export function WarningMessage_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UnsignedNodeAnnouncement_write(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR obj);
/* @internal */
export function UnsignedNodeAnnouncement_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ UnsignedNodeAnnouncement_read(struct LDKu8slice ser);
/* @internal */
export function UnsignedNodeAnnouncement_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z NodeAnnouncement_write(const struct LDKNodeAnnouncement *NONNULL_PTR obj);
/* @internal */
export function NodeAnnouncement_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAnnouncementDecodeErrorZ NodeAnnouncement_read(struct LDKu8slice ser);
/* @internal */
export function NodeAnnouncement_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_read(ser);
	return nativeResponseValue;
}
	// struct LDKCResult_QueryShortChannelIdsDecodeErrorZ QueryShortChannelIds_read(struct LDKu8slice ser);
/* @internal */
export function QueryShortChannelIds_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z QueryShortChannelIds_write(const struct LDKQueryShortChannelIds *NONNULL_PTR obj);
/* @internal */
export function QueryShortChannelIds_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_write(obj);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ReplyShortChannelIdsEnd_write(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR obj);
/* @internal */
export function ReplyShortChannelIdsEnd_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ ReplyShortChannelIdsEnd_read(struct LDKu8slice ser);
/* @internal */
export function ReplyShortChannelIdsEnd_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_read(ser);
	return nativeResponseValue;
}
	// MUST_USE_RES uint32_t QueryChannelRange_end_blocknum(const struct LDKQueryChannelRange *NONNULL_PTR this_arg);
/* @internal */
export function QueryChannelRange_end_blocknum(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_end_blocknum(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z QueryChannelRange_write(const struct LDKQueryChannelRange *NONNULL_PTR obj);
/* @internal */
export function QueryChannelRange_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_QueryChannelRangeDecodeErrorZ QueryChannelRange_read(struct LDKu8slice ser);
/* @internal */
export function QueryChannelRange_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_read(ser);
	return nativeResponseValue;
}
	// struct LDKCResult_ReplyChannelRangeDecodeErrorZ ReplyChannelRange_read(struct LDKu8slice ser);
/* @internal */
export function ReplyChannelRange_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ReplyChannelRange_write(const struct LDKReplyChannelRange *NONNULL_PTR obj);
/* @internal */
export function ReplyChannelRange_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_write(obj);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z GossipTimestampFilter_write(const struct LDKGossipTimestampFilter *NONNULL_PTR obj);
/* @internal */
export function GossipTimestampFilter_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_GossipTimestampFilterDecodeErrorZ GossipTimestampFilter_read(struct LDKu8slice ser);
/* @internal */
export function GossipTimestampFilter_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_read(ser);
	return nativeResponseValue;
}
	// void CustomMessageHandler_free(struct LDKCustomMessageHandler this_ptr);
/* @internal */
export function CustomMessageHandler_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomMessageHandler_free(this_ptr);
	// debug statements here
}
	// void IgnoringMessageHandler_free(struct LDKIgnoringMessageHandler this_obj);
/* @internal */
export function IgnoringMessageHandler_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_IgnoringMessageHandler_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKIgnoringMessageHandler IgnoringMessageHandler_new(void);
/* @internal */
export function IgnoringMessageHandler_new(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_IgnoringMessageHandler_new();
	return nativeResponseValue;
}
	// struct LDKMessageSendEventsProvider IgnoringMessageHandler_as_MessageSendEventsProvider(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);
/* @internal */
export function IgnoringMessageHandler_as_MessageSendEventsProvider(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_IgnoringMessageHandler_as_MessageSendEventsProvider(this_arg);
	return nativeResponseValue;
}
	// struct LDKRoutingMessageHandler IgnoringMessageHandler_as_RoutingMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);
/* @internal */
export function IgnoringMessageHandler_as_RoutingMessageHandler(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_IgnoringMessageHandler_as_RoutingMessageHandler(this_arg);
	return nativeResponseValue;
}
	// struct LDKOnionMessageProvider IgnoringMessageHandler_as_OnionMessageProvider(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);
/* @internal */
export function IgnoringMessageHandler_as_OnionMessageProvider(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_IgnoringMessageHandler_as_OnionMessageProvider(this_arg);
	return nativeResponseValue;
}
	// struct LDKOnionMessageHandler IgnoringMessageHandler_as_OnionMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);
/* @internal */
export function IgnoringMessageHandler_as_OnionMessageHandler(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_IgnoringMessageHandler_as_OnionMessageHandler(this_arg);
	return nativeResponseValue;
}
	// struct LDKOffersMessageHandler IgnoringMessageHandler_as_OffersMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);
/* @internal */
export function IgnoringMessageHandler_as_OffersMessageHandler(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_IgnoringMessageHandler_as_OffersMessageHandler(this_arg);
	return nativeResponseValue;
}
	// struct LDKCustomOnionMessageHandler IgnoringMessageHandler_as_CustomOnionMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);
/* @internal */
export function IgnoringMessageHandler_as_CustomOnionMessageHandler(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_IgnoringMessageHandler_as_CustomOnionMessageHandler(this_arg);
	return nativeResponseValue;
}
	// struct LDKCustomMessageReader IgnoringMessageHandler_as_CustomMessageReader(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);
/* @internal */
export function IgnoringMessageHandler_as_CustomMessageReader(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_IgnoringMessageHandler_as_CustomMessageReader(this_arg);
	return nativeResponseValue;
}
	// struct LDKCustomMessageHandler IgnoringMessageHandler_as_CustomMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);
/* @internal */
export function IgnoringMessageHandler_as_CustomMessageHandler(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_IgnoringMessageHandler_as_CustomMessageHandler(this_arg);
	return nativeResponseValue;
}
	// void ErroringMessageHandler_free(struct LDKErroringMessageHandler this_obj);
/* @internal */
export function ErroringMessageHandler_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErroringMessageHandler_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKErroringMessageHandler ErroringMessageHandler_new(void);
/* @internal */
export function ErroringMessageHandler_new(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErroringMessageHandler_new();
	return nativeResponseValue;
}
	// struct LDKMessageSendEventsProvider ErroringMessageHandler_as_MessageSendEventsProvider(const struct LDKErroringMessageHandler *NONNULL_PTR this_arg);
/* @internal */
export function ErroringMessageHandler_as_MessageSendEventsProvider(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErroringMessageHandler_as_MessageSendEventsProvider(this_arg);
	return nativeResponseValue;
}
	// struct LDKChannelMessageHandler ErroringMessageHandler_as_ChannelMessageHandler(const struct LDKErroringMessageHandler *NONNULL_PTR this_arg);
/* @internal */
export function ErroringMessageHandler_as_ChannelMessageHandler(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErroringMessageHandler_as_ChannelMessageHandler(this_arg);
	return nativeResponseValue;
}
	// void MessageHandler_free(struct LDKMessageHandler this_obj);
/* @internal */
export function MessageHandler_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageHandler_free(this_obj);
	// debug statements here
}
	// const struct LDKChannelMessageHandler *MessageHandler_get_chan_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);
/* @internal */
export function MessageHandler_get_chan_handler(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageHandler_get_chan_handler(this_ptr);
	return nativeResponseValue;
}
	// void MessageHandler_set_chan_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKChannelMessageHandler val);
/* @internal */
export function MessageHandler_set_chan_handler(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageHandler_set_chan_handler(this_ptr, val);
	// debug statements here
}
	// const struct LDKRoutingMessageHandler *MessageHandler_get_route_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);
/* @internal */
export function MessageHandler_get_route_handler(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageHandler_get_route_handler(this_ptr);
	return nativeResponseValue;
}
	// void MessageHandler_set_route_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKRoutingMessageHandler val);
/* @internal */
export function MessageHandler_set_route_handler(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageHandler_set_route_handler(this_ptr, val);
	// debug statements here
}
	// const struct LDKOnionMessageHandler *MessageHandler_get_onion_message_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);
/* @internal */
export function MessageHandler_get_onion_message_handler(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageHandler_get_onion_message_handler(this_ptr);
	return nativeResponseValue;
}
	// void MessageHandler_set_onion_message_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKOnionMessageHandler val);
/* @internal */
export function MessageHandler_set_onion_message_handler(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageHandler_set_onion_message_handler(this_ptr, val);
	// debug statements here
}
	// const struct LDKCustomMessageHandler *MessageHandler_get_custom_message_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);
/* @internal */
export function MessageHandler_get_custom_message_handler(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageHandler_get_custom_message_handler(this_ptr);
	return nativeResponseValue;
}
	// void MessageHandler_set_custom_message_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKCustomMessageHandler val);
/* @internal */
export function MessageHandler_set_custom_message_handler(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageHandler_set_custom_message_handler(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKMessageHandler MessageHandler_new(struct LDKChannelMessageHandler chan_handler_arg, struct LDKRoutingMessageHandler route_handler_arg, struct LDKOnionMessageHandler onion_message_handler_arg, struct LDKCustomMessageHandler custom_message_handler_arg);
/* @internal */
export function MessageHandler_new(chan_handler_arg: bigint, route_handler_arg: bigint, onion_message_handler_arg: bigint, custom_message_handler_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageHandler_new(chan_handler_arg, route_handler_arg, onion_message_handler_arg, custom_message_handler_arg);
	return nativeResponseValue;
}
	// uint64_t SocketDescriptor_clone_ptr(LDKSocketDescriptor *NONNULL_PTR arg);
/* @internal */
export function SocketDescriptor_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SocketDescriptor_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKSocketDescriptor SocketDescriptor_clone(const struct LDKSocketDescriptor *NONNULL_PTR orig);
/* @internal */
export function SocketDescriptor_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SocketDescriptor_clone(orig);
	return nativeResponseValue;
}
	// void SocketDescriptor_free(struct LDKSocketDescriptor this_ptr);
/* @internal */
export function SocketDescriptor_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SocketDescriptor_free(this_ptr);
	// debug statements here
}
	// void PeerHandleError_free(struct LDKPeerHandleError this_obj);
/* @internal */
export function PeerHandleError_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerHandleError_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKPeerHandleError PeerHandleError_new(void);
/* @internal */
export function PeerHandleError_new(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerHandleError_new();
	return nativeResponseValue;
}
	// uint64_t PeerHandleError_clone_ptr(LDKPeerHandleError *NONNULL_PTR arg);
/* @internal */
export function PeerHandleError_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerHandleError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPeerHandleError PeerHandleError_clone(const struct LDKPeerHandleError *NONNULL_PTR orig);
/* @internal */
export function PeerHandleError_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerHandleError_clone(orig);
	return nativeResponseValue;
}
	// void PeerManager_free(struct LDKPeerManager this_obj);
/* @internal */
export function PeerManager_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKPeerManager PeerManager_new(struct LDKMessageHandler message_handler, uint32_t current_time, const uint8_t (*ephemeral_random_data)[32], struct LDKLogger logger, struct LDKNodeSigner node_signer);
/* @internal */
export function PeerManager_new(message_handler: bigint, current_time: number, ephemeral_random_data: number, logger: bigint, node_signer: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_new(message_handler, current_time, ephemeral_random_data, logger, node_signer);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_C2Tuple_PublicKeyCOption_NetAddressZZZ PeerManager_get_peer_node_ids(const struct LDKPeerManager *NONNULL_PTR this_arg);
/* @internal */
export function PeerManager_get_peer_node_ids(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_get_peer_node_ids(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_CVec_u8ZPeerHandleErrorZ PeerManager_new_outbound_connection(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKSocketDescriptor descriptor, struct LDKCOption_NetAddressZ remote_network_address);
/* @internal */
export function PeerManager_new_outbound_connection(this_arg: bigint, their_node_id: number, descriptor: bigint, remote_network_address: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_new_outbound_connection(this_arg, their_node_id, descriptor, remote_network_address);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NonePeerHandleErrorZ PeerManager_new_inbound_connection(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor descriptor, struct LDKCOption_NetAddressZ remote_network_address);
/* @internal */
export function PeerManager_new_inbound_connection(this_arg: bigint, descriptor: bigint, remote_network_address: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_new_inbound_connection(this_arg, descriptor, remote_network_address);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NonePeerHandleErrorZ PeerManager_write_buffer_space_avail(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor *NONNULL_PTR descriptor);
/* @internal */
export function PeerManager_write_buffer_space_avail(this_arg: bigint, descriptor: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_write_buffer_space_avail(this_arg, descriptor);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_boolPeerHandleErrorZ PeerManager_read_event(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor *NONNULL_PTR peer_descriptor, struct LDKu8slice data);
/* @internal */
export function PeerManager_read_event(this_arg: bigint, peer_descriptor: bigint, data: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_read_event(this_arg, peer_descriptor, data);
	return nativeResponseValue;
}
	// void PeerManager_process_events(const struct LDKPeerManager *NONNULL_PTR this_arg);
/* @internal */
export function PeerManager_process_events(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_process_events(this_arg);
	// debug statements here
}
	// void PeerManager_socket_disconnected(const struct LDKPeerManager *NONNULL_PTR this_arg, const struct LDKSocketDescriptor *NONNULL_PTR descriptor);
/* @internal */
export function PeerManager_socket_disconnected(this_arg: bigint, descriptor: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_socket_disconnected(this_arg, descriptor);
	// debug statements here
}
	// void PeerManager_disconnect_by_node_id(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKPublicKey node_id);
/* @internal */
export function PeerManager_disconnect_by_node_id(this_arg: bigint, node_id: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_disconnect_by_node_id(this_arg, node_id);
	// debug statements here
}
	// void PeerManager_disconnect_all_peers(const struct LDKPeerManager *NONNULL_PTR this_arg);
/* @internal */
export function PeerManager_disconnect_all_peers(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_disconnect_all_peers(this_arg);
	// debug statements here
}
	// void PeerManager_timer_tick_occurred(const struct LDKPeerManager *NONNULL_PTR this_arg);
/* @internal */
export function PeerManager_timer_tick_occurred(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_timer_tick_occurred(this_arg);
	// debug statements here
}
	// void PeerManager_broadcast_node_announcement(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKThreeBytes rgb, struct LDKThirtyTwoBytes alias, struct LDKCVec_NetAddressZ addresses);
/* @internal */
export function PeerManager_broadcast_node_announcement(this_arg: bigint, rgb: number, alias: number, addresses: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_broadcast_node_announcement(this_arg, rgb, alias, addresses);
	// debug statements here
}
	// uint64_t htlc_success_tx_weight(const struct LDKChannelTypeFeatures *NONNULL_PTR channel_type_features);
/* @internal */
export function htlc_success_tx_weight(channel_type_features: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_htlc_success_tx_weight(channel_type_features);
	return nativeResponseValue;
}
	// uint64_t htlc_timeout_tx_weight(const struct LDKChannelTypeFeatures *NONNULL_PTR channel_type_features);
/* @internal */
export function htlc_timeout_tx_weight(channel_type_features: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_htlc_timeout_tx_weight(channel_type_features);
	return nativeResponseValue;
}
	// enum LDKHTLCClaim HTLCClaim_clone(const enum LDKHTLCClaim *NONNULL_PTR orig);
/* @internal */
export function HTLCClaim_clone(orig: bigint): HTLCClaim {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCClaim_clone(orig);
	return nativeResponseValue;
}
	// enum LDKHTLCClaim HTLCClaim_offered_timeout(void);
/* @internal */
export function HTLCClaim_offered_timeout(): HTLCClaim {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCClaim_offered_timeout();
	return nativeResponseValue;
}
	// enum LDKHTLCClaim HTLCClaim_offered_preimage(void);
/* @internal */
export function HTLCClaim_offered_preimage(): HTLCClaim {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCClaim_offered_preimage();
	return nativeResponseValue;
}
	// enum LDKHTLCClaim HTLCClaim_accepted_timeout(void);
/* @internal */
export function HTLCClaim_accepted_timeout(): HTLCClaim {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCClaim_accepted_timeout();
	return nativeResponseValue;
}
	// enum LDKHTLCClaim HTLCClaim_accepted_preimage(void);
/* @internal */
export function HTLCClaim_accepted_preimage(): HTLCClaim {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCClaim_accepted_preimage();
	return nativeResponseValue;
}
	// enum LDKHTLCClaim HTLCClaim_revocation(void);
/* @internal */
export function HTLCClaim_revocation(): HTLCClaim {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCClaim_revocation();
	return nativeResponseValue;
}
	// bool HTLCClaim_eq(const enum LDKHTLCClaim *NONNULL_PTR a, const enum LDKHTLCClaim *NONNULL_PTR b);
/* @internal */
export function HTLCClaim_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCClaim_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_HTLCClaimZ HTLCClaim_from_witness(struct LDKWitness witness);
/* @internal */
export function HTLCClaim_from_witness(witness: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCClaim_from_witness(witness);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes build_commitment_secret(const uint8_t (*commitment_seed)[32], uint64_t idx);
/* @internal */
export function build_commitment_secret(commitment_seed: number, idx: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_build_commitment_secret(commitment_seed, idx);
	return nativeResponseValue;
}
	// struct LDKTransaction build_closing_transaction(uint64_t to_holder_value_sat, uint64_t to_counterparty_value_sat, struct LDKCVec_u8Z to_holder_script, struct LDKCVec_u8Z to_counterparty_script, struct LDKOutPoint funding_outpoint);
/* @internal */
export function build_closing_transaction(to_holder_value_sat: bigint, to_counterparty_value_sat: bigint, to_holder_script: number, to_counterparty_script: number, funding_outpoint: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_build_closing_transaction(to_holder_value_sat, to_counterparty_value_sat, to_holder_script, to_counterparty_script, funding_outpoint);
	return nativeResponseValue;
}
	// void CounterpartyCommitmentSecrets_free(struct LDKCounterpartyCommitmentSecrets this_obj);
/* @internal */
export function CounterpartyCommitmentSecrets_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_free(this_obj);
	// debug statements here
}
	// uint64_t CounterpartyCommitmentSecrets_clone_ptr(LDKCounterpartyCommitmentSecrets *NONNULL_PTR arg);
/* @internal */
export function CounterpartyCommitmentSecrets_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCounterpartyCommitmentSecrets CounterpartyCommitmentSecrets_clone(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR orig);
/* @internal */
export function CounterpartyCommitmentSecrets_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCounterpartyCommitmentSecrets CounterpartyCommitmentSecrets_new(void);
/* @internal */
export function CounterpartyCommitmentSecrets_new(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_new();
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t CounterpartyCommitmentSecrets_get_min_seen_secret(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR this_arg);
/* @internal */
export function CounterpartyCommitmentSecrets_get_min_seen_secret(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_get_min_seen_secret(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ CounterpartyCommitmentSecrets_provide_secret(struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR this_arg, uint64_t idx, struct LDKThirtyTwoBytes secret);
/* @internal */
export function CounterpartyCommitmentSecrets_provide_secret(this_arg: bigint, idx: bigint, secret: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_provide_secret(this_arg, idx, secret);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes CounterpartyCommitmentSecrets_get_secret(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR this_arg, uint64_t idx);
/* @internal */
export function CounterpartyCommitmentSecrets_get_secret(this_arg: bigint, idx: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_get_secret(this_arg, idx);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z CounterpartyCommitmentSecrets_write(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR obj);
/* @internal */
export function CounterpartyCommitmentSecrets_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CounterpartyCommitmentSecrets_read(struct LDKu8slice ser);
/* @internal */
export function CounterpartyCommitmentSecrets_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_read(ser);
	return nativeResponseValue;
}
	// struct LDKSecretKey derive_private_key(struct LDKPublicKey per_commitment_point, const uint8_t (*base_secret)[32]);
/* @internal */
export function derive_private_key(per_commitment_point: number, base_secret: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_derive_private_key(per_commitment_point, base_secret);
	return nativeResponseValue;
}
	// struct LDKPublicKey derive_public_key(struct LDKPublicKey per_commitment_point, struct LDKPublicKey base_point);
/* @internal */
export function derive_public_key(per_commitment_point: number, base_point: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_derive_public_key(per_commitment_point, base_point);
	return nativeResponseValue;
}
	// struct LDKSecretKey derive_private_revocation_key(const uint8_t (*per_commitment_secret)[32], const uint8_t (*countersignatory_revocation_base_secret)[32]);
/* @internal */
export function derive_private_revocation_key(per_commitment_secret: number, countersignatory_revocation_base_secret: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_derive_private_revocation_key(per_commitment_secret, countersignatory_revocation_base_secret);
	return nativeResponseValue;
}
	// struct LDKPublicKey derive_public_revocation_key(struct LDKPublicKey per_commitment_point, struct LDKPublicKey countersignatory_revocation_base_point);
/* @internal */
export function derive_public_revocation_key(per_commitment_point: number, countersignatory_revocation_base_point: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_derive_public_revocation_key(per_commitment_point, countersignatory_revocation_base_point);
	return nativeResponseValue;
}
	// void TxCreationKeys_free(struct LDKTxCreationKeys this_obj);
/* @internal */
export function TxCreationKeys_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_free(this_obj);
	// debug statements here
}
	// struct LDKPublicKey TxCreationKeys_get_per_commitment_point(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);
/* @internal */
export function TxCreationKeys_get_per_commitment_point(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_get_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void TxCreationKeys_set_per_commitment_point(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function TxCreationKeys_set_per_commitment_point(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_set_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey TxCreationKeys_get_revocation_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);
/* @internal */
export function TxCreationKeys_get_revocation_key(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_get_revocation_key(this_ptr);
	return nativeResponseValue;
}
	// void TxCreationKeys_set_revocation_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function TxCreationKeys_set_revocation_key(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_set_revocation_key(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey TxCreationKeys_get_broadcaster_htlc_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);
/* @internal */
export function TxCreationKeys_get_broadcaster_htlc_key(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_get_broadcaster_htlc_key(this_ptr);
	return nativeResponseValue;
}
	// void TxCreationKeys_set_broadcaster_htlc_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function TxCreationKeys_set_broadcaster_htlc_key(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_set_broadcaster_htlc_key(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey TxCreationKeys_get_countersignatory_htlc_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);
/* @internal */
export function TxCreationKeys_get_countersignatory_htlc_key(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_get_countersignatory_htlc_key(this_ptr);
	return nativeResponseValue;
}
	// void TxCreationKeys_set_countersignatory_htlc_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function TxCreationKeys_set_countersignatory_htlc_key(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_set_countersignatory_htlc_key(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey TxCreationKeys_get_broadcaster_delayed_payment_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);
/* @internal */
export function TxCreationKeys_get_broadcaster_delayed_payment_key(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_get_broadcaster_delayed_payment_key(this_ptr);
	return nativeResponseValue;
}
	// void TxCreationKeys_set_broadcaster_delayed_payment_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function TxCreationKeys_set_broadcaster_delayed_payment_key(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_set_broadcaster_delayed_payment_key(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKTxCreationKeys TxCreationKeys_new(struct LDKPublicKey per_commitment_point_arg, struct LDKPublicKey revocation_key_arg, struct LDKPublicKey broadcaster_htlc_key_arg, struct LDKPublicKey countersignatory_htlc_key_arg, struct LDKPublicKey broadcaster_delayed_payment_key_arg);
/* @internal */
export function TxCreationKeys_new(per_commitment_point_arg: number, revocation_key_arg: number, broadcaster_htlc_key_arg: number, countersignatory_htlc_key_arg: number, broadcaster_delayed_payment_key_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_new(per_commitment_point_arg, revocation_key_arg, broadcaster_htlc_key_arg, countersignatory_htlc_key_arg, broadcaster_delayed_payment_key_arg);
	return nativeResponseValue;
}
	// bool TxCreationKeys_eq(const struct LDKTxCreationKeys *NONNULL_PTR a, const struct LDKTxCreationKeys *NONNULL_PTR b);
/* @internal */
export function TxCreationKeys_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_eq(a, b);
	return nativeResponseValue;
}
	// uint64_t TxCreationKeys_clone_ptr(LDKTxCreationKeys *NONNULL_PTR arg);
/* @internal */
export function TxCreationKeys_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKTxCreationKeys TxCreationKeys_clone(const struct LDKTxCreationKeys *NONNULL_PTR orig);
/* @internal */
export function TxCreationKeys_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z TxCreationKeys_write(const struct LDKTxCreationKeys *NONNULL_PTR obj);
/* @internal */
export function TxCreationKeys_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_TxCreationKeysDecodeErrorZ TxCreationKeys_read(struct LDKu8slice ser);
/* @internal */
export function TxCreationKeys_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_read(ser);
	return nativeResponseValue;
}
	// void ChannelPublicKeys_free(struct LDKChannelPublicKeys this_obj);
/* @internal */
export function ChannelPublicKeys_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_free(this_obj);
	// debug statements here
}
	// struct LDKPublicKey ChannelPublicKeys_get_funding_pubkey(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelPublicKeys_get_funding_pubkey(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_get_funding_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void ChannelPublicKeys_set_funding_pubkey(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function ChannelPublicKeys_set_funding_pubkey(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_set_funding_pubkey(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey ChannelPublicKeys_get_revocation_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelPublicKeys_get_revocation_basepoint(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_get_revocation_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void ChannelPublicKeys_set_revocation_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function ChannelPublicKeys_set_revocation_basepoint(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_set_revocation_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey ChannelPublicKeys_get_payment_point(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelPublicKeys_get_payment_point(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_get_payment_point(this_ptr);
	return nativeResponseValue;
}
	// void ChannelPublicKeys_set_payment_point(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function ChannelPublicKeys_set_payment_point(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_set_payment_point(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey ChannelPublicKeys_get_delayed_payment_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelPublicKeys_get_delayed_payment_basepoint(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_get_delayed_payment_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void ChannelPublicKeys_set_delayed_payment_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function ChannelPublicKeys_set_delayed_payment_basepoint(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_set_delayed_payment_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey ChannelPublicKeys_get_htlc_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelPublicKeys_get_htlc_basepoint(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_get_htlc_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void ChannelPublicKeys_set_htlc_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function ChannelPublicKeys_set_htlc_basepoint(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_set_htlc_basepoint(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelPublicKeys ChannelPublicKeys_new(struct LDKPublicKey funding_pubkey_arg, struct LDKPublicKey revocation_basepoint_arg, struct LDKPublicKey payment_point_arg, struct LDKPublicKey delayed_payment_basepoint_arg, struct LDKPublicKey htlc_basepoint_arg);
/* @internal */
export function ChannelPublicKeys_new(funding_pubkey_arg: number, revocation_basepoint_arg: number, payment_point_arg: number, delayed_payment_basepoint_arg: number, htlc_basepoint_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_new(funding_pubkey_arg, revocation_basepoint_arg, payment_point_arg, delayed_payment_basepoint_arg, htlc_basepoint_arg);
	return nativeResponseValue;
}
	// uint64_t ChannelPublicKeys_clone_ptr(LDKChannelPublicKeys *NONNULL_PTR arg);
/* @internal */
export function ChannelPublicKeys_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelPublicKeys ChannelPublicKeys_clone(const struct LDKChannelPublicKeys *NONNULL_PTR orig);
/* @internal */
export function ChannelPublicKeys_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_clone(orig);
	return nativeResponseValue;
}
	// bool ChannelPublicKeys_eq(const struct LDKChannelPublicKeys *NONNULL_PTR a, const struct LDKChannelPublicKeys *NONNULL_PTR b);
/* @internal */
export function ChannelPublicKeys_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelPublicKeys_write(const struct LDKChannelPublicKeys *NONNULL_PTR obj);
/* @internal */
export function ChannelPublicKeys_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelPublicKeysDecodeErrorZ ChannelPublicKeys_read(struct LDKu8slice ser);
/* @internal */
export function ChannelPublicKeys_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_read(ser);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKTxCreationKeys TxCreationKeys_derive_new(struct LDKPublicKey per_commitment_point, struct LDKPublicKey broadcaster_delayed_payment_base, struct LDKPublicKey broadcaster_htlc_base, struct LDKPublicKey countersignatory_revocation_base, struct LDKPublicKey countersignatory_htlc_base);
/* @internal */
export function TxCreationKeys_derive_new(per_commitment_point: number, broadcaster_delayed_payment_base: number, broadcaster_htlc_base: number, countersignatory_revocation_base: number, countersignatory_htlc_base: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_derive_new(per_commitment_point, broadcaster_delayed_payment_base, broadcaster_htlc_base, countersignatory_revocation_base, countersignatory_htlc_base);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKTxCreationKeys TxCreationKeys_from_channel_static_keys(struct LDKPublicKey per_commitment_point, const struct LDKChannelPublicKeys *NONNULL_PTR broadcaster_keys, const struct LDKChannelPublicKeys *NONNULL_PTR countersignatory_keys);
/* @internal */
export function TxCreationKeys_from_channel_static_keys(per_commitment_point: number, broadcaster_keys: bigint, countersignatory_keys: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_from_channel_static_keys(per_commitment_point, broadcaster_keys, countersignatory_keys);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z get_revokeable_redeemscript(struct LDKPublicKey revocation_key, uint16_t contest_delay, struct LDKPublicKey broadcaster_delayed_payment_key);
/* @internal */
export function get_revokeable_redeemscript(revocation_key: number, contest_delay: number, broadcaster_delayed_payment_key: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_get_revokeable_redeemscript(revocation_key, contest_delay, broadcaster_delayed_payment_key);
	return nativeResponseValue;
}
	// void HTLCOutputInCommitment_free(struct LDKHTLCOutputInCommitment this_obj);
/* @internal */
export function HTLCOutputInCommitment_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_free(this_obj);
	// debug statements here
}
	// bool HTLCOutputInCommitment_get_offered(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);
/* @internal */
export function HTLCOutputInCommitment_get_offered(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_get_offered(this_ptr);
	return nativeResponseValue;
}
	// void HTLCOutputInCommitment_set_offered(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function HTLCOutputInCommitment_set_offered(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_set_offered(this_ptr, val);
	// debug statements here
}
	// uint64_t HTLCOutputInCommitment_get_amount_msat(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);
/* @internal */
export function HTLCOutputInCommitment_get_amount_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_get_amount_msat(this_ptr);
	return nativeResponseValue;
}
	// void HTLCOutputInCommitment_set_amount_msat(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function HTLCOutputInCommitment_set_amount_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_set_amount_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t HTLCOutputInCommitment_get_cltv_expiry(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);
/* @internal */
export function HTLCOutputInCommitment_get_cltv_expiry(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_get_cltv_expiry(this_ptr);
	return nativeResponseValue;
}
	// void HTLCOutputInCommitment_set_cltv_expiry(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function HTLCOutputInCommitment_set_cltv_expiry(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_set_cltv_expiry(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*HTLCOutputInCommitment_get_payment_hash(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr))[32];
/* @internal */
export function HTLCOutputInCommitment_get_payment_hash(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_get_payment_hash(this_ptr);
	return nativeResponseValue;
}
	// void HTLCOutputInCommitment_set_payment_hash(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function HTLCOutputInCommitment_set_payment_hash(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_set_payment_hash(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u32Z HTLCOutputInCommitment_get_transaction_output_index(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);
/* @internal */
export function HTLCOutputInCommitment_get_transaction_output_index(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_get_transaction_output_index(this_ptr);
	return nativeResponseValue;
}
	// void HTLCOutputInCommitment_set_transaction_output_index(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);
/* @internal */
export function HTLCOutputInCommitment_set_transaction_output_index(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_set_transaction_output_index(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKHTLCOutputInCommitment HTLCOutputInCommitment_new(bool offered_arg, uint64_t amount_msat_arg, uint32_t cltv_expiry_arg, struct LDKThirtyTwoBytes payment_hash_arg, struct LDKCOption_u32Z transaction_output_index_arg);
/* @internal */
export function HTLCOutputInCommitment_new(offered_arg: boolean, amount_msat_arg: bigint, cltv_expiry_arg: number, payment_hash_arg: number, transaction_output_index_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_new(offered_arg, amount_msat_arg, cltv_expiry_arg, payment_hash_arg, transaction_output_index_arg);
	return nativeResponseValue;
}
	// uint64_t HTLCOutputInCommitment_clone_ptr(LDKHTLCOutputInCommitment *NONNULL_PTR arg);
/* @internal */
export function HTLCOutputInCommitment_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKHTLCOutputInCommitment HTLCOutputInCommitment_clone(const struct LDKHTLCOutputInCommitment *NONNULL_PTR orig);
/* @internal */
export function HTLCOutputInCommitment_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_clone(orig);
	return nativeResponseValue;
}
	// bool HTLCOutputInCommitment_eq(const struct LDKHTLCOutputInCommitment *NONNULL_PTR a, const struct LDKHTLCOutputInCommitment *NONNULL_PTR b);
/* @internal */
export function HTLCOutputInCommitment_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z HTLCOutputInCommitment_write(const struct LDKHTLCOutputInCommitment *NONNULL_PTR obj);
/* @internal */
export function HTLCOutputInCommitment_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ HTLCOutputInCommitment_read(struct LDKu8slice ser);
/* @internal */
export function HTLCOutputInCommitment_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z get_htlc_redeemscript(const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc, const struct LDKChannelTypeFeatures *NONNULL_PTR channel_type_features, const struct LDKTxCreationKeys *NONNULL_PTR keys);
/* @internal */
export function get_htlc_redeemscript(htlc: bigint, channel_type_features: bigint, keys: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_get_htlc_redeemscript(htlc, channel_type_features, keys);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z make_funding_redeemscript(struct LDKPublicKey broadcaster, struct LDKPublicKey countersignatory);
/* @internal */
export function make_funding_redeemscript(broadcaster: number, countersignatory: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_make_funding_redeemscript(broadcaster, countersignatory);
	return nativeResponseValue;
}
	// struct LDKTransaction build_htlc_transaction(const uint8_t (*commitment_txid)[32], uint32_t feerate_per_kw, uint16_t contest_delay, const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc, const struct LDKChannelTypeFeatures *NONNULL_PTR channel_type_features, struct LDKPublicKey broadcaster_delayed_payment_key, struct LDKPublicKey revocation_key);
/* @internal */
export function build_htlc_transaction(commitment_txid: number, feerate_per_kw: number, contest_delay: number, htlc: bigint, channel_type_features: bigint, broadcaster_delayed_payment_key: number, revocation_key: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_build_htlc_transaction(commitment_txid, feerate_per_kw, contest_delay, htlc, channel_type_features, broadcaster_delayed_payment_key, revocation_key);
	return nativeResponseValue;
}
	// struct LDKWitness build_htlc_input_witness(struct LDKSignature local_sig, struct LDKSignature remote_sig, struct LDKCOption_PaymentPreimageZ preimage, struct LDKu8slice redeem_script, const struct LDKChannelTypeFeatures *NONNULL_PTR channel_type_features);
/* @internal */
export function build_htlc_input_witness(local_sig: number, remote_sig: number, preimage: bigint, redeem_script: number, channel_type_features: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_build_htlc_input_witness(local_sig, remote_sig, preimage, redeem_script, channel_type_features);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z get_to_countersignatory_with_anchors_redeemscript(struct LDKPublicKey payment_point);
/* @internal */
export function get_to_countersignatory_with_anchors_redeemscript(payment_point: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_get_to_countersignatory_with_anchors_redeemscript(payment_point);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z get_anchor_redeemscript(struct LDKPublicKey funding_pubkey);
/* @internal */
export function get_anchor_redeemscript(funding_pubkey: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_get_anchor_redeemscript(funding_pubkey);
	return nativeResponseValue;
}
	// struct LDKWitness build_anchor_input_witness(struct LDKPublicKey funding_key, struct LDKSignature funding_sig);
/* @internal */
export function build_anchor_input_witness(funding_key: number, funding_sig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_build_anchor_input_witness(funding_key, funding_sig);
	return nativeResponseValue;
}
	// void ChannelTransactionParameters_free(struct LDKChannelTransactionParameters this_obj);
/* @internal */
export function ChannelTransactionParameters_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_free(this_obj);
	// debug statements here
}
	// struct LDKChannelPublicKeys ChannelTransactionParameters_get_holder_pubkeys(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelTransactionParameters_get_holder_pubkeys(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_holder_pubkeys(this_ptr);
	return nativeResponseValue;
}
	// void ChannelTransactionParameters_set_holder_pubkeys(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelPublicKeys val);
/* @internal */
export function ChannelTransactionParameters_set_holder_pubkeys(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_holder_pubkeys(this_ptr, val);
	// debug statements here
}
	// uint16_t ChannelTransactionParameters_get_holder_selected_contest_delay(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelTransactionParameters_get_holder_selected_contest_delay(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_holder_selected_contest_delay(this_ptr);
	return nativeResponseValue;
}
	// void ChannelTransactionParameters_set_holder_selected_contest_delay(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function ChannelTransactionParameters_set_holder_selected_contest_delay(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_holder_selected_contest_delay(this_ptr, val);
	// debug statements here
}
	// bool ChannelTransactionParameters_get_is_outbound_from_holder(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelTransactionParameters_get_is_outbound_from_holder(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_is_outbound_from_holder(this_ptr);
	return nativeResponseValue;
}
	// void ChannelTransactionParameters_set_is_outbound_from_holder(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelTransactionParameters_set_is_outbound_from_holder(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_is_outbound_from_holder(this_ptr, val);
	// debug statements here
}
	// struct LDKCounterpartyChannelTransactionParameters ChannelTransactionParameters_get_counterparty_parameters(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelTransactionParameters_get_counterparty_parameters(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_counterparty_parameters(this_ptr);
	return nativeResponseValue;
}
	// void ChannelTransactionParameters_set_counterparty_parameters(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKCounterpartyChannelTransactionParameters val);
/* @internal */
export function ChannelTransactionParameters_set_counterparty_parameters(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_counterparty_parameters(this_ptr, val);
	// debug statements here
}
	// struct LDKOutPoint ChannelTransactionParameters_get_funding_outpoint(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelTransactionParameters_get_funding_outpoint(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_funding_outpoint(this_ptr);
	return nativeResponseValue;
}
	// void ChannelTransactionParameters_set_funding_outpoint(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */
export function ChannelTransactionParameters_set_funding_outpoint(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_funding_outpoint(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelTypeFeatures ChannelTransactionParameters_get_channel_type_features(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelTransactionParameters_get_channel_type_features(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_channel_type_features(this_ptr);
	return nativeResponseValue;
}
	// void ChannelTransactionParameters_set_channel_type_features(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);
/* @internal */
export function ChannelTransactionParameters_set_channel_type_features(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_channel_type_features(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelTransactionParameters ChannelTransactionParameters_new(struct LDKChannelPublicKeys holder_pubkeys_arg, uint16_t holder_selected_contest_delay_arg, bool is_outbound_from_holder_arg, struct LDKCounterpartyChannelTransactionParameters counterparty_parameters_arg, struct LDKOutPoint funding_outpoint_arg, struct LDKChannelTypeFeatures channel_type_features_arg);
/* @internal */
export function ChannelTransactionParameters_new(holder_pubkeys_arg: bigint, holder_selected_contest_delay_arg: number, is_outbound_from_holder_arg: boolean, counterparty_parameters_arg: bigint, funding_outpoint_arg: bigint, channel_type_features_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_new(holder_pubkeys_arg, holder_selected_contest_delay_arg, is_outbound_from_holder_arg, counterparty_parameters_arg, funding_outpoint_arg, channel_type_features_arg);
	return nativeResponseValue;
}
	// uint64_t ChannelTransactionParameters_clone_ptr(LDKChannelTransactionParameters *NONNULL_PTR arg);
/* @internal */
export function ChannelTransactionParameters_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelTransactionParameters ChannelTransactionParameters_clone(const struct LDKChannelTransactionParameters *NONNULL_PTR orig);
/* @internal */
export function ChannelTransactionParameters_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_clone(orig);
	return nativeResponseValue;
}
	// bool ChannelTransactionParameters_eq(const struct LDKChannelTransactionParameters *NONNULL_PTR a, const struct LDKChannelTransactionParameters *NONNULL_PTR b);
/* @internal */
export function ChannelTransactionParameters_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_eq(a, b);
	return nativeResponseValue;
}
	// void CounterpartyChannelTransactionParameters_free(struct LDKCounterpartyChannelTransactionParameters this_obj);
/* @internal */
export function CounterpartyChannelTransactionParameters_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_free(this_obj);
	// debug statements here
}
	// struct LDKChannelPublicKeys CounterpartyChannelTransactionParameters_get_pubkeys(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */
export function CounterpartyChannelTransactionParameters_get_pubkeys(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_get_pubkeys(this_ptr);
	return nativeResponseValue;
}
	// void CounterpartyChannelTransactionParameters_set_pubkeys(struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelPublicKeys val);
/* @internal */
export function CounterpartyChannelTransactionParameters_set_pubkeys(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_set_pubkeys(this_ptr, val);
	// debug statements here
}
	// uint16_t CounterpartyChannelTransactionParameters_get_selected_contest_delay(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */
export function CounterpartyChannelTransactionParameters_get_selected_contest_delay(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_get_selected_contest_delay(this_ptr);
	return nativeResponseValue;
}
	// void CounterpartyChannelTransactionParameters_set_selected_contest_delay(struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function CounterpartyChannelTransactionParameters_set_selected_contest_delay(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_set_selected_contest_delay(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKCounterpartyChannelTransactionParameters CounterpartyChannelTransactionParameters_new(struct LDKChannelPublicKeys pubkeys_arg, uint16_t selected_contest_delay_arg);
/* @internal */
export function CounterpartyChannelTransactionParameters_new(pubkeys_arg: bigint, selected_contest_delay_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_new(pubkeys_arg, selected_contest_delay_arg);
	return nativeResponseValue;
}
	// uint64_t CounterpartyChannelTransactionParameters_clone_ptr(LDKCounterpartyChannelTransactionParameters *NONNULL_PTR arg);
/* @internal */
export function CounterpartyChannelTransactionParameters_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCounterpartyChannelTransactionParameters CounterpartyChannelTransactionParameters_clone(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR orig);
/* @internal */
export function CounterpartyChannelTransactionParameters_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_clone(orig);
	return nativeResponseValue;
}
	// bool CounterpartyChannelTransactionParameters_eq(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR a, const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR b);
/* @internal */
export function CounterpartyChannelTransactionParameters_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES bool ChannelTransactionParameters_is_populated(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTransactionParameters_is_populated(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_is_populated(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKDirectedChannelTransactionParameters ChannelTransactionParameters_as_holder_broadcastable(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTransactionParameters_as_holder_broadcastable(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_as_holder_broadcastable(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKDirectedChannelTransactionParameters ChannelTransactionParameters_as_counterparty_broadcastable(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTransactionParameters_as_counterparty_broadcastable(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_as_counterparty_broadcastable(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z CounterpartyChannelTransactionParameters_write(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR obj);
/* @internal */
export function CounterpartyChannelTransactionParameters_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CounterpartyChannelTransactionParameters_read(struct LDKu8slice ser);
/* @internal */
export function CounterpartyChannelTransactionParameters_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelTransactionParameters_write(const struct LDKChannelTransactionParameters *NONNULL_PTR obj);
/* @internal */
export function ChannelTransactionParameters_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelTransactionParametersDecodeErrorZ ChannelTransactionParameters_read(struct LDKu8slice ser);
/* @internal */
export function ChannelTransactionParameters_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_read(ser);
	return nativeResponseValue;
}
	// void DirectedChannelTransactionParameters_free(struct LDKDirectedChannelTransactionParameters this_obj);
/* @internal */
export function DirectedChannelTransactionParameters_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelPublicKeys DirectedChannelTransactionParameters_broadcaster_pubkeys(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelTransactionParameters_broadcaster_pubkeys(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_broadcaster_pubkeys(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelPublicKeys DirectedChannelTransactionParameters_countersignatory_pubkeys(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelTransactionParameters_countersignatory_pubkeys(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_countersignatory_pubkeys(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint16_t DirectedChannelTransactionParameters_contest_delay(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelTransactionParameters_contest_delay(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_contest_delay(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool DirectedChannelTransactionParameters_is_outbound(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelTransactionParameters_is_outbound(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_is_outbound(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKOutPoint DirectedChannelTransactionParameters_funding_outpoint(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelTransactionParameters_funding_outpoint(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_funding_outpoint(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelTypeFeatures DirectedChannelTransactionParameters_channel_type_features(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelTransactionParameters_channel_type_features(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_channel_type_features(this_arg);
	return nativeResponseValue;
}
	// void HolderCommitmentTransaction_free(struct LDKHolderCommitmentTransaction this_obj);
/* @internal */
export function HolderCommitmentTransaction_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_free(this_obj);
	// debug statements here
}
	// struct LDKSignature HolderCommitmentTransaction_get_counterparty_sig(const struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr);
/* @internal */
export function HolderCommitmentTransaction_get_counterparty_sig(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_get_counterparty_sig(this_ptr);
	return nativeResponseValue;
}
	// void HolderCommitmentTransaction_set_counterparty_sig(struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function HolderCommitmentTransaction_set_counterparty_sig(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_set_counterparty_sig(this_ptr, val);
	// debug statements here
}
	// struct LDKCVec_SignatureZ HolderCommitmentTransaction_get_counterparty_htlc_sigs(const struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr);
/* @internal */
export function HolderCommitmentTransaction_get_counterparty_htlc_sigs(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_get_counterparty_htlc_sigs(this_ptr);
	return nativeResponseValue;
}
	// void HolderCommitmentTransaction_set_counterparty_htlc_sigs(struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKCVec_SignatureZ val);
/* @internal */
export function HolderCommitmentTransaction_set_counterparty_htlc_sigs(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_set_counterparty_htlc_sigs(this_ptr, val);
	// debug statements here
}
	// uint64_t HolderCommitmentTransaction_clone_ptr(LDKHolderCommitmentTransaction *NONNULL_PTR arg);
/* @internal */
export function HolderCommitmentTransaction_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKHolderCommitmentTransaction HolderCommitmentTransaction_clone(const struct LDKHolderCommitmentTransaction *NONNULL_PTR orig);
/* @internal */
export function HolderCommitmentTransaction_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z HolderCommitmentTransaction_write(const struct LDKHolderCommitmentTransaction *NONNULL_PTR obj);
/* @internal */
export function HolderCommitmentTransaction_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ HolderCommitmentTransaction_read(struct LDKu8slice ser);
/* @internal */
export function HolderCommitmentTransaction_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_read(ser);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKHolderCommitmentTransaction HolderCommitmentTransaction_new(struct LDKCommitmentTransaction commitment_tx, struct LDKSignature counterparty_sig, struct LDKCVec_SignatureZ counterparty_htlc_sigs, struct LDKPublicKey holder_funding_key, struct LDKPublicKey counterparty_funding_key);
/* @internal */
export function HolderCommitmentTransaction_new(commitment_tx: bigint, counterparty_sig: number, counterparty_htlc_sigs: number, holder_funding_key: number, counterparty_funding_key: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_new(commitment_tx, counterparty_sig, counterparty_htlc_sigs, holder_funding_key, counterparty_funding_key);
	return nativeResponseValue;
}
	// void BuiltCommitmentTransaction_free(struct LDKBuiltCommitmentTransaction this_obj);
/* @internal */
export function BuiltCommitmentTransaction_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_free(this_obj);
	// debug statements here
}
	// struct LDKTransaction BuiltCommitmentTransaction_get_transaction(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr);
/* @internal */
export function BuiltCommitmentTransaction_get_transaction(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_get_transaction(this_ptr);
	return nativeResponseValue;
}
	// void BuiltCommitmentTransaction_set_transaction(struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKTransaction val);
/* @internal */
export function BuiltCommitmentTransaction_set_transaction(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_set_transaction(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*BuiltCommitmentTransaction_get_txid(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr))[32];
/* @internal */
export function BuiltCommitmentTransaction_get_txid(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_get_txid(this_ptr);
	return nativeResponseValue;
}
	// void BuiltCommitmentTransaction_set_txid(struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function BuiltCommitmentTransaction_set_txid(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_set_txid(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_new(struct LDKTransaction transaction_arg, struct LDKThirtyTwoBytes txid_arg);
/* @internal */
export function BuiltCommitmentTransaction_new(transaction_arg: number, txid_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_new(transaction_arg, txid_arg);
	return nativeResponseValue;
}
	// uint64_t BuiltCommitmentTransaction_clone_ptr(LDKBuiltCommitmentTransaction *NONNULL_PTR arg);
/* @internal */
export function BuiltCommitmentTransaction_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_clone(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR orig);
/* @internal */
export function BuiltCommitmentTransaction_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z BuiltCommitmentTransaction_write(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR obj);
/* @internal */
export function BuiltCommitmentTransaction_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ BuiltCommitmentTransaction_read(struct LDKu8slice ser);
/* @internal */
export function BuiltCommitmentTransaction_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_read(ser);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes BuiltCommitmentTransaction_get_sighash_all(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);
/* @internal */
export function BuiltCommitmentTransaction_get_sighash_all(this_arg: bigint, funding_redeemscript: number, channel_value_satoshis: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_get_sighash_all(this_arg, funding_redeemscript, channel_value_satoshis);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKSignature BuiltCommitmentTransaction_sign_counterparty_commitment(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*funding_key)[32], struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);
/* @internal */
export function BuiltCommitmentTransaction_sign_counterparty_commitment(this_arg: bigint, funding_key: number, funding_redeemscript: number, channel_value_satoshis: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_sign_counterparty_commitment(this_arg, funding_key, funding_redeemscript, channel_value_satoshis);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKSignature BuiltCommitmentTransaction_sign_holder_commitment(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*funding_key)[32], struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis, const struct LDKEntropySource *NONNULL_PTR entropy_source);
/* @internal */
export function BuiltCommitmentTransaction_sign_holder_commitment(this_arg: bigint, funding_key: number, funding_redeemscript: number, channel_value_satoshis: bigint, entropy_source: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_sign_holder_commitment(this_arg, funding_key, funding_redeemscript, channel_value_satoshis, entropy_source);
	return nativeResponseValue;
}
	// void ClosingTransaction_free(struct LDKClosingTransaction this_obj);
/* @internal */
export function ClosingTransaction_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_free(this_obj);
	// debug statements here
}
	// uint64_t ClosingTransaction_clone_ptr(LDKClosingTransaction *NONNULL_PTR arg);
/* @internal */
export function ClosingTransaction_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKClosingTransaction ClosingTransaction_clone(const struct LDKClosingTransaction *NONNULL_PTR orig);
/* @internal */
export function ClosingTransaction_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_clone(orig);
	return nativeResponseValue;
}
	// uint64_t ClosingTransaction_hash(const struct LDKClosingTransaction *NONNULL_PTR o);
/* @internal */
export function ClosingTransaction_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_hash(o);
	return nativeResponseValue;
}
	// bool ClosingTransaction_eq(const struct LDKClosingTransaction *NONNULL_PTR a, const struct LDKClosingTransaction *NONNULL_PTR b);
/* @internal */
export function ClosingTransaction_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKClosingTransaction ClosingTransaction_new(uint64_t to_holder_value_sat, uint64_t to_counterparty_value_sat, struct LDKCVec_u8Z to_holder_script, struct LDKCVec_u8Z to_counterparty_script, struct LDKOutPoint funding_outpoint);
/* @internal */
export function ClosingTransaction_new(to_holder_value_sat: bigint, to_counterparty_value_sat: bigint, to_holder_script: number, to_counterparty_script: number, funding_outpoint: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_new(to_holder_value_sat, to_counterparty_value_sat, to_holder_script, to_counterparty_script, funding_outpoint);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKTrustedClosingTransaction ClosingTransaction_trust(const struct LDKClosingTransaction *NONNULL_PTR this_arg);
/* @internal */
export function ClosingTransaction_trust(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_trust(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_TrustedClosingTransactionNoneZ ClosingTransaction_verify(const struct LDKClosingTransaction *NONNULL_PTR this_arg, struct LDKOutPoint funding_outpoint);
/* @internal */
export function ClosingTransaction_verify(this_arg: bigint, funding_outpoint: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_verify(this_arg, funding_outpoint);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t ClosingTransaction_to_holder_value_sat(const struct LDKClosingTransaction *NONNULL_PTR this_arg);
/* @internal */
export function ClosingTransaction_to_holder_value_sat(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_to_holder_value_sat(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t ClosingTransaction_to_counterparty_value_sat(const struct LDKClosingTransaction *NONNULL_PTR this_arg);
/* @internal */
export function ClosingTransaction_to_counterparty_value_sat(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_to_counterparty_value_sat(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKu8slice ClosingTransaction_to_holder_script(const struct LDKClosingTransaction *NONNULL_PTR this_arg);
/* @internal */
export function ClosingTransaction_to_holder_script(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_to_holder_script(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKu8slice ClosingTransaction_to_counterparty_script(const struct LDKClosingTransaction *NONNULL_PTR this_arg);
/* @internal */
export function ClosingTransaction_to_counterparty_script(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_to_counterparty_script(this_arg);
	return nativeResponseValue;
}
	// void TrustedClosingTransaction_free(struct LDKTrustedClosingTransaction this_obj);
/* @internal */
export function TrustedClosingTransaction_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedClosingTransaction_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKTransaction TrustedClosingTransaction_built_transaction(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg);
/* @internal */
export function TrustedClosingTransaction_built_transaction(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedClosingTransaction_built_transaction(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes TrustedClosingTransaction_get_sighash_all(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg, struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);
/* @internal */
export function TrustedClosingTransaction_get_sighash_all(this_arg: bigint, funding_redeemscript: number, channel_value_satoshis: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedClosingTransaction_get_sighash_all(this_arg, funding_redeemscript, channel_value_satoshis);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKSignature TrustedClosingTransaction_sign(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg, const uint8_t (*funding_key)[32], struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);
/* @internal */
export function TrustedClosingTransaction_sign(this_arg: bigint, funding_key: number, funding_redeemscript: number, channel_value_satoshis: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedClosingTransaction_sign(this_arg, funding_key, funding_redeemscript, channel_value_satoshis);
	return nativeResponseValue;
}
	// void CommitmentTransaction_free(struct LDKCommitmentTransaction this_obj);
/* @internal */
export function CommitmentTransaction_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_free(this_obj);
	// debug statements here
}
	// uint64_t CommitmentTransaction_clone_ptr(LDKCommitmentTransaction *NONNULL_PTR arg);
/* @internal */
export function CommitmentTransaction_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCommitmentTransaction CommitmentTransaction_clone(const struct LDKCommitmentTransaction *NONNULL_PTR orig);
/* @internal */
export function CommitmentTransaction_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z CommitmentTransaction_write(const struct LDKCommitmentTransaction *NONNULL_PTR obj);
/* @internal */
export function CommitmentTransaction_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_CommitmentTransactionDecodeErrorZ CommitmentTransaction_read(struct LDKu8slice ser);
/* @internal */
export function CommitmentTransaction_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_read(ser);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t CommitmentTransaction_commitment_number(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function CommitmentTransaction_commitment_number(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_commitment_number(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t CommitmentTransaction_to_broadcaster_value_sat(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function CommitmentTransaction_to_broadcaster_value_sat(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_to_broadcaster_value_sat(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t CommitmentTransaction_to_countersignatory_value_sat(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function CommitmentTransaction_to_countersignatory_value_sat(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_to_countersignatory_value_sat(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint32_t CommitmentTransaction_feerate_per_kw(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function CommitmentTransaction_feerate_per_kw(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_feerate_per_kw(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKTrustedCommitmentTransaction CommitmentTransaction_trust(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function CommitmentTransaction_trust(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_trust(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_TrustedCommitmentTransactionNoneZ CommitmentTransaction_verify(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg, const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR channel_parameters, const struct LDKChannelPublicKeys *NONNULL_PTR broadcaster_keys, const struct LDKChannelPublicKeys *NONNULL_PTR countersignatory_keys);
/* @internal */
export function CommitmentTransaction_verify(this_arg: bigint, channel_parameters: bigint, broadcaster_keys: bigint, countersignatory_keys: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_verify(this_arg, channel_parameters, broadcaster_keys, countersignatory_keys);
	return nativeResponseValue;
}
	// void TrustedCommitmentTransaction_free(struct LDKTrustedCommitmentTransaction this_obj);
/* @internal */
export function TrustedCommitmentTransaction_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKThirtyTwoBytes TrustedCommitmentTransaction_txid(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function TrustedCommitmentTransaction_txid(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_txid(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKBuiltCommitmentTransaction TrustedCommitmentTransaction_built_transaction(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function TrustedCommitmentTransaction_built_transaction(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_built_transaction(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKTxCreationKeys TrustedCommitmentTransaction_keys(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function TrustedCommitmentTransaction_keys(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_keys(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelTypeFeatures TrustedCommitmentTransaction_channel_type_features(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function TrustedCommitmentTransaction_channel_type_features(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_channel_type_features(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_CVec_SignatureZNoneZ TrustedCommitmentTransaction_get_htlc_sigs(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*htlc_base_key)[32], const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR channel_parameters, const struct LDKEntropySource *NONNULL_PTR entropy_source);
/* @internal */
export function TrustedCommitmentTransaction_get_htlc_sigs(this_arg: bigint, htlc_base_key: number, channel_parameters: bigint, entropy_source: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_get_htlc_sigs(this_arg, htlc_base_key, channel_parameters, entropy_source);
	return nativeResponseValue;
}
	// uint64_t get_commitment_transaction_number_obscure_factor(struct LDKPublicKey broadcaster_payment_basepoint, struct LDKPublicKey countersignatory_payment_basepoint, bool outbound_from_broadcaster);
/* @internal */
export function get_commitment_transaction_number_obscure_factor(broadcaster_payment_basepoint: number, countersignatory_payment_basepoint: number, outbound_from_broadcaster: boolean): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_get_commitment_transaction_number_obscure_factor(broadcaster_payment_basepoint, countersignatory_payment_basepoint, outbound_from_broadcaster);
	return nativeResponseValue;
}
	// bool InitFeatures_eq(const struct LDKInitFeatures *NONNULL_PTR a, const struct LDKInitFeatures *NONNULL_PTR b);
/* @internal */
export function InitFeatures_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_eq(a, b);
	return nativeResponseValue;
}
	// bool NodeFeatures_eq(const struct LDKNodeFeatures *NONNULL_PTR a, const struct LDKNodeFeatures *NONNULL_PTR b);
/* @internal */
export function NodeFeatures_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_eq(a, b);
	return nativeResponseValue;
}
	// bool ChannelFeatures_eq(const struct LDKChannelFeatures *NONNULL_PTR a, const struct LDKChannelFeatures *NONNULL_PTR b);
/* @internal */
export function ChannelFeatures_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_eq(a, b);
	return nativeResponseValue;
}
	// bool Bolt11InvoiceFeatures_eq(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR a, const struct LDKBolt11InvoiceFeatures *NONNULL_PTR b);
/* @internal */
export function Bolt11InvoiceFeatures_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_eq(a, b);
	return nativeResponseValue;
}
	// bool OfferFeatures_eq(const struct LDKOfferFeatures *NONNULL_PTR a, const struct LDKOfferFeatures *NONNULL_PTR b);
/* @internal */
export function OfferFeatures_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OfferFeatures_eq(a, b);
	return nativeResponseValue;
}
	// bool InvoiceRequestFeatures_eq(const struct LDKInvoiceRequestFeatures *NONNULL_PTR a, const struct LDKInvoiceRequestFeatures *NONNULL_PTR b);
/* @internal */
export function InvoiceRequestFeatures_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequestFeatures_eq(a, b);
	return nativeResponseValue;
}
	// bool Bolt12InvoiceFeatures_eq(const struct LDKBolt12InvoiceFeatures *NONNULL_PTR a, const struct LDKBolt12InvoiceFeatures *NONNULL_PTR b);
/* @internal */
export function Bolt12InvoiceFeatures_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12InvoiceFeatures_eq(a, b);
	return nativeResponseValue;
}
	// bool BlindedHopFeatures_eq(const struct LDKBlindedHopFeatures *NONNULL_PTR a, const struct LDKBlindedHopFeatures *NONNULL_PTR b);
/* @internal */
export function BlindedHopFeatures_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHopFeatures_eq(a, b);
	return nativeResponseValue;
}
	// bool ChannelTypeFeatures_eq(const struct LDKChannelTypeFeatures *NONNULL_PTR a, const struct LDKChannelTypeFeatures *NONNULL_PTR b);
/* @internal */
export function ChannelTypeFeatures_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_eq(a, b);
	return nativeResponseValue;
}
	// uint64_t InitFeatures_clone_ptr(LDKInitFeatures *NONNULL_PTR arg);
/* @internal */
export function InitFeatures_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKInitFeatures InitFeatures_clone(const struct LDKInitFeatures *NONNULL_PTR orig);
/* @internal */
export function InitFeatures_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_clone(orig);
	return nativeResponseValue;
}
	// uint64_t NodeFeatures_clone_ptr(LDKNodeFeatures *NONNULL_PTR arg);
/* @internal */
export function NodeFeatures_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKNodeFeatures NodeFeatures_clone(const struct LDKNodeFeatures *NONNULL_PTR orig);
/* @internal */
export function NodeFeatures_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_clone(orig);
	return nativeResponseValue;
}
	// uint64_t ChannelFeatures_clone_ptr(LDKChannelFeatures *NONNULL_PTR arg);
/* @internal */
export function ChannelFeatures_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelFeatures ChannelFeatures_clone(const struct LDKChannelFeatures *NONNULL_PTR orig);
/* @internal */
export function ChannelFeatures_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_clone(orig);
	return nativeResponseValue;
}
	// uint64_t Bolt11InvoiceFeatures_clone_ptr(LDKBolt11InvoiceFeatures *NONNULL_PTR arg);
/* @internal */
export function Bolt11InvoiceFeatures_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBolt11InvoiceFeatures Bolt11InvoiceFeatures_clone(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR orig);
/* @internal */
export function Bolt11InvoiceFeatures_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_clone(orig);
	return nativeResponseValue;
}
	// uint64_t OfferFeatures_clone_ptr(LDKOfferFeatures *NONNULL_PTR arg);
/* @internal */
export function OfferFeatures_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OfferFeatures_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKOfferFeatures OfferFeatures_clone(const struct LDKOfferFeatures *NONNULL_PTR orig);
/* @internal */
export function OfferFeatures_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OfferFeatures_clone(orig);
	return nativeResponseValue;
}
	// uint64_t InvoiceRequestFeatures_clone_ptr(LDKInvoiceRequestFeatures *NONNULL_PTR arg);
/* @internal */
export function InvoiceRequestFeatures_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequestFeatures_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKInvoiceRequestFeatures InvoiceRequestFeatures_clone(const struct LDKInvoiceRequestFeatures *NONNULL_PTR orig);
/* @internal */
export function InvoiceRequestFeatures_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequestFeatures_clone(orig);
	return nativeResponseValue;
}
	// uint64_t Bolt12InvoiceFeatures_clone_ptr(LDKBolt12InvoiceFeatures *NONNULL_PTR arg);
/* @internal */
export function Bolt12InvoiceFeatures_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12InvoiceFeatures_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBolt12InvoiceFeatures Bolt12InvoiceFeatures_clone(const struct LDKBolt12InvoiceFeatures *NONNULL_PTR orig);
/* @internal */
export function Bolt12InvoiceFeatures_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12InvoiceFeatures_clone(orig);
	return nativeResponseValue;
}
	// uint64_t BlindedHopFeatures_clone_ptr(LDKBlindedHopFeatures *NONNULL_PTR arg);
/* @internal */
export function BlindedHopFeatures_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHopFeatures_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBlindedHopFeatures BlindedHopFeatures_clone(const struct LDKBlindedHopFeatures *NONNULL_PTR orig);
/* @internal */
export function BlindedHopFeatures_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHopFeatures_clone(orig);
	return nativeResponseValue;
}
	// uint64_t ChannelTypeFeatures_clone_ptr(LDKChannelTypeFeatures *NONNULL_PTR arg);
/* @internal */
export function ChannelTypeFeatures_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelTypeFeatures ChannelTypeFeatures_clone(const struct LDKChannelTypeFeatures *NONNULL_PTR orig);
/* @internal */
export function ChannelTypeFeatures_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_clone(orig);
	return nativeResponseValue;
}
	// void InitFeatures_free(struct LDKInitFeatures this_obj);
/* @internal */
export function InitFeatures_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_free(this_obj);
	// debug statements here
}
	// void NodeFeatures_free(struct LDKNodeFeatures this_obj);
/* @internal */
export function NodeFeatures_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_free(this_obj);
	// debug statements here
}
	// void ChannelFeatures_free(struct LDKChannelFeatures this_obj);
/* @internal */
export function ChannelFeatures_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_free(this_obj);
	// debug statements here
}
	// void Bolt11InvoiceFeatures_free(struct LDKBolt11InvoiceFeatures this_obj);
/* @internal */
export function Bolt11InvoiceFeatures_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_free(this_obj);
	// debug statements here
}
	// void OfferFeatures_free(struct LDKOfferFeatures this_obj);
/* @internal */
export function OfferFeatures_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OfferFeatures_free(this_obj);
	// debug statements here
}
	// void InvoiceRequestFeatures_free(struct LDKInvoiceRequestFeatures this_obj);
/* @internal */
export function InvoiceRequestFeatures_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequestFeatures_free(this_obj);
	// debug statements here
}
	// void Bolt12InvoiceFeatures_free(struct LDKBolt12InvoiceFeatures this_obj);
/* @internal */
export function Bolt12InvoiceFeatures_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12InvoiceFeatures_free(this_obj);
	// debug statements here
}
	// void BlindedHopFeatures_free(struct LDKBlindedHopFeatures this_obj);
/* @internal */
export function BlindedHopFeatures_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHopFeatures_free(this_obj);
	// debug statements here
}
	// void ChannelTypeFeatures_free(struct LDKChannelTypeFeatures this_obj);
/* @internal */
export function ChannelTypeFeatures_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKInitFeatures InitFeatures_empty(void);
/* @internal */
export function InitFeatures_empty(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_empty();
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_unknown_bits_from(const struct LDKInitFeatures *NONNULL_PTR this_arg, const struct LDKInitFeatures *NONNULL_PTR other);
/* @internal */
export function InitFeatures_requires_unknown_bits_from(this_arg: bigint, other: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_unknown_bits_from(this_arg, other);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_unknown_bits(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_requires_unknown_bits(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_unknown_bits(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ InitFeatures_set_required_custom_bit(struct LDKInitFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function InitFeatures_set_required_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_required_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ InitFeatures_set_optional_custom_bit(struct LDKInitFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function InitFeatures_set_optional_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_optional_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKNodeFeatures NodeFeatures_empty(void);
/* @internal */
export function NodeFeatures_empty(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_empty();
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_unknown_bits_from(const struct LDKNodeFeatures *NONNULL_PTR this_arg, const struct LDKNodeFeatures *NONNULL_PTR other);
/* @internal */
export function NodeFeatures_requires_unknown_bits_from(this_arg: bigint, other: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_unknown_bits_from(this_arg, other);
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_unknown_bits(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_unknown_bits(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_unknown_bits(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ NodeFeatures_set_required_custom_bit(struct LDKNodeFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function NodeFeatures_set_required_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_required_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ NodeFeatures_set_optional_custom_bit(struct LDKNodeFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function NodeFeatures_set_optional_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_optional_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelFeatures ChannelFeatures_empty(void);
/* @internal */
export function ChannelFeatures_empty(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_empty();
	return nativeResponseValue;
}
	// MUST_USE_RES bool ChannelFeatures_requires_unknown_bits_from(const struct LDKChannelFeatures *NONNULL_PTR this_arg, const struct LDKChannelFeatures *NONNULL_PTR other);
/* @internal */
export function ChannelFeatures_requires_unknown_bits_from(this_arg: bigint, other: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_requires_unknown_bits_from(this_arg, other);
	return nativeResponseValue;
}
	// MUST_USE_RES bool ChannelFeatures_requires_unknown_bits(const struct LDKChannelFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelFeatures_requires_unknown_bits(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_requires_unknown_bits(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelFeatures_set_required_custom_bit(struct LDKChannelFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function ChannelFeatures_set_required_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_set_required_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelFeatures_set_optional_custom_bit(struct LDKChannelFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function ChannelFeatures_set_optional_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_set_optional_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKBolt11InvoiceFeatures Bolt11InvoiceFeatures_empty(void);
/* @internal */
export function Bolt11InvoiceFeatures_empty(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_empty();
	return nativeResponseValue;
}
	// MUST_USE_RES bool Bolt11InvoiceFeatures_requires_unknown_bits_from(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg, const struct LDKBolt11InvoiceFeatures *NONNULL_PTR other);
/* @internal */
export function Bolt11InvoiceFeatures_requires_unknown_bits_from(this_arg: bigint, other: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_requires_unknown_bits_from(this_arg, other);
	return nativeResponseValue;
}
	// MUST_USE_RES bool Bolt11InvoiceFeatures_requires_unknown_bits(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11InvoiceFeatures_requires_unknown_bits(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_requires_unknown_bits(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ Bolt11InvoiceFeatures_set_required_custom_bit(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function Bolt11InvoiceFeatures_set_required_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_set_required_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ Bolt11InvoiceFeatures_set_optional_custom_bit(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function Bolt11InvoiceFeatures_set_optional_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_set_optional_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKOfferFeatures OfferFeatures_empty(void);
/* @internal */
export function OfferFeatures_empty(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OfferFeatures_empty();
	return nativeResponseValue;
}
	// MUST_USE_RES bool OfferFeatures_requires_unknown_bits_from(const struct LDKOfferFeatures *NONNULL_PTR this_arg, const struct LDKOfferFeatures *NONNULL_PTR other);
/* @internal */
export function OfferFeatures_requires_unknown_bits_from(this_arg: bigint, other: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OfferFeatures_requires_unknown_bits_from(this_arg, other);
	return nativeResponseValue;
}
	// MUST_USE_RES bool OfferFeatures_requires_unknown_bits(const struct LDKOfferFeatures *NONNULL_PTR this_arg);
/* @internal */
export function OfferFeatures_requires_unknown_bits(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OfferFeatures_requires_unknown_bits(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ OfferFeatures_set_required_custom_bit(struct LDKOfferFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function OfferFeatures_set_required_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OfferFeatures_set_required_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ OfferFeatures_set_optional_custom_bit(struct LDKOfferFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function OfferFeatures_set_optional_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OfferFeatures_set_optional_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInvoiceRequestFeatures InvoiceRequestFeatures_empty(void);
/* @internal */
export function InvoiceRequestFeatures_empty(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequestFeatures_empty();
	return nativeResponseValue;
}
	// MUST_USE_RES bool InvoiceRequestFeatures_requires_unknown_bits_from(const struct LDKInvoiceRequestFeatures *NONNULL_PTR this_arg, const struct LDKInvoiceRequestFeatures *NONNULL_PTR other);
/* @internal */
export function InvoiceRequestFeatures_requires_unknown_bits_from(this_arg: bigint, other: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequestFeatures_requires_unknown_bits_from(this_arg, other);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InvoiceRequestFeatures_requires_unknown_bits(const struct LDKInvoiceRequestFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InvoiceRequestFeatures_requires_unknown_bits(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequestFeatures_requires_unknown_bits(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ InvoiceRequestFeatures_set_required_custom_bit(struct LDKInvoiceRequestFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function InvoiceRequestFeatures_set_required_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequestFeatures_set_required_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ InvoiceRequestFeatures_set_optional_custom_bit(struct LDKInvoiceRequestFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function InvoiceRequestFeatures_set_optional_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequestFeatures_set_optional_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKBolt12InvoiceFeatures Bolt12InvoiceFeatures_empty(void);
/* @internal */
export function Bolt12InvoiceFeatures_empty(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12InvoiceFeatures_empty();
	return nativeResponseValue;
}
	// MUST_USE_RES bool Bolt12InvoiceFeatures_requires_unknown_bits_from(const struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg, const struct LDKBolt12InvoiceFeatures *NONNULL_PTR other);
/* @internal */
export function Bolt12InvoiceFeatures_requires_unknown_bits_from(this_arg: bigint, other: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12InvoiceFeatures_requires_unknown_bits_from(this_arg, other);
	return nativeResponseValue;
}
	// MUST_USE_RES bool Bolt12InvoiceFeatures_requires_unknown_bits(const struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt12InvoiceFeatures_requires_unknown_bits(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12InvoiceFeatures_requires_unknown_bits(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ Bolt12InvoiceFeatures_set_required_custom_bit(struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function Bolt12InvoiceFeatures_set_required_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12InvoiceFeatures_set_required_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ Bolt12InvoiceFeatures_set_optional_custom_bit(struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function Bolt12InvoiceFeatures_set_optional_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12InvoiceFeatures_set_optional_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKBlindedHopFeatures BlindedHopFeatures_empty(void);
/* @internal */
export function BlindedHopFeatures_empty(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHopFeatures_empty();
	return nativeResponseValue;
}
	// MUST_USE_RES bool BlindedHopFeatures_requires_unknown_bits_from(const struct LDKBlindedHopFeatures *NONNULL_PTR this_arg, const struct LDKBlindedHopFeatures *NONNULL_PTR other);
/* @internal */
export function BlindedHopFeatures_requires_unknown_bits_from(this_arg: bigint, other: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHopFeatures_requires_unknown_bits_from(this_arg, other);
	return nativeResponseValue;
}
	// MUST_USE_RES bool BlindedHopFeatures_requires_unknown_bits(const struct LDKBlindedHopFeatures *NONNULL_PTR this_arg);
/* @internal */
export function BlindedHopFeatures_requires_unknown_bits(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHopFeatures_requires_unknown_bits(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ BlindedHopFeatures_set_required_custom_bit(struct LDKBlindedHopFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function BlindedHopFeatures_set_required_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHopFeatures_set_required_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ BlindedHopFeatures_set_optional_custom_bit(struct LDKBlindedHopFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function BlindedHopFeatures_set_optional_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHopFeatures_set_optional_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelTypeFeatures ChannelTypeFeatures_empty(void);
/* @internal */
export function ChannelTypeFeatures_empty(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_empty();
	return nativeResponseValue;
}
	// MUST_USE_RES bool ChannelTypeFeatures_requires_unknown_bits_from(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg, const struct LDKChannelTypeFeatures *NONNULL_PTR other);
/* @internal */
export function ChannelTypeFeatures_requires_unknown_bits_from(this_arg: bigint, other: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_requires_unknown_bits_from(this_arg, other);
	return nativeResponseValue;
}
	// MUST_USE_RES bool ChannelTypeFeatures_requires_unknown_bits(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_requires_unknown_bits(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_requires_unknown_bits(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelTypeFeatures_set_required_custom_bit(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function ChannelTypeFeatures_set_required_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_set_required_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelTypeFeatures_set_optional_custom_bit(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg, uintptr_t bit);
/* @internal */
export function ChannelTypeFeatures_set_optional_custom_bit(this_arg: bigint, bit: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_set_optional_custom_bit(this_arg, bit);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z InitFeatures_write(const struct LDKInitFeatures *NONNULL_PTR obj);
/* @internal */
export function InitFeatures_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_InitFeaturesDecodeErrorZ InitFeatures_read(struct LDKu8slice ser);
/* @internal */
export function InitFeatures_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelFeatures_write(const struct LDKChannelFeatures *NONNULL_PTR obj);
/* @internal */
export function ChannelFeatures_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelFeaturesDecodeErrorZ ChannelFeatures_read(struct LDKu8slice ser);
/* @internal */
export function ChannelFeatures_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z NodeFeatures_write(const struct LDKNodeFeatures *NONNULL_PTR obj);
/* @internal */
export function NodeFeatures_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeFeaturesDecodeErrorZ NodeFeatures_read(struct LDKu8slice ser);
/* @internal */
export function NodeFeatures_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Bolt11InvoiceFeatures_write(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR obj);
/* @internal */
export function Bolt11InvoiceFeatures_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ Bolt11InvoiceFeatures_read(struct LDKu8slice ser);
/* @internal */
export function Bolt11InvoiceFeatures_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Bolt12InvoiceFeatures_write(const struct LDKBolt12InvoiceFeatures *NONNULL_PTR obj);
/* @internal */
export function Bolt12InvoiceFeatures_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12InvoiceFeatures_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ Bolt12InvoiceFeatures_read(struct LDKu8slice ser);
/* @internal */
export function Bolt12InvoiceFeatures_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12InvoiceFeatures_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z BlindedHopFeatures_write(const struct LDKBlindedHopFeatures *NONNULL_PTR obj);
/* @internal */
export function BlindedHopFeatures_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHopFeatures_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedHopFeaturesDecodeErrorZ BlindedHopFeatures_read(struct LDKu8slice ser);
/* @internal */
export function BlindedHopFeatures_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHopFeatures_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelTypeFeatures_write(const struct LDKChannelTypeFeatures *NONNULL_PTR obj);
/* @internal */
export function ChannelTypeFeatures_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ ChannelTypeFeatures_read(struct LDKu8slice ser);
/* @internal */
export function ChannelTypeFeatures_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_read(ser);
	return nativeResponseValue;
}
	// void InitFeatures_set_data_loss_protect_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_data_loss_protect_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_data_loss_protect_optional(this_arg);
	// debug statements here
}
	// void InitFeatures_set_data_loss_protect_required(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_data_loss_protect_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_data_loss_protect_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool InitFeatures_supports_data_loss_protect(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_supports_data_loss_protect(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_supports_data_loss_protect(this_arg);
	return nativeResponseValue;
}
	// void NodeFeatures_set_data_loss_protect_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_data_loss_protect_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_data_loss_protect_optional(this_arg);
	// debug statements here
}
	// void NodeFeatures_set_data_loss_protect_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_data_loss_protect_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_data_loss_protect_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool NodeFeatures_supports_data_loss_protect(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_supports_data_loss_protect(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_supports_data_loss_protect(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_data_loss_protect(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_requires_data_loss_protect(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_data_loss_protect(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_data_loss_protect(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_data_loss_protect(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_data_loss_protect(this_arg);
	return nativeResponseValue;
}
	// void InitFeatures_set_initial_routing_sync_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_initial_routing_sync_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_initial_routing_sync_optional(this_arg);
	// debug statements here
}
	// void InitFeatures_set_initial_routing_sync_required(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_initial_routing_sync_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_initial_routing_sync_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool InitFeatures_initial_routing_sync(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_initial_routing_sync(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_initial_routing_sync(this_arg);
	return nativeResponseValue;
}
	// void InitFeatures_set_upfront_shutdown_script_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_upfront_shutdown_script_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_upfront_shutdown_script_optional(this_arg);
	// debug statements here
}
	// void InitFeatures_set_upfront_shutdown_script_required(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_upfront_shutdown_script_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_upfront_shutdown_script_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool InitFeatures_supports_upfront_shutdown_script(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_supports_upfront_shutdown_script(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_supports_upfront_shutdown_script(this_arg);
	return nativeResponseValue;
}
	// void NodeFeatures_set_upfront_shutdown_script_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_upfront_shutdown_script_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_upfront_shutdown_script_optional(this_arg);
	// debug statements here
}
	// void NodeFeatures_set_upfront_shutdown_script_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_upfront_shutdown_script_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_upfront_shutdown_script_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool NodeFeatures_supports_upfront_shutdown_script(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_supports_upfront_shutdown_script(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_supports_upfront_shutdown_script(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_upfront_shutdown_script(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_requires_upfront_shutdown_script(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_upfront_shutdown_script(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_upfront_shutdown_script(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_upfront_shutdown_script(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_upfront_shutdown_script(this_arg);
	return nativeResponseValue;
}
	// void InitFeatures_set_gossip_queries_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_gossip_queries_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_gossip_queries_optional(this_arg);
	// debug statements here
}
	// void InitFeatures_set_gossip_queries_required(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_gossip_queries_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_gossip_queries_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool InitFeatures_supports_gossip_queries(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_supports_gossip_queries(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_supports_gossip_queries(this_arg);
	return nativeResponseValue;
}
	// void NodeFeatures_set_gossip_queries_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_gossip_queries_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_gossip_queries_optional(this_arg);
	// debug statements here
}
	// void NodeFeatures_set_gossip_queries_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_gossip_queries_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_gossip_queries_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool NodeFeatures_supports_gossip_queries(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_supports_gossip_queries(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_supports_gossip_queries(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_gossip_queries(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_requires_gossip_queries(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_gossip_queries(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_gossip_queries(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_gossip_queries(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_gossip_queries(this_arg);
	return nativeResponseValue;
}
	// void InitFeatures_set_variable_length_onion_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_variable_length_onion_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_variable_length_onion_optional(this_arg);
	// debug statements here
}
	// void InitFeatures_set_variable_length_onion_required(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_variable_length_onion_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_variable_length_onion_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool InitFeatures_supports_variable_length_onion(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_supports_variable_length_onion(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_supports_variable_length_onion(this_arg);
	return nativeResponseValue;
}
	// void NodeFeatures_set_variable_length_onion_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_variable_length_onion_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_variable_length_onion_optional(this_arg);
	// debug statements here
}
	// void NodeFeatures_set_variable_length_onion_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_variable_length_onion_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_variable_length_onion_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool NodeFeatures_supports_variable_length_onion(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_supports_variable_length_onion(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_supports_variable_length_onion(this_arg);
	return nativeResponseValue;
}
	// void Bolt11InvoiceFeatures_set_variable_length_onion_optional(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11InvoiceFeatures_set_variable_length_onion_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_set_variable_length_onion_optional(this_arg);
	// debug statements here
}
	// void Bolt11InvoiceFeatures_set_variable_length_onion_required(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11InvoiceFeatures_set_variable_length_onion_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_set_variable_length_onion_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool Bolt11InvoiceFeatures_supports_variable_length_onion(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11InvoiceFeatures_supports_variable_length_onion(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_supports_variable_length_onion(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_variable_length_onion(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_requires_variable_length_onion(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_variable_length_onion(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_variable_length_onion(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_variable_length_onion(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_variable_length_onion(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool Bolt11InvoiceFeatures_requires_variable_length_onion(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11InvoiceFeatures_requires_variable_length_onion(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_requires_variable_length_onion(this_arg);
	return nativeResponseValue;
}
	// void InitFeatures_set_static_remote_key_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_static_remote_key_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_static_remote_key_optional(this_arg);
	// debug statements here
}
	// void InitFeatures_set_static_remote_key_required(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_static_remote_key_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_static_remote_key_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool InitFeatures_supports_static_remote_key(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_supports_static_remote_key(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_supports_static_remote_key(this_arg);
	return nativeResponseValue;
}
	// void NodeFeatures_set_static_remote_key_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_static_remote_key_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_static_remote_key_optional(this_arg);
	// debug statements here
}
	// void NodeFeatures_set_static_remote_key_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_static_remote_key_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_static_remote_key_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool NodeFeatures_supports_static_remote_key(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_supports_static_remote_key(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_supports_static_remote_key(this_arg);
	return nativeResponseValue;
}
	// void ChannelTypeFeatures_set_static_remote_key_optional(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_set_static_remote_key_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_set_static_remote_key_optional(this_arg);
	// debug statements here
}
	// void ChannelTypeFeatures_set_static_remote_key_required(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_set_static_remote_key_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_set_static_remote_key_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool ChannelTypeFeatures_supports_static_remote_key(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_supports_static_remote_key(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_supports_static_remote_key(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_static_remote_key(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_requires_static_remote_key(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_static_remote_key(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_static_remote_key(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_static_remote_key(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_static_remote_key(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool ChannelTypeFeatures_requires_static_remote_key(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_requires_static_remote_key(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_requires_static_remote_key(this_arg);
	return nativeResponseValue;
}
	// void InitFeatures_set_payment_secret_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_payment_secret_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_payment_secret_optional(this_arg);
	// debug statements here
}
	// void InitFeatures_set_payment_secret_required(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_payment_secret_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_payment_secret_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool InitFeatures_supports_payment_secret(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_supports_payment_secret(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_supports_payment_secret(this_arg);
	return nativeResponseValue;
}
	// void NodeFeatures_set_payment_secret_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_payment_secret_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_payment_secret_optional(this_arg);
	// debug statements here
}
	// void NodeFeatures_set_payment_secret_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_payment_secret_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_payment_secret_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool NodeFeatures_supports_payment_secret(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_supports_payment_secret(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_supports_payment_secret(this_arg);
	return nativeResponseValue;
}
	// void Bolt11InvoiceFeatures_set_payment_secret_optional(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11InvoiceFeatures_set_payment_secret_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_set_payment_secret_optional(this_arg);
	// debug statements here
}
	// void Bolt11InvoiceFeatures_set_payment_secret_required(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11InvoiceFeatures_set_payment_secret_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_set_payment_secret_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool Bolt11InvoiceFeatures_supports_payment_secret(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11InvoiceFeatures_supports_payment_secret(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_supports_payment_secret(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_payment_secret(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_requires_payment_secret(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_payment_secret(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_payment_secret(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_payment_secret(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_payment_secret(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool Bolt11InvoiceFeatures_requires_payment_secret(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11InvoiceFeatures_requires_payment_secret(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_requires_payment_secret(this_arg);
	return nativeResponseValue;
}
	// void InitFeatures_set_basic_mpp_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_basic_mpp_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_basic_mpp_optional(this_arg);
	// debug statements here
}
	// void InitFeatures_set_basic_mpp_required(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_basic_mpp_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_basic_mpp_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool InitFeatures_supports_basic_mpp(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_supports_basic_mpp(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_supports_basic_mpp(this_arg);
	return nativeResponseValue;
}
	// void NodeFeatures_set_basic_mpp_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_basic_mpp_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_basic_mpp_optional(this_arg);
	// debug statements here
}
	// void NodeFeatures_set_basic_mpp_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_basic_mpp_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_basic_mpp_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool NodeFeatures_supports_basic_mpp(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_supports_basic_mpp(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_supports_basic_mpp(this_arg);
	return nativeResponseValue;
}
	// void Bolt11InvoiceFeatures_set_basic_mpp_optional(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11InvoiceFeatures_set_basic_mpp_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_set_basic_mpp_optional(this_arg);
	// debug statements here
}
	// void Bolt11InvoiceFeatures_set_basic_mpp_required(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11InvoiceFeatures_set_basic_mpp_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_set_basic_mpp_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool Bolt11InvoiceFeatures_supports_basic_mpp(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11InvoiceFeatures_supports_basic_mpp(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_supports_basic_mpp(this_arg);
	return nativeResponseValue;
}
	// void Bolt12InvoiceFeatures_set_basic_mpp_optional(struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt12InvoiceFeatures_set_basic_mpp_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12InvoiceFeatures_set_basic_mpp_optional(this_arg);
	// debug statements here
}
	// void Bolt12InvoiceFeatures_set_basic_mpp_required(struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt12InvoiceFeatures_set_basic_mpp_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12InvoiceFeatures_set_basic_mpp_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool Bolt12InvoiceFeatures_supports_basic_mpp(const struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt12InvoiceFeatures_supports_basic_mpp(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12InvoiceFeatures_supports_basic_mpp(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_basic_mpp(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_requires_basic_mpp(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_basic_mpp(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_basic_mpp(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_basic_mpp(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_basic_mpp(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool Bolt11InvoiceFeatures_requires_basic_mpp(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11InvoiceFeatures_requires_basic_mpp(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_requires_basic_mpp(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool Bolt12InvoiceFeatures_requires_basic_mpp(const struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt12InvoiceFeatures_requires_basic_mpp(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12InvoiceFeatures_requires_basic_mpp(this_arg);
	return nativeResponseValue;
}
	// void InitFeatures_set_wumbo_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_wumbo_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_wumbo_optional(this_arg);
	// debug statements here
}
	// void InitFeatures_set_wumbo_required(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_wumbo_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_wumbo_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool InitFeatures_supports_wumbo(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_supports_wumbo(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_supports_wumbo(this_arg);
	return nativeResponseValue;
}
	// void NodeFeatures_set_wumbo_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_wumbo_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_wumbo_optional(this_arg);
	// debug statements here
}
	// void NodeFeatures_set_wumbo_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_wumbo_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_wumbo_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool NodeFeatures_supports_wumbo(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_supports_wumbo(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_supports_wumbo(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_wumbo(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_requires_wumbo(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_wumbo(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_wumbo(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_wumbo(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_wumbo(this_arg);
	return nativeResponseValue;
}
	// void InitFeatures_set_anchors_nonzero_fee_htlc_tx_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_anchors_nonzero_fee_htlc_tx_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_anchors_nonzero_fee_htlc_tx_optional(this_arg);
	// debug statements here
}
	// void InitFeatures_set_anchors_nonzero_fee_htlc_tx_required(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_anchors_nonzero_fee_htlc_tx_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_anchors_nonzero_fee_htlc_tx_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool InitFeatures_supports_anchors_nonzero_fee_htlc_tx(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_supports_anchors_nonzero_fee_htlc_tx(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_supports_anchors_nonzero_fee_htlc_tx(this_arg);
	return nativeResponseValue;
}
	// void NodeFeatures_set_anchors_nonzero_fee_htlc_tx_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_anchors_nonzero_fee_htlc_tx_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_anchors_nonzero_fee_htlc_tx_optional(this_arg);
	// debug statements here
}
	// void NodeFeatures_set_anchors_nonzero_fee_htlc_tx_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_anchors_nonzero_fee_htlc_tx_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_anchors_nonzero_fee_htlc_tx_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool NodeFeatures_supports_anchors_nonzero_fee_htlc_tx(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_supports_anchors_nonzero_fee_htlc_tx(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_supports_anchors_nonzero_fee_htlc_tx(this_arg);
	return nativeResponseValue;
}
	// void ChannelTypeFeatures_set_anchors_nonzero_fee_htlc_tx_optional(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_set_anchors_nonzero_fee_htlc_tx_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_set_anchors_nonzero_fee_htlc_tx_optional(this_arg);
	// debug statements here
}
	// void ChannelTypeFeatures_set_anchors_nonzero_fee_htlc_tx_required(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_set_anchors_nonzero_fee_htlc_tx_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_set_anchors_nonzero_fee_htlc_tx_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool ChannelTypeFeatures_supports_anchors_nonzero_fee_htlc_tx(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_supports_anchors_nonzero_fee_htlc_tx(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_supports_anchors_nonzero_fee_htlc_tx(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_anchors_nonzero_fee_htlc_tx(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_requires_anchors_nonzero_fee_htlc_tx(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_anchors_nonzero_fee_htlc_tx(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_anchors_nonzero_fee_htlc_tx(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_anchors_nonzero_fee_htlc_tx(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_anchors_nonzero_fee_htlc_tx(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool ChannelTypeFeatures_requires_anchors_nonzero_fee_htlc_tx(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_requires_anchors_nonzero_fee_htlc_tx(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_requires_anchors_nonzero_fee_htlc_tx(this_arg);
	return nativeResponseValue;
}
	// void InitFeatures_set_anchors_zero_fee_htlc_tx_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_anchors_zero_fee_htlc_tx_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_anchors_zero_fee_htlc_tx_optional(this_arg);
	// debug statements here
}
	// void InitFeatures_set_anchors_zero_fee_htlc_tx_required(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_anchors_zero_fee_htlc_tx_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_anchors_zero_fee_htlc_tx_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool InitFeatures_supports_anchors_zero_fee_htlc_tx(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_supports_anchors_zero_fee_htlc_tx(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_supports_anchors_zero_fee_htlc_tx(this_arg);
	return nativeResponseValue;
}
	// void NodeFeatures_set_anchors_zero_fee_htlc_tx_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_anchors_zero_fee_htlc_tx_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_anchors_zero_fee_htlc_tx_optional(this_arg);
	// debug statements here
}
	// void NodeFeatures_set_anchors_zero_fee_htlc_tx_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_anchors_zero_fee_htlc_tx_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_anchors_zero_fee_htlc_tx_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool NodeFeatures_supports_anchors_zero_fee_htlc_tx(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_supports_anchors_zero_fee_htlc_tx(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_supports_anchors_zero_fee_htlc_tx(this_arg);
	return nativeResponseValue;
}
	// void ChannelTypeFeatures_set_anchors_zero_fee_htlc_tx_optional(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_set_anchors_zero_fee_htlc_tx_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_set_anchors_zero_fee_htlc_tx_optional(this_arg);
	// debug statements here
}
	// void ChannelTypeFeatures_set_anchors_zero_fee_htlc_tx_required(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_set_anchors_zero_fee_htlc_tx_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_set_anchors_zero_fee_htlc_tx_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool ChannelTypeFeatures_supports_anchors_zero_fee_htlc_tx(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_supports_anchors_zero_fee_htlc_tx(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_supports_anchors_zero_fee_htlc_tx(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_anchors_zero_fee_htlc_tx(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_requires_anchors_zero_fee_htlc_tx(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_anchors_zero_fee_htlc_tx(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_anchors_zero_fee_htlc_tx(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_anchors_zero_fee_htlc_tx(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_anchors_zero_fee_htlc_tx(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool ChannelTypeFeatures_requires_anchors_zero_fee_htlc_tx(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_requires_anchors_zero_fee_htlc_tx(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_requires_anchors_zero_fee_htlc_tx(this_arg);
	return nativeResponseValue;
}
	// void InitFeatures_set_shutdown_any_segwit_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_shutdown_any_segwit_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_shutdown_any_segwit_optional(this_arg);
	// debug statements here
}
	// void InitFeatures_set_shutdown_any_segwit_required(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_shutdown_any_segwit_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_shutdown_any_segwit_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool InitFeatures_supports_shutdown_anysegwit(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_supports_shutdown_anysegwit(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_supports_shutdown_anysegwit(this_arg);
	return nativeResponseValue;
}
	// void NodeFeatures_set_shutdown_any_segwit_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_shutdown_any_segwit_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_shutdown_any_segwit_optional(this_arg);
	// debug statements here
}
	// void NodeFeatures_set_shutdown_any_segwit_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_shutdown_any_segwit_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_shutdown_any_segwit_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool NodeFeatures_supports_shutdown_anysegwit(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_supports_shutdown_anysegwit(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_supports_shutdown_anysegwit(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_shutdown_anysegwit(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_requires_shutdown_anysegwit(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_shutdown_anysegwit(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_shutdown_anysegwit(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_shutdown_anysegwit(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_shutdown_anysegwit(this_arg);
	return nativeResponseValue;
}
	// void InitFeatures_set_onion_messages_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_onion_messages_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_onion_messages_optional(this_arg);
	// debug statements here
}
	// void InitFeatures_set_onion_messages_required(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_onion_messages_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_onion_messages_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool InitFeatures_supports_onion_messages(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_supports_onion_messages(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_supports_onion_messages(this_arg);
	return nativeResponseValue;
}
	// void NodeFeatures_set_onion_messages_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_onion_messages_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_onion_messages_optional(this_arg);
	// debug statements here
}
	// void NodeFeatures_set_onion_messages_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_onion_messages_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_onion_messages_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool NodeFeatures_supports_onion_messages(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_supports_onion_messages(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_supports_onion_messages(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_onion_messages(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_requires_onion_messages(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_onion_messages(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_onion_messages(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_onion_messages(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_onion_messages(this_arg);
	return nativeResponseValue;
}
	// void InitFeatures_set_channel_type_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_channel_type_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_channel_type_optional(this_arg);
	// debug statements here
}
	// void InitFeatures_set_channel_type_required(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_channel_type_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_channel_type_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool InitFeatures_supports_channel_type(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_supports_channel_type(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_supports_channel_type(this_arg);
	return nativeResponseValue;
}
	// void NodeFeatures_set_channel_type_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_channel_type_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_channel_type_optional(this_arg);
	// debug statements here
}
	// void NodeFeatures_set_channel_type_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_channel_type_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_channel_type_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool NodeFeatures_supports_channel_type(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_supports_channel_type(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_supports_channel_type(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_channel_type(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_requires_channel_type(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_channel_type(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_channel_type(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_channel_type(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_channel_type(this_arg);
	return nativeResponseValue;
}
	// void InitFeatures_set_scid_privacy_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_scid_privacy_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_scid_privacy_optional(this_arg);
	// debug statements here
}
	// void InitFeatures_set_scid_privacy_required(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_scid_privacy_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_scid_privacy_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool InitFeatures_supports_scid_privacy(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_supports_scid_privacy(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_supports_scid_privacy(this_arg);
	return nativeResponseValue;
}
	// void NodeFeatures_set_scid_privacy_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_scid_privacy_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_scid_privacy_optional(this_arg);
	// debug statements here
}
	// void NodeFeatures_set_scid_privacy_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_scid_privacy_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_scid_privacy_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool NodeFeatures_supports_scid_privacy(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_supports_scid_privacy(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_supports_scid_privacy(this_arg);
	return nativeResponseValue;
}
	// void ChannelTypeFeatures_set_scid_privacy_optional(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_set_scid_privacy_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_set_scid_privacy_optional(this_arg);
	// debug statements here
}
	// void ChannelTypeFeatures_set_scid_privacy_required(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_set_scid_privacy_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_set_scid_privacy_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool ChannelTypeFeatures_supports_scid_privacy(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_supports_scid_privacy(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_supports_scid_privacy(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_scid_privacy(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_requires_scid_privacy(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_scid_privacy(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_scid_privacy(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_scid_privacy(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_scid_privacy(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool ChannelTypeFeatures_requires_scid_privacy(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_requires_scid_privacy(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_requires_scid_privacy(this_arg);
	return nativeResponseValue;
}
	// void Bolt11InvoiceFeatures_set_payment_metadata_optional(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11InvoiceFeatures_set_payment_metadata_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_set_payment_metadata_optional(this_arg);
	// debug statements here
}
	// void Bolt11InvoiceFeatures_set_payment_metadata_required(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11InvoiceFeatures_set_payment_metadata_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_set_payment_metadata_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool Bolt11InvoiceFeatures_supports_payment_metadata(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11InvoiceFeatures_supports_payment_metadata(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_supports_payment_metadata(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool Bolt11InvoiceFeatures_requires_payment_metadata(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11InvoiceFeatures_requires_payment_metadata(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceFeatures_requires_payment_metadata(this_arg);
	return nativeResponseValue;
}
	// void InitFeatures_set_zero_conf_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_zero_conf_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_zero_conf_optional(this_arg);
	// debug statements here
}
	// void InitFeatures_set_zero_conf_required(struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_set_zero_conf_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_set_zero_conf_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool InitFeatures_supports_zero_conf(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_supports_zero_conf(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_supports_zero_conf(this_arg);
	return nativeResponseValue;
}
	// void NodeFeatures_set_zero_conf_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_zero_conf_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_zero_conf_optional(this_arg);
	// debug statements here
}
	// void NodeFeatures_set_zero_conf_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_zero_conf_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_zero_conf_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool NodeFeatures_supports_zero_conf(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_supports_zero_conf(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_supports_zero_conf(this_arg);
	return nativeResponseValue;
}
	// void ChannelTypeFeatures_set_zero_conf_optional(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_set_zero_conf_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_set_zero_conf_optional(this_arg);
	// debug statements here
}
	// void ChannelTypeFeatures_set_zero_conf_required(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_set_zero_conf_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_set_zero_conf_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool ChannelTypeFeatures_supports_zero_conf(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_supports_zero_conf(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_supports_zero_conf(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_zero_conf(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_requires_zero_conf(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_zero_conf(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_zero_conf(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_zero_conf(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_zero_conf(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool ChannelTypeFeatures_requires_zero_conf(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_requires_zero_conf(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_requires_zero_conf(this_arg);
	return nativeResponseValue;
}
	// void NodeFeatures_set_keysend_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_keysend_optional(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_keysend_optional(this_arg);
	// debug statements here
}
	// void NodeFeatures_set_keysend_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_set_keysend_required(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_set_keysend_required(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool NodeFeatures_supports_keysend(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_supports_keysend(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_supports_keysend(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_keysend(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_keysend(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_keysend(this_arg);
	return nativeResponseValue;
}
	// void ShutdownScript_free(struct LDKShutdownScript this_obj);
/* @internal */
export function ShutdownScript_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_free(this_obj);
	// debug statements here
}
	// uint64_t ShutdownScript_clone_ptr(LDKShutdownScript *NONNULL_PTR arg);
/* @internal */
export function ShutdownScript_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKShutdownScript ShutdownScript_clone(const struct LDKShutdownScript *NONNULL_PTR orig);
/* @internal */
export function ShutdownScript_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_clone(orig);
	return nativeResponseValue;
}
	// bool ShutdownScript_eq(const struct LDKShutdownScript *NONNULL_PTR a, const struct LDKShutdownScript *NONNULL_PTR b);
/* @internal */
export function ShutdownScript_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_eq(a, b);
	return nativeResponseValue;
}
	// void InvalidShutdownScript_free(struct LDKInvalidShutdownScript this_obj);
/* @internal */
export function InvalidShutdownScript_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvalidShutdownScript_free(this_obj);
	// debug statements here
}
	// struct LDKu8slice InvalidShutdownScript_get_script(const struct LDKInvalidShutdownScript *NONNULL_PTR this_ptr);
/* @internal */
export function InvalidShutdownScript_get_script(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvalidShutdownScript_get_script(this_ptr);
	return nativeResponseValue;
}
	// void InvalidShutdownScript_set_script(struct LDKInvalidShutdownScript *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);
/* @internal */
export function InvalidShutdownScript_set_script(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvalidShutdownScript_set_script(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKInvalidShutdownScript InvalidShutdownScript_new(struct LDKCVec_u8Z script_arg);
/* @internal */
export function InvalidShutdownScript_new(script_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvalidShutdownScript_new(script_arg);
	return nativeResponseValue;
}
	// uint64_t InvalidShutdownScript_clone_ptr(LDKInvalidShutdownScript *NONNULL_PTR arg);
/* @internal */
export function InvalidShutdownScript_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvalidShutdownScript_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKInvalidShutdownScript InvalidShutdownScript_clone(const struct LDKInvalidShutdownScript *NONNULL_PTR orig);
/* @internal */
export function InvalidShutdownScript_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvalidShutdownScript_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ShutdownScript_write(const struct LDKShutdownScript *NONNULL_PTR obj);
/* @internal */
export function ShutdownScript_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownScriptDecodeErrorZ ShutdownScript_read(struct LDKu8slice ser);
/* @internal */
export function ShutdownScript_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_read(ser);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKShutdownScript ShutdownScript_new_p2wpkh(const uint8_t (*pubkey_hash)[20]);
/* @internal */
export function ShutdownScript_new_p2wpkh(pubkey_hash: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_new_p2wpkh(pubkey_hash);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKShutdownScript ShutdownScript_new_p2wsh(const uint8_t (*script_hash)[32]);
/* @internal */
export function ShutdownScript_new_p2wsh(script_hash: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_new_p2wsh(script_hash);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ ShutdownScript_new_witness_program(struct LDKWitnessVersion version, struct LDKu8slice program);
/* @internal */
export function ShutdownScript_new_witness_program(version: number, program: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_new_witness_program(version, program);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_u8Z ShutdownScript_into_inner(struct LDKShutdownScript this_arg);
/* @internal */
export function ShutdownScript_into_inner(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_into_inner(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPublicKey ShutdownScript_as_legacy_pubkey(const struct LDKShutdownScript *NONNULL_PTR this_arg);
/* @internal */
export function ShutdownScript_as_legacy_pubkey(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_as_legacy_pubkey(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool ShutdownScript_is_compatible(const struct LDKShutdownScript *NONNULL_PTR this_arg, const struct LDKInitFeatures *NONNULL_PTR features);
/* @internal */
export function ShutdownScript_is_compatible(this_arg: bigint, features: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_is_compatible(this_arg, features);
	return nativeResponseValue;
}
	// void Retry_free(struct LDKRetry this_ptr);
/* @internal */
export function Retry_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Retry_free(this_ptr);
	// debug statements here
}
	// uint64_t Retry_clone_ptr(LDKRetry *NONNULL_PTR arg);
/* @internal */
export function Retry_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Retry_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRetry Retry_clone(const struct LDKRetry *NONNULL_PTR orig);
/* @internal */
export function Retry_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Retry_clone(orig);
	return nativeResponseValue;
}
	// struct LDKRetry Retry_attempts(uintptr_t a);
/* @internal */
export function Retry_attempts(a: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Retry_attempts(a);
	return nativeResponseValue;
}
	// bool Retry_eq(const struct LDKRetry *NONNULL_PTR a, const struct LDKRetry *NONNULL_PTR b);
/* @internal */
export function Retry_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Retry_eq(a, b);
	return nativeResponseValue;
}
	// uint64_t Retry_hash(const struct LDKRetry *NONNULL_PTR o);
/* @internal */
export function Retry_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Retry_hash(o);
	return nativeResponseValue;
}
	// enum LDKRetryableSendFailure RetryableSendFailure_clone(const enum LDKRetryableSendFailure *NONNULL_PTR orig);
/* @internal */
export function RetryableSendFailure_clone(orig: bigint): RetryableSendFailure {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RetryableSendFailure_clone(orig);
	return nativeResponseValue;
}
	// enum LDKRetryableSendFailure RetryableSendFailure_payment_expired(void);
/* @internal */
export function RetryableSendFailure_payment_expired(): RetryableSendFailure {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RetryableSendFailure_payment_expired();
	return nativeResponseValue;
}
	// enum LDKRetryableSendFailure RetryableSendFailure_route_not_found(void);
/* @internal */
export function RetryableSendFailure_route_not_found(): RetryableSendFailure {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RetryableSendFailure_route_not_found();
	return nativeResponseValue;
}
	// enum LDKRetryableSendFailure RetryableSendFailure_duplicate_payment(void);
/* @internal */
export function RetryableSendFailure_duplicate_payment(): RetryableSendFailure {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RetryableSendFailure_duplicate_payment();
	return nativeResponseValue;
}
	// bool RetryableSendFailure_eq(const enum LDKRetryableSendFailure *NONNULL_PTR a, const enum LDKRetryableSendFailure *NONNULL_PTR b);
/* @internal */
export function RetryableSendFailure_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RetryableSendFailure_eq(a, b);
	return nativeResponseValue;
}
	// void PaymentSendFailure_free(struct LDKPaymentSendFailure this_ptr);
/* @internal */
export function PaymentSendFailure_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentSendFailure_free(this_ptr);
	// debug statements here
}
	// uint64_t PaymentSendFailure_clone_ptr(LDKPaymentSendFailure *NONNULL_PTR arg);
/* @internal */
export function PaymentSendFailure_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentSendFailure_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPaymentSendFailure PaymentSendFailure_clone(const struct LDKPaymentSendFailure *NONNULL_PTR orig);
/* @internal */
export function PaymentSendFailure_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentSendFailure_clone(orig);
	return nativeResponseValue;
}
	// struct LDKPaymentSendFailure PaymentSendFailure_parameter_error(struct LDKAPIError a);
/* @internal */
export function PaymentSendFailure_parameter_error(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentSendFailure_parameter_error(a);
	return nativeResponseValue;
}
	// struct LDKPaymentSendFailure PaymentSendFailure_path_parameter_error(struct LDKCVec_CResult_NoneAPIErrorZZ a);
/* @internal */
export function PaymentSendFailure_path_parameter_error(a: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentSendFailure_path_parameter_error(a);
	return nativeResponseValue;
}
	// struct LDKPaymentSendFailure PaymentSendFailure_all_failed_resend_safe(struct LDKCVec_APIErrorZ a);
/* @internal */
export function PaymentSendFailure_all_failed_resend_safe(a: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentSendFailure_all_failed_resend_safe(a);
	return nativeResponseValue;
}
	// struct LDKPaymentSendFailure PaymentSendFailure_duplicate_payment(void);
/* @internal */
export function PaymentSendFailure_duplicate_payment(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentSendFailure_duplicate_payment();
	return nativeResponseValue;
}
	// struct LDKPaymentSendFailure PaymentSendFailure_partial_failure(struct LDKCVec_CResult_NoneAPIErrorZZ results, struct LDKRouteParameters failed_paths_retry, struct LDKThirtyTwoBytes payment_id);
/* @internal */
export function PaymentSendFailure_partial_failure(results: number, failed_paths_retry: bigint, payment_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentSendFailure_partial_failure(results, failed_paths_retry, payment_id);
	return nativeResponseValue;
}
	// void RecipientOnionFields_free(struct LDKRecipientOnionFields this_obj);
/* @internal */
export function RecipientOnionFields_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecipientOnionFields_free(this_obj);
	// debug statements here
}
	// struct LDKCOption_PaymentSecretZ RecipientOnionFields_get_payment_secret(const struct LDKRecipientOnionFields *NONNULL_PTR this_ptr);
/* @internal */
export function RecipientOnionFields_get_payment_secret(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecipientOnionFields_get_payment_secret(this_ptr);
	return nativeResponseValue;
}
	// void RecipientOnionFields_set_payment_secret(struct LDKRecipientOnionFields *NONNULL_PTR this_ptr, struct LDKCOption_PaymentSecretZ val);
/* @internal */
export function RecipientOnionFields_set_payment_secret(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecipientOnionFields_set_payment_secret(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_CVec_u8ZZ RecipientOnionFields_get_payment_metadata(const struct LDKRecipientOnionFields *NONNULL_PTR this_ptr);
/* @internal */
export function RecipientOnionFields_get_payment_metadata(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecipientOnionFields_get_payment_metadata(this_ptr);
	return nativeResponseValue;
}
	// void RecipientOnionFields_set_payment_metadata(struct LDKRecipientOnionFields *NONNULL_PTR this_ptr, struct LDKCOption_CVec_u8ZZ val);
/* @internal */
export function RecipientOnionFields_set_payment_metadata(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecipientOnionFields_set_payment_metadata(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKRecipientOnionFields RecipientOnionFields_new(struct LDKCOption_PaymentSecretZ payment_secret_arg, struct LDKCOption_CVec_u8ZZ payment_metadata_arg);
/* @internal */
export function RecipientOnionFields_new(payment_secret_arg: bigint, payment_metadata_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecipientOnionFields_new(payment_secret_arg, payment_metadata_arg);
	return nativeResponseValue;
}
	// uint64_t RecipientOnionFields_clone_ptr(LDKRecipientOnionFields *NONNULL_PTR arg);
/* @internal */
export function RecipientOnionFields_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecipientOnionFields_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRecipientOnionFields RecipientOnionFields_clone(const struct LDKRecipientOnionFields *NONNULL_PTR orig);
/* @internal */
export function RecipientOnionFields_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecipientOnionFields_clone(orig);
	return nativeResponseValue;
}
	// bool RecipientOnionFields_eq(const struct LDKRecipientOnionFields *NONNULL_PTR a, const struct LDKRecipientOnionFields *NONNULL_PTR b);
/* @internal */
export function RecipientOnionFields_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecipientOnionFields_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z RecipientOnionFields_write(const struct LDKRecipientOnionFields *NONNULL_PTR obj);
/* @internal */
export function RecipientOnionFields_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecipientOnionFields_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_RecipientOnionFieldsDecodeErrorZ RecipientOnionFields_read(struct LDKu8slice ser);
/* @internal */
export function RecipientOnionFields_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecipientOnionFields_read(ser);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKRecipientOnionFields RecipientOnionFields_secret_only(struct LDKThirtyTwoBytes payment_secret);
/* @internal */
export function RecipientOnionFields_secret_only(payment_secret: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecipientOnionFields_secret_only(payment_secret);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKRecipientOnionFields RecipientOnionFields_spontaneous_empty(void);
/* @internal */
export function RecipientOnionFields_spontaneous_empty(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RecipientOnionFields_spontaneous_empty();
	return nativeResponseValue;
}
	// void CustomMessageReader_free(struct LDKCustomMessageReader this_ptr);
/* @internal */
export function CustomMessageReader_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomMessageReader_free(this_ptr);
	// debug statements here
}
	// uint64_t Type_clone_ptr(LDKType *NONNULL_PTR arg);
/* @internal */
export function Type_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Type_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKType Type_clone(const struct LDKType *NONNULL_PTR orig);
/* @internal */
export function Type_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Type_clone(orig);
	return nativeResponseValue;
}
	// void Type_free(struct LDKType this_ptr);
/* @internal */
export function Type_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Type_free(this_ptr);
	// debug statements here
}
	// void UnsignedBolt12Invoice_free(struct LDKUnsignedBolt12Invoice this_obj);
/* @internal */
export function UnsignedBolt12Invoice_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedBolt12Invoice_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKPublicKey UnsignedBolt12Invoice_signing_pubkey(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);
/* @internal */
export function UnsignedBolt12Invoice_signing_pubkey(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedBolt12Invoice_signing_pubkey(this_arg);
	return nativeResponseValue;
}
	// void Bolt12Invoice_free(struct LDKBolt12Invoice this_obj);
/* @internal */
export function Bolt12Invoice_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12Invoice_free(this_obj);
	// debug statements here
}
	// uint64_t Bolt12Invoice_clone_ptr(LDKBolt12Invoice *NONNULL_PTR arg);
/* @internal */
export function Bolt12Invoice_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12Invoice_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBolt12Invoice Bolt12Invoice_clone(const struct LDKBolt12Invoice *NONNULL_PTR orig);
/* @internal */
export function Bolt12Invoice_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12Invoice_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPrintableString Bolt12Invoice_description(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt12Invoice_description(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12Invoice_description(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Bolt12Invoice_created_at(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt12Invoice_created_at(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12Invoice_created_at(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Bolt12Invoice_relative_expiry(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt12Invoice_relative_expiry(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12Invoice_relative_expiry(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes Bolt12Invoice_payment_hash(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt12Invoice_payment_hash(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12Invoice_payment_hash(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Bolt12Invoice_amount_msats(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt12Invoice_amount_msats(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12Invoice_amount_msats(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKBolt12InvoiceFeatures Bolt12Invoice_features(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt12Invoice_features(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12Invoice_features(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPublicKey Bolt12Invoice_signing_pubkey(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt12Invoice_signing_pubkey(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12Invoice_signing_pubkey(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes Bolt12Invoice_signable_hash(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt12Invoice_signable_hash(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12Invoice_signable_hash(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool Bolt12Invoice_verify(const struct LDKBolt12Invoice *NONNULL_PTR this_arg, const struct LDKExpandedKey *NONNULL_PTR key);
/* @internal */
export function Bolt12Invoice_verify(this_arg: bigint, key: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12Invoice_verify(this_arg, key);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Bolt12Invoice_write(const struct LDKBolt12Invoice *NONNULL_PTR obj);
/* @internal */
export function Bolt12Invoice_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12Invoice_write(obj);
	return nativeResponseValue;
}
	// void BlindedPayInfo_free(struct LDKBlindedPayInfo this_obj);
/* @internal */
export function BlindedPayInfo_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_free(this_obj);
	// debug statements here
}
	// uint32_t BlindedPayInfo_get_fee_base_msat(const struct LDKBlindedPayInfo *NONNULL_PTR this_ptr);
/* @internal */
export function BlindedPayInfo_get_fee_base_msat(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_get_fee_base_msat(this_ptr);
	return nativeResponseValue;
}
	// void BlindedPayInfo_set_fee_base_msat(struct LDKBlindedPayInfo *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function BlindedPayInfo_set_fee_base_msat(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_set_fee_base_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t BlindedPayInfo_get_fee_proportional_millionths(const struct LDKBlindedPayInfo *NONNULL_PTR this_ptr);
/* @internal */
export function BlindedPayInfo_get_fee_proportional_millionths(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_get_fee_proportional_millionths(this_ptr);
	return nativeResponseValue;
}
	// void BlindedPayInfo_set_fee_proportional_millionths(struct LDKBlindedPayInfo *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function BlindedPayInfo_set_fee_proportional_millionths(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_set_fee_proportional_millionths(this_ptr, val);
	// debug statements here
}
	// uint16_t BlindedPayInfo_get_cltv_expiry_delta(const struct LDKBlindedPayInfo *NONNULL_PTR this_ptr);
/* @internal */
export function BlindedPayInfo_get_cltv_expiry_delta(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_get_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void BlindedPayInfo_set_cltv_expiry_delta(struct LDKBlindedPayInfo *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function BlindedPayInfo_set_cltv_expiry_delta(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_set_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// uint64_t BlindedPayInfo_get_htlc_minimum_msat(const struct LDKBlindedPayInfo *NONNULL_PTR this_ptr);
/* @internal */
export function BlindedPayInfo_get_htlc_minimum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_get_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void BlindedPayInfo_set_htlc_minimum_msat(struct LDKBlindedPayInfo *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function BlindedPayInfo_set_htlc_minimum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_set_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t BlindedPayInfo_get_htlc_maximum_msat(const struct LDKBlindedPayInfo *NONNULL_PTR this_ptr);
/* @internal */
export function BlindedPayInfo_get_htlc_maximum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_get_htlc_maximum_msat(this_ptr);
	return nativeResponseValue;
}
	// void BlindedPayInfo_set_htlc_maximum_msat(struct LDKBlindedPayInfo *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function BlindedPayInfo_set_htlc_maximum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_set_htlc_maximum_msat(this_ptr, val);
	// debug statements here
}
	// struct LDKBlindedHopFeatures BlindedPayInfo_get_features(const struct LDKBlindedPayInfo *NONNULL_PTR this_ptr);
/* @internal */
export function BlindedPayInfo_get_features(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_get_features(this_ptr);
	return nativeResponseValue;
}
	// void BlindedPayInfo_set_features(struct LDKBlindedPayInfo *NONNULL_PTR this_ptr, struct LDKBlindedHopFeatures val);
/* @internal */
export function BlindedPayInfo_set_features(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_set_features(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKBlindedPayInfo BlindedPayInfo_new(uint32_t fee_base_msat_arg, uint32_t fee_proportional_millionths_arg, uint16_t cltv_expiry_delta_arg, uint64_t htlc_minimum_msat_arg, uint64_t htlc_maximum_msat_arg, struct LDKBlindedHopFeatures features_arg);
/* @internal */
export function BlindedPayInfo_new(fee_base_msat_arg: number, fee_proportional_millionths_arg: number, cltv_expiry_delta_arg: number, htlc_minimum_msat_arg: bigint, htlc_maximum_msat_arg: bigint, features_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_new(fee_base_msat_arg, fee_proportional_millionths_arg, cltv_expiry_delta_arg, htlc_minimum_msat_arg, htlc_maximum_msat_arg, features_arg);
	return nativeResponseValue;
}
	// uint64_t BlindedPayInfo_clone_ptr(LDKBlindedPayInfo *NONNULL_PTR arg);
/* @internal */
export function BlindedPayInfo_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBlindedPayInfo BlindedPayInfo_clone(const struct LDKBlindedPayInfo *NONNULL_PTR orig);
/* @internal */
export function BlindedPayInfo_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_clone(orig);
	return nativeResponseValue;
}
	// uint64_t BlindedPayInfo_hash(const struct LDKBlindedPayInfo *NONNULL_PTR o);
/* @internal */
export function BlindedPayInfo_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_hash(o);
	return nativeResponseValue;
}
	// bool BlindedPayInfo_eq(const struct LDKBlindedPayInfo *NONNULL_PTR a, const struct LDKBlindedPayInfo *NONNULL_PTR b);
/* @internal */
export function BlindedPayInfo_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z BlindedPayInfo_write(const struct LDKBlindedPayInfo *NONNULL_PTR obj);
/* @internal */
export function BlindedPayInfo_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedPayInfoDecodeErrorZ BlindedPayInfo_read(struct LDKu8slice ser);
/* @internal */
export function BlindedPayInfo_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPayInfo_read(ser);
	return nativeResponseValue;
}
	// void InvoiceError_free(struct LDKInvoiceError this_obj);
/* @internal */
export function InvoiceError_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceError_free(this_obj);
	// debug statements here
}
	// struct LDKErroneousField InvoiceError_get_erroneous_field(const struct LDKInvoiceError *NONNULL_PTR this_ptr);
/* @internal */
export function InvoiceError_get_erroneous_field(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceError_get_erroneous_field(this_ptr);
	return nativeResponseValue;
}
	// void InvoiceError_set_erroneous_field(struct LDKInvoiceError *NONNULL_PTR this_ptr, struct LDKErroneousField val);
/* @internal */
export function InvoiceError_set_erroneous_field(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceError_set_erroneous_field(this_ptr, val);
	// debug statements here
}
	// struct LDKUntrustedString InvoiceError_get_message(const struct LDKInvoiceError *NONNULL_PTR this_ptr);
/* @internal */
export function InvoiceError_get_message(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceError_get_message(this_ptr);
	return nativeResponseValue;
}
	// void InvoiceError_set_message(struct LDKInvoiceError *NONNULL_PTR this_ptr, struct LDKUntrustedString val);
/* @internal */
export function InvoiceError_set_message(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceError_set_message(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKInvoiceError InvoiceError_new(struct LDKErroneousField erroneous_field_arg, struct LDKUntrustedString message_arg);
/* @internal */
export function InvoiceError_new(erroneous_field_arg: bigint, message_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceError_new(erroneous_field_arg, message_arg);
	return nativeResponseValue;
}
	// uint64_t InvoiceError_clone_ptr(LDKInvoiceError *NONNULL_PTR arg);
/* @internal */
export function InvoiceError_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKInvoiceError InvoiceError_clone(const struct LDKInvoiceError *NONNULL_PTR orig);
/* @internal */
export function InvoiceError_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceError_clone(orig);
	return nativeResponseValue;
}
	// void ErroneousField_free(struct LDKErroneousField this_obj);
/* @internal */
export function ErroneousField_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErroneousField_free(this_obj);
	// debug statements here
}
	// uint64_t ErroneousField_get_tlv_fieldnum(const struct LDKErroneousField *NONNULL_PTR this_ptr);
/* @internal */
export function ErroneousField_get_tlv_fieldnum(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErroneousField_get_tlv_fieldnum(this_ptr);
	return nativeResponseValue;
}
	// void ErroneousField_set_tlv_fieldnum(struct LDKErroneousField *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ErroneousField_set_tlv_fieldnum(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErroneousField_set_tlv_fieldnum(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_CVec_u8ZZ ErroneousField_get_suggested_value(const struct LDKErroneousField *NONNULL_PTR this_ptr);
/* @internal */
export function ErroneousField_get_suggested_value(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErroneousField_get_suggested_value(this_ptr);
	return nativeResponseValue;
}
	// void ErroneousField_set_suggested_value(struct LDKErroneousField *NONNULL_PTR this_ptr, struct LDKCOption_CVec_u8ZZ val);
/* @internal */
export function ErroneousField_set_suggested_value(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErroneousField_set_suggested_value(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKErroneousField ErroneousField_new(uint64_t tlv_fieldnum_arg, struct LDKCOption_CVec_u8ZZ suggested_value_arg);
/* @internal */
export function ErroneousField_new(tlv_fieldnum_arg: bigint, suggested_value_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErroneousField_new(tlv_fieldnum_arg, suggested_value_arg);
	return nativeResponseValue;
}
	// uint64_t ErroneousField_clone_ptr(LDKErroneousField *NONNULL_PTR arg);
/* @internal */
export function ErroneousField_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErroneousField_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKErroneousField ErroneousField_clone(const struct LDKErroneousField *NONNULL_PTR orig);
/* @internal */
export function ErroneousField_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErroneousField_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z InvoiceError_write(const struct LDKInvoiceError *NONNULL_PTR obj);
/* @internal */
export function InvoiceError_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceError_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceErrorDecodeErrorZ InvoiceError_read(struct LDKu8slice ser);
/* @internal */
export function InvoiceError_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceError_read(ser);
	return nativeResponseValue;
}
	// void UnsignedInvoiceRequest_free(struct LDKUnsignedInvoiceRequest this_obj);
/* @internal */
export function UnsignedInvoiceRequest_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedInvoiceRequest_free(this_obj);
	// debug statements here
}
	// void InvoiceRequest_free(struct LDKInvoiceRequest this_obj);
/* @internal */
export function InvoiceRequest_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequest_free(this_obj);
	// debug statements here
}
	// uint64_t InvoiceRequest_clone_ptr(LDKInvoiceRequest *NONNULL_PTR arg);
/* @internal */
export function InvoiceRequest_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequest_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKInvoiceRequest InvoiceRequest_clone(const struct LDKInvoiceRequest *NONNULL_PTR orig);
/* @internal */
export function InvoiceRequest_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequest_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKu8slice InvoiceRequest_metadata(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);
/* @internal */
export function InvoiceRequest_metadata(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequest_metadata(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes InvoiceRequest_chain(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);
/* @internal */
export function InvoiceRequest_chain(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequest_chain(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_u64Z InvoiceRequest_amount_msats(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);
/* @internal */
export function InvoiceRequest_amount_msats(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequest_amount_msats(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInvoiceRequestFeatures InvoiceRequest_features(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);
/* @internal */
export function InvoiceRequest_features(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequest_features(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_u64Z InvoiceRequest_quantity(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);
/* @internal */
export function InvoiceRequest_quantity(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequest_quantity(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPublicKey InvoiceRequest_payer_id(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);
/* @internal */
export function InvoiceRequest_payer_id(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequest_payer_id(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPrintableString InvoiceRequest_payer_note(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);
/* @internal */
export function InvoiceRequest_payer_note(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequest_payer_note(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_COption_KeyPairZNoneZ InvoiceRequest_verify(const struct LDKInvoiceRequest *NONNULL_PTR this_arg, const struct LDKExpandedKey *NONNULL_PTR key);
/* @internal */
export function InvoiceRequest_verify(this_arg: bigint, key: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequest_verify(this_arg, key);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z InvoiceRequest_write(const struct LDKInvoiceRequest *NONNULL_PTR obj);
/* @internal */
export function InvoiceRequest_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceRequest_write(obj);
	return nativeResponseValue;
}
	// void Offer_free(struct LDKOffer this_obj);
/* @internal */
export function Offer_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_free(this_obj);
	// debug statements here
}
	// uint64_t Offer_clone_ptr(LDKOffer *NONNULL_PTR arg);
/* @internal */
export function Offer_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKOffer Offer_clone(const struct LDKOffer *NONNULL_PTR orig);
/* @internal */
export function Offer_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_ChainHashZ Offer_chains(const struct LDKOffer *NONNULL_PTR this_arg);
/* @internal */
export function Offer_chains(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_chains(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool Offer_supports_chain(const struct LDKOffer *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes chain);
/* @internal */
export function Offer_supports_chain(this_arg: bigint, chain: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_supports_chain(this_arg, chain);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_CVec_u8ZZ Offer_metadata(const struct LDKOffer *NONNULL_PTR this_arg);
/* @internal */
export function Offer_metadata(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_metadata(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKAmount Offer_amount(const struct LDKOffer *NONNULL_PTR this_arg);
/* @internal */
export function Offer_amount(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_amount(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPrintableString Offer_description(const struct LDKOffer *NONNULL_PTR this_arg);
/* @internal */
export function Offer_description(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_description(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKOfferFeatures Offer_features(const struct LDKOffer *NONNULL_PTR this_arg);
/* @internal */
export function Offer_features(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_features(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_DurationZ Offer_absolute_expiry(const struct LDKOffer *NONNULL_PTR this_arg);
/* @internal */
export function Offer_absolute_expiry(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_absolute_expiry(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPrintableString Offer_issuer(const struct LDKOffer *NONNULL_PTR this_arg);
/* @internal */
export function Offer_issuer(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_issuer(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_BlindedPathZ Offer_paths(const struct LDKOffer *NONNULL_PTR this_arg);
/* @internal */
export function Offer_paths(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_paths(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKQuantity Offer_supported_quantity(const struct LDKOffer *NONNULL_PTR this_arg);
/* @internal */
export function Offer_supported_quantity(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_supported_quantity(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool Offer_is_valid_quantity(const struct LDKOffer *NONNULL_PTR this_arg, uint64_t quantity);
/* @internal */
export function Offer_is_valid_quantity(this_arg: bigint, quantity: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_is_valid_quantity(this_arg, quantity);
	return nativeResponseValue;
}
	// MUST_USE_RES bool Offer_expects_quantity(const struct LDKOffer *NONNULL_PTR this_arg);
/* @internal */
export function Offer_expects_quantity(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_expects_quantity(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPublicKey Offer_signing_pubkey(const struct LDKOffer *NONNULL_PTR this_arg);
/* @internal */
export function Offer_signing_pubkey(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_signing_pubkey(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Offer_write(const struct LDKOffer *NONNULL_PTR obj);
/* @internal */
export function Offer_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_write(obj);
	return nativeResponseValue;
}
	// void Amount_free(struct LDKAmount this_obj);
/* @internal */
export function Amount_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Amount_free(this_obj);
	// debug statements here
}
	// uint64_t Amount_clone_ptr(LDKAmount *NONNULL_PTR arg);
/* @internal */
export function Amount_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Amount_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKAmount Amount_clone(const struct LDKAmount *NONNULL_PTR orig);
/* @internal */
export function Amount_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Amount_clone(orig);
	return nativeResponseValue;
}
	// void Quantity_free(struct LDKQuantity this_obj);
/* @internal */
export function Quantity_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Quantity_free(this_obj);
	// debug statements here
}
	// uint64_t Quantity_clone_ptr(LDKQuantity *NONNULL_PTR arg);
/* @internal */
export function Quantity_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Quantity_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKQuantity Quantity_clone(const struct LDKQuantity *NONNULL_PTR orig);
/* @internal */
export function Quantity_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Quantity_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_OfferBolt12ParseErrorZ Offer_from_str(struct LDKStr s);
/* @internal */
export function Offer_from_str(s: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Offer_from_str(s);
	return nativeResponseValue;
}
	// void Bolt12ParseError_free(struct LDKBolt12ParseError this_obj);
/* @internal */
export function Bolt12ParseError_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12ParseError_free(this_obj);
	// debug statements here
}
	// uint64_t Bolt12ParseError_clone_ptr(LDKBolt12ParseError *NONNULL_PTR arg);
/* @internal */
export function Bolt12ParseError_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12ParseError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBolt12ParseError Bolt12ParseError_clone(const struct LDKBolt12ParseError *NONNULL_PTR orig);
/* @internal */
export function Bolt12ParseError_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12ParseError_clone(orig);
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_clone(const enum LDKBolt12SemanticError *NONNULL_PTR orig);
/* @internal */
export function Bolt12SemanticError_clone(orig: bigint): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_clone(orig);
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_already_expired(void);
/* @internal */
export function Bolt12SemanticError_already_expired(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_already_expired();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_unsupported_chain(void);
/* @internal */
export function Bolt12SemanticError_unsupported_chain(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_unsupported_chain();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_unexpected_chain(void);
/* @internal */
export function Bolt12SemanticError_unexpected_chain(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_unexpected_chain();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_missing_amount(void);
/* @internal */
export function Bolt12SemanticError_missing_amount(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_missing_amount();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_invalid_amount(void);
/* @internal */
export function Bolt12SemanticError_invalid_amount(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_invalid_amount();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_insufficient_amount(void);
/* @internal */
export function Bolt12SemanticError_insufficient_amount(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_insufficient_amount();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_unexpected_amount(void);
/* @internal */
export function Bolt12SemanticError_unexpected_amount(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_unexpected_amount();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_unsupported_currency(void);
/* @internal */
export function Bolt12SemanticError_unsupported_currency(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_unsupported_currency();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_unknown_required_features(void);
/* @internal */
export function Bolt12SemanticError_unknown_required_features(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_unknown_required_features();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_unexpected_features(void);
/* @internal */
export function Bolt12SemanticError_unexpected_features(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_unexpected_features();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_missing_description(void);
/* @internal */
export function Bolt12SemanticError_missing_description(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_missing_description();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_missing_signing_pubkey(void);
/* @internal */
export function Bolt12SemanticError_missing_signing_pubkey(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_missing_signing_pubkey();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_invalid_signing_pubkey(void);
/* @internal */
export function Bolt12SemanticError_invalid_signing_pubkey(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_invalid_signing_pubkey();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_unexpected_signing_pubkey(void);
/* @internal */
export function Bolt12SemanticError_unexpected_signing_pubkey(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_unexpected_signing_pubkey();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_missing_quantity(void);
/* @internal */
export function Bolt12SemanticError_missing_quantity(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_missing_quantity();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_invalid_quantity(void);
/* @internal */
export function Bolt12SemanticError_invalid_quantity(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_invalid_quantity();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_unexpected_quantity(void);
/* @internal */
export function Bolt12SemanticError_unexpected_quantity(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_unexpected_quantity();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_invalid_metadata(void);
/* @internal */
export function Bolt12SemanticError_invalid_metadata(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_invalid_metadata();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_unexpected_metadata(void);
/* @internal */
export function Bolt12SemanticError_unexpected_metadata(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_unexpected_metadata();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_missing_payer_metadata(void);
/* @internal */
export function Bolt12SemanticError_missing_payer_metadata(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_missing_payer_metadata();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_missing_payer_id(void);
/* @internal */
export function Bolt12SemanticError_missing_payer_id(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_missing_payer_id();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_missing_paths(void);
/* @internal */
export function Bolt12SemanticError_missing_paths(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_missing_paths();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_invalid_pay_info(void);
/* @internal */
export function Bolt12SemanticError_invalid_pay_info(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_invalid_pay_info();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_missing_creation_time(void);
/* @internal */
export function Bolt12SemanticError_missing_creation_time(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_missing_creation_time();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_missing_payment_hash(void);
/* @internal */
export function Bolt12SemanticError_missing_payment_hash(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_missing_payment_hash();
	return nativeResponseValue;
}
	// enum LDKBolt12SemanticError Bolt12SemanticError_missing_signature(void);
/* @internal */
export function Bolt12SemanticError_missing_signature(): Bolt12SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt12SemanticError_missing_signature();
	return nativeResponseValue;
}
	// void Refund_free(struct LDKRefund this_obj);
/* @internal */
export function Refund_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Refund_free(this_obj);
	// debug statements here
}
	// uint64_t Refund_clone_ptr(LDKRefund *NONNULL_PTR arg);
/* @internal */
export function Refund_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Refund_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRefund Refund_clone(const struct LDKRefund *NONNULL_PTR orig);
/* @internal */
export function Refund_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Refund_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPrintableString Refund_description(const struct LDKRefund *NONNULL_PTR this_arg);
/* @internal */
export function Refund_description(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Refund_description(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_DurationZ Refund_absolute_expiry(const struct LDKRefund *NONNULL_PTR this_arg);
/* @internal */
export function Refund_absolute_expiry(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Refund_absolute_expiry(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPrintableString Refund_issuer(const struct LDKRefund *NONNULL_PTR this_arg);
/* @internal */
export function Refund_issuer(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Refund_issuer(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_BlindedPathZ Refund_paths(const struct LDKRefund *NONNULL_PTR this_arg);
/* @internal */
export function Refund_paths(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Refund_paths(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKu8slice Refund_metadata(const struct LDKRefund *NONNULL_PTR this_arg);
/* @internal */
export function Refund_metadata(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Refund_metadata(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes Refund_chain(const struct LDKRefund *NONNULL_PTR this_arg);
/* @internal */
export function Refund_chain(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Refund_chain(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Refund_amount_msats(const struct LDKRefund *NONNULL_PTR this_arg);
/* @internal */
export function Refund_amount_msats(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Refund_amount_msats(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInvoiceRequestFeatures Refund_features(const struct LDKRefund *NONNULL_PTR this_arg);
/* @internal */
export function Refund_features(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Refund_features(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_u64Z Refund_quantity(const struct LDKRefund *NONNULL_PTR this_arg);
/* @internal */
export function Refund_quantity(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Refund_quantity(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPublicKey Refund_payer_id(const struct LDKRefund *NONNULL_PTR this_arg);
/* @internal */
export function Refund_payer_id(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Refund_payer_id(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPrintableString Refund_payer_note(const struct LDKRefund *NONNULL_PTR this_arg);
/* @internal */
export function Refund_payer_note(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Refund_payer_note(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Refund_write(const struct LDKRefund *NONNULL_PTR obj);
/* @internal */
export function Refund_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Refund_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_RefundBolt12ParseErrorZ Refund_from_str(struct LDKStr s);
/* @internal */
export function Refund_from_str(s: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Refund_from_str(s);
	return nativeResponseValue;
}
	// enum LDKUtxoLookupError UtxoLookupError_clone(const enum LDKUtxoLookupError *NONNULL_PTR orig);
/* @internal */
export function UtxoLookupError_clone(orig: bigint): UtxoLookupError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UtxoLookupError_clone(orig);
	return nativeResponseValue;
}
	// enum LDKUtxoLookupError UtxoLookupError_unknown_chain(void);
/* @internal */
export function UtxoLookupError_unknown_chain(): UtxoLookupError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UtxoLookupError_unknown_chain();
	return nativeResponseValue;
}
	// enum LDKUtxoLookupError UtxoLookupError_unknown_tx(void);
/* @internal */
export function UtxoLookupError_unknown_tx(): UtxoLookupError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UtxoLookupError_unknown_tx();
	return nativeResponseValue;
}
	// void UtxoResult_free(struct LDKUtxoResult this_ptr);
/* @internal */
export function UtxoResult_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UtxoResult_free(this_ptr);
	// debug statements here
}
	// uint64_t UtxoResult_clone_ptr(LDKUtxoResult *NONNULL_PTR arg);
/* @internal */
export function UtxoResult_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UtxoResult_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUtxoResult UtxoResult_clone(const struct LDKUtxoResult *NONNULL_PTR orig);
/* @internal */
export function UtxoResult_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UtxoResult_clone(orig);
	return nativeResponseValue;
}
	// struct LDKUtxoResult UtxoResult_sync(struct LDKCResult_TxOutUtxoLookupErrorZ a);
/* @internal */
export function UtxoResult_sync(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UtxoResult_sync(a);
	return nativeResponseValue;
}
	// struct LDKUtxoResult UtxoResult_async(struct LDKUtxoFuture a);
/* @internal */
export function UtxoResult_async(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UtxoResult_async(a);
	return nativeResponseValue;
}
	// void UtxoLookup_free(struct LDKUtxoLookup this_ptr);
/* @internal */
export function UtxoLookup_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UtxoLookup_free(this_ptr);
	// debug statements here
}
	// void UtxoFuture_free(struct LDKUtxoFuture this_obj);
/* @internal */
export function UtxoFuture_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UtxoFuture_free(this_obj);
	// debug statements here
}
	// uint64_t UtxoFuture_clone_ptr(LDKUtxoFuture *NONNULL_PTR arg);
/* @internal */
export function UtxoFuture_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UtxoFuture_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUtxoFuture UtxoFuture_clone(const struct LDKUtxoFuture *NONNULL_PTR orig);
/* @internal */
export function UtxoFuture_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UtxoFuture_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKUtxoFuture UtxoFuture_new(void);
/* @internal */
export function UtxoFuture_new(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UtxoFuture_new();
	return nativeResponseValue;
}
	// void UtxoFuture_resolve_without_forwarding(const struct LDKUtxoFuture *NONNULL_PTR this_arg, const struct LDKNetworkGraph *NONNULL_PTR graph, struct LDKCResult_TxOutUtxoLookupErrorZ result);
/* @internal */
export function UtxoFuture_resolve_without_forwarding(this_arg: bigint, graph: bigint, result: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UtxoFuture_resolve_without_forwarding(this_arg, graph, result);
	// debug statements here
}
	// void UtxoFuture_resolve(const struct LDKUtxoFuture *NONNULL_PTR this_arg, const struct LDKNetworkGraph *NONNULL_PTR graph, const struct LDKP2PGossipSync *NONNULL_PTR gossip, struct LDKCResult_TxOutUtxoLookupErrorZ result);
/* @internal */
export function UtxoFuture_resolve(this_arg: bigint, graph: bigint, gossip: bigint, result: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UtxoFuture_resolve(this_arg, graph, gossip, result);
	// debug statements here
}
	// void NodeId_free(struct LDKNodeId this_obj);
/* @internal */
export function NodeId_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeId_free(this_obj);
	// debug statements here
}
	// uint64_t NodeId_clone_ptr(LDKNodeId *NONNULL_PTR arg);
/* @internal */
export function NodeId_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeId_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKNodeId NodeId_clone(const struct LDKNodeId *NONNULL_PTR orig);
/* @internal */
export function NodeId_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeId_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKNodeId NodeId_from_pubkey(struct LDKPublicKey pubkey);
/* @internal */
export function NodeId_from_pubkey(pubkey: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeId_from_pubkey(pubkey);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKu8slice NodeId_as_slice(const struct LDKNodeId *NONNULL_PTR this_arg);
/* @internal */
export function NodeId_as_slice(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeId_as_slice(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PublicKeyErrorZ NodeId_as_pubkey(const struct LDKNodeId *NONNULL_PTR this_arg);
/* @internal */
export function NodeId_as_pubkey(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeId_as_pubkey(this_arg);
	return nativeResponseValue;
}
	// uint64_t NodeId_hash(const struct LDKNodeId *NONNULL_PTR o);
/* @internal */
export function NodeId_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeId_hash(o);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z NodeId_write(const struct LDKNodeId *NONNULL_PTR obj);
/* @internal */
export function NodeId_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeId_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeIdDecodeErrorZ NodeId_read(struct LDKu8slice ser);
/* @internal */
export function NodeId_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeId_read(ser);
	return nativeResponseValue;
}
	// void NetworkGraph_free(struct LDKNetworkGraph this_obj);
/* @internal */
export function NetworkGraph_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_free(this_obj);
	// debug statements here
}
	// void ReadOnlyNetworkGraph_free(struct LDKReadOnlyNetworkGraph this_obj);
/* @internal */
export function ReadOnlyNetworkGraph_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReadOnlyNetworkGraph_free(this_obj);
	// debug statements here
}
	// void NetworkUpdate_free(struct LDKNetworkUpdate this_ptr);
/* @internal */
export function NetworkUpdate_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkUpdate_free(this_ptr);
	// debug statements here
}
	// uint64_t NetworkUpdate_clone_ptr(LDKNetworkUpdate *NONNULL_PTR arg);
/* @internal */
export function NetworkUpdate_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkUpdate_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKNetworkUpdate NetworkUpdate_clone(const struct LDKNetworkUpdate *NONNULL_PTR orig);
/* @internal */
export function NetworkUpdate_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkUpdate_clone(orig);
	return nativeResponseValue;
}
	// struct LDKNetworkUpdate NetworkUpdate_channel_update_message(struct LDKChannelUpdate msg);
/* @internal */
export function NetworkUpdate_channel_update_message(msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkUpdate_channel_update_message(msg);
	return nativeResponseValue;
}
	// struct LDKNetworkUpdate NetworkUpdate_channel_failure(uint64_t short_channel_id, bool is_permanent);
/* @internal */
export function NetworkUpdate_channel_failure(short_channel_id: bigint, is_permanent: boolean): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkUpdate_channel_failure(short_channel_id, is_permanent);
	return nativeResponseValue;
}
	// struct LDKNetworkUpdate NetworkUpdate_node_failure(struct LDKPublicKey node_id, bool is_permanent);
/* @internal */
export function NetworkUpdate_node_failure(node_id: number, is_permanent: boolean): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkUpdate_node_failure(node_id, is_permanent);
	return nativeResponseValue;
}
	// bool NetworkUpdate_eq(const struct LDKNetworkUpdate *NONNULL_PTR a, const struct LDKNetworkUpdate *NONNULL_PTR b);
/* @internal */
export function NetworkUpdate_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkUpdate_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z NetworkUpdate_write(const struct LDKNetworkUpdate *NONNULL_PTR obj);
/* @internal */
export function NetworkUpdate_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkUpdate_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ NetworkUpdate_read(struct LDKu8slice ser);
/* @internal */
export function NetworkUpdate_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkUpdate_read(ser);
	return nativeResponseValue;
}
	// void P2PGossipSync_free(struct LDKP2PGossipSync this_obj);
/* @internal */
export function P2PGossipSync_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_P2PGossipSync_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKP2PGossipSync P2PGossipSync_new(const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKCOption_UtxoLookupZ utxo_lookup, struct LDKLogger logger);
/* @internal */
export function P2PGossipSync_new(network_graph: bigint, utxo_lookup: bigint, logger: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_P2PGossipSync_new(network_graph, utxo_lookup, logger);
	return nativeResponseValue;
}
	// void P2PGossipSync_add_utxo_lookup(struct LDKP2PGossipSync *NONNULL_PTR this_arg, struct LDKCOption_UtxoLookupZ utxo_lookup);
/* @internal */
export function P2PGossipSync_add_utxo_lookup(this_arg: bigint, utxo_lookup: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_P2PGossipSync_add_utxo_lookup(this_arg, utxo_lookup);
	// debug statements here
}
	// void NetworkGraph_handle_network_update(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKNetworkUpdate *NONNULL_PTR network_update);
/* @internal */
export function NetworkGraph_handle_network_update(this_arg: bigint, network_update: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_handle_network_update(this_arg, network_update);
	// debug statements here
}
	// MUST_USE_RES struct LDKThirtyTwoBytes NetworkGraph_get_genesis_hash(const struct LDKNetworkGraph *NONNULL_PTR this_arg);
/* @internal */
export function NetworkGraph_get_genesis_hash(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_get_genesis_hash(this_arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneLightningErrorZ verify_node_announcement(const struct LDKNodeAnnouncement *NONNULL_PTR msg);
/* @internal */
export function verify_node_announcement(msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_verify_node_announcement(msg);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneLightningErrorZ verify_channel_announcement(const struct LDKChannelAnnouncement *NONNULL_PTR msg);
/* @internal */
export function verify_channel_announcement(msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_verify_channel_announcement(msg);
	return nativeResponseValue;
}
	// struct LDKRoutingMessageHandler P2PGossipSync_as_RoutingMessageHandler(const struct LDKP2PGossipSync *NONNULL_PTR this_arg);
/* @internal */
export function P2PGossipSync_as_RoutingMessageHandler(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_P2PGossipSync_as_RoutingMessageHandler(this_arg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEventsProvider P2PGossipSync_as_MessageSendEventsProvider(const struct LDKP2PGossipSync *NONNULL_PTR this_arg);
/* @internal */
export function P2PGossipSync_as_MessageSendEventsProvider(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_P2PGossipSync_as_MessageSendEventsProvider(this_arg);
	return nativeResponseValue;
}
	// void ChannelUpdateInfo_free(struct LDKChannelUpdateInfo this_obj);
/* @internal */
export function ChannelUpdateInfo_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_free(this_obj);
	// debug statements here
}
	// uint32_t ChannelUpdateInfo_get_last_update(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdateInfo_get_last_update(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_get_last_update(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdateInfo_set_last_update(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function ChannelUpdateInfo_set_last_update(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_set_last_update(this_ptr, val);
	// debug statements here
}
	// bool ChannelUpdateInfo_get_enabled(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdateInfo_get_enabled(this_ptr: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_get_enabled(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdateInfo_set_enabled(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelUpdateInfo_set_enabled(this_ptr: bigint, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_set_enabled(this_ptr, val);
	// debug statements here
}
	// uint16_t ChannelUpdateInfo_get_cltv_expiry_delta(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdateInfo_get_cltv_expiry_delta(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_get_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdateInfo_set_cltv_expiry_delta(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function ChannelUpdateInfo_set_cltv_expiry_delta(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_set_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelUpdateInfo_get_htlc_minimum_msat(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdateInfo_get_htlc_minimum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_get_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdateInfo_set_htlc_minimum_msat(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelUpdateInfo_set_htlc_minimum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_set_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelUpdateInfo_get_htlc_maximum_msat(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdateInfo_get_htlc_maximum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_get_htlc_maximum_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdateInfo_set_htlc_maximum_msat(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelUpdateInfo_set_htlc_maximum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_set_htlc_maximum_msat(this_ptr, val);
	// debug statements here
}
	// struct LDKRoutingFees ChannelUpdateInfo_get_fees(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdateInfo_get_fees(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_get_fees(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdateInfo_set_fees(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, struct LDKRoutingFees val);
/* @internal */
export function ChannelUpdateInfo_set_fees(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_set_fees(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelUpdate ChannelUpdateInfo_get_last_update_message(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdateInfo_get_last_update_message(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_get_last_update_message(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdateInfo_set_last_update_message(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdate val);
/* @internal */
export function ChannelUpdateInfo_set_last_update_message(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_set_last_update_message(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelUpdateInfo ChannelUpdateInfo_new(uint32_t last_update_arg, bool enabled_arg, uint16_t cltv_expiry_delta_arg, uint64_t htlc_minimum_msat_arg, uint64_t htlc_maximum_msat_arg, struct LDKRoutingFees fees_arg, struct LDKChannelUpdate last_update_message_arg);
/* @internal */
export function ChannelUpdateInfo_new(last_update_arg: number, enabled_arg: boolean, cltv_expiry_delta_arg: number, htlc_minimum_msat_arg: bigint, htlc_maximum_msat_arg: bigint, fees_arg: bigint, last_update_message_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_new(last_update_arg, enabled_arg, cltv_expiry_delta_arg, htlc_minimum_msat_arg, htlc_maximum_msat_arg, fees_arg, last_update_message_arg);
	return nativeResponseValue;
}
	// uint64_t ChannelUpdateInfo_clone_ptr(LDKChannelUpdateInfo *NONNULL_PTR arg);
/* @internal */
export function ChannelUpdateInfo_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelUpdateInfo ChannelUpdateInfo_clone(const struct LDKChannelUpdateInfo *NONNULL_PTR orig);
/* @internal */
export function ChannelUpdateInfo_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_clone(orig);
	return nativeResponseValue;
}
	// bool ChannelUpdateInfo_eq(const struct LDKChannelUpdateInfo *NONNULL_PTR a, const struct LDKChannelUpdateInfo *NONNULL_PTR b);
/* @internal */
export function ChannelUpdateInfo_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelUpdateInfo_write(const struct LDKChannelUpdateInfo *NONNULL_PTR obj);
/* @internal */
export function ChannelUpdateInfo_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelUpdateInfoDecodeErrorZ ChannelUpdateInfo_read(struct LDKu8slice ser);
/* @internal */
export function ChannelUpdateInfo_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_read(ser);
	return nativeResponseValue;
}
	// void ChannelInfo_free(struct LDKChannelInfo this_obj);
/* @internal */
export function ChannelInfo_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_free(this_obj);
	// debug statements here
}
	// struct LDKChannelFeatures ChannelInfo_get_features(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelInfo_get_features(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_get_features(this_ptr);
	return nativeResponseValue;
}
	// void ChannelInfo_set_features(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);
/* @internal */
export function ChannelInfo_set_features(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_set_features(this_ptr, val);
	// debug statements here
}
	// struct LDKNodeId ChannelInfo_get_node_one(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelInfo_get_node_one(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_get_node_one(this_ptr);
	return nativeResponseValue;
}
	// void ChannelInfo_set_node_one(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKNodeId val);
/* @internal */
export function ChannelInfo_set_node_one(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_set_node_one(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelUpdateInfo ChannelInfo_get_one_to_two(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelInfo_get_one_to_two(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_get_one_to_two(this_ptr);
	return nativeResponseValue;
}
	// void ChannelInfo_set_one_to_two(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdateInfo val);
/* @internal */
export function ChannelInfo_set_one_to_two(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_set_one_to_two(this_ptr, val);
	// debug statements here
}
	// struct LDKNodeId ChannelInfo_get_node_two(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelInfo_get_node_two(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_get_node_two(this_ptr);
	return nativeResponseValue;
}
	// void ChannelInfo_set_node_two(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKNodeId val);
/* @internal */
export function ChannelInfo_set_node_two(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_set_node_two(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelUpdateInfo ChannelInfo_get_two_to_one(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelInfo_get_two_to_one(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_get_two_to_one(this_ptr);
	return nativeResponseValue;
}
	// void ChannelInfo_set_two_to_one(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdateInfo val);
/* @internal */
export function ChannelInfo_set_two_to_one(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_set_two_to_one(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z ChannelInfo_get_capacity_sats(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelInfo_get_capacity_sats(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_get_capacity_sats(this_ptr);
	return nativeResponseValue;
}
	// void ChannelInfo_set_capacity_sats(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function ChannelInfo_set_capacity_sats(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_set_capacity_sats(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelAnnouncement ChannelInfo_get_announcement_message(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelInfo_get_announcement_message(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_get_announcement_message(this_ptr);
	return nativeResponseValue;
}
	// void ChannelInfo_set_announcement_message(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelAnnouncement val);
/* @internal */
export function ChannelInfo_set_announcement_message(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_set_announcement_message(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelInfo_clone_ptr(LDKChannelInfo *NONNULL_PTR arg);
/* @internal */
export function ChannelInfo_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelInfo ChannelInfo_clone(const struct LDKChannelInfo *NONNULL_PTR orig);
/* @internal */
export function ChannelInfo_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_clone(orig);
	return nativeResponseValue;
}
	// bool ChannelInfo_eq(const struct LDKChannelInfo *NONNULL_PTR a, const struct LDKChannelInfo *NONNULL_PTR b);
/* @internal */
export function ChannelInfo_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelUpdateInfo ChannelInfo_get_directional_info(const struct LDKChannelInfo *NONNULL_PTR this_arg, uint8_t channel_flags);
/* @internal */
export function ChannelInfo_get_directional_info(this_arg: bigint, channel_flags: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_get_directional_info(this_arg, channel_flags);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelInfo_write(const struct LDKChannelInfo *NONNULL_PTR obj);
/* @internal */
export function ChannelInfo_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelInfoDecodeErrorZ ChannelInfo_read(struct LDKu8slice ser);
/* @internal */
export function ChannelInfo_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_read(ser);
	return nativeResponseValue;
}
	// void DirectedChannelInfo_free(struct LDKDirectedChannelInfo this_obj);
/* @internal */
export function DirectedChannelInfo_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelInfo_free(this_obj);
	// debug statements here
}
	// uint64_t DirectedChannelInfo_clone_ptr(LDKDirectedChannelInfo *NONNULL_PTR arg);
/* @internal */
export function DirectedChannelInfo_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelInfo_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKDirectedChannelInfo DirectedChannelInfo_clone(const struct LDKDirectedChannelInfo *NONNULL_PTR orig);
/* @internal */
export function DirectedChannelInfo_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelInfo_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelInfo DirectedChannelInfo_channel(const struct LDKDirectedChannelInfo *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelInfo_channel(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelInfo_channel(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t DirectedChannelInfo_htlc_maximum_msat(const struct LDKDirectedChannelInfo *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelInfo_htlc_maximum_msat(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelInfo_htlc_maximum_msat(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKEffectiveCapacity DirectedChannelInfo_effective_capacity(const struct LDKDirectedChannelInfo *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelInfo_effective_capacity(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelInfo_effective_capacity(this_arg);
	return nativeResponseValue;
}
	// void EffectiveCapacity_free(struct LDKEffectiveCapacity this_ptr);
/* @internal */
export function EffectiveCapacity_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_free(this_ptr);
	// debug statements here
}
	// uint64_t EffectiveCapacity_clone_ptr(LDKEffectiveCapacity *NONNULL_PTR arg);
/* @internal */
export function EffectiveCapacity_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKEffectiveCapacity EffectiveCapacity_clone(const struct LDKEffectiveCapacity *NONNULL_PTR orig);
/* @internal */
export function EffectiveCapacity_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_clone(orig);
	return nativeResponseValue;
}
	// struct LDKEffectiveCapacity EffectiveCapacity_exact_liquidity(uint64_t liquidity_msat);
/* @internal */
export function EffectiveCapacity_exact_liquidity(liquidity_msat: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_exact_liquidity(liquidity_msat);
	return nativeResponseValue;
}
	// struct LDKEffectiveCapacity EffectiveCapacity_advertised_max_htlc(uint64_t amount_msat);
/* @internal */
export function EffectiveCapacity_advertised_max_htlc(amount_msat: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_advertised_max_htlc(amount_msat);
	return nativeResponseValue;
}
	// struct LDKEffectiveCapacity EffectiveCapacity_total(uint64_t capacity_msat, uint64_t htlc_maximum_msat);
/* @internal */
export function EffectiveCapacity_total(capacity_msat: bigint, htlc_maximum_msat: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_total(capacity_msat, htlc_maximum_msat);
	return nativeResponseValue;
}
	// struct LDKEffectiveCapacity EffectiveCapacity_infinite(void);
/* @internal */
export function EffectiveCapacity_infinite(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_infinite();
	return nativeResponseValue;
}
	// struct LDKEffectiveCapacity EffectiveCapacity_hint_max_htlc(uint64_t amount_msat);
/* @internal */
export function EffectiveCapacity_hint_max_htlc(amount_msat: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_hint_max_htlc(amount_msat);
	return nativeResponseValue;
}
	// struct LDKEffectiveCapacity EffectiveCapacity_unknown(void);
/* @internal */
export function EffectiveCapacity_unknown(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_unknown();
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t EffectiveCapacity_as_msat(const struct LDKEffectiveCapacity *NONNULL_PTR this_arg);
/* @internal */
export function EffectiveCapacity_as_msat(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_as_msat(this_arg);
	return nativeResponseValue;
}
	// void RoutingFees_free(struct LDKRoutingFees this_obj);
/* @internal */
export function RoutingFees_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_free(this_obj);
	// debug statements here
}
	// uint32_t RoutingFees_get_base_msat(const struct LDKRoutingFees *NONNULL_PTR this_ptr);
/* @internal */
export function RoutingFees_get_base_msat(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_get_base_msat(this_ptr);
	return nativeResponseValue;
}
	// void RoutingFees_set_base_msat(struct LDKRoutingFees *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function RoutingFees_set_base_msat(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_set_base_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t RoutingFees_get_proportional_millionths(const struct LDKRoutingFees *NONNULL_PTR this_ptr);
/* @internal */
export function RoutingFees_get_proportional_millionths(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_get_proportional_millionths(this_ptr);
	return nativeResponseValue;
}
	// void RoutingFees_set_proportional_millionths(struct LDKRoutingFees *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function RoutingFees_set_proportional_millionths(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_set_proportional_millionths(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKRoutingFees RoutingFees_new(uint32_t base_msat_arg, uint32_t proportional_millionths_arg);
/* @internal */
export function RoutingFees_new(base_msat_arg: number, proportional_millionths_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_new(base_msat_arg, proportional_millionths_arg);
	return nativeResponseValue;
}
	// bool RoutingFees_eq(const struct LDKRoutingFees *NONNULL_PTR a, const struct LDKRoutingFees *NONNULL_PTR b);
/* @internal */
export function RoutingFees_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_eq(a, b);
	return nativeResponseValue;
}
	// uint64_t RoutingFees_clone_ptr(LDKRoutingFees *NONNULL_PTR arg);
/* @internal */
export function RoutingFees_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRoutingFees RoutingFees_clone(const struct LDKRoutingFees *NONNULL_PTR orig);
/* @internal */
export function RoutingFees_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_clone(orig);
	return nativeResponseValue;
}
	// uint64_t RoutingFees_hash(const struct LDKRoutingFees *NONNULL_PTR o);
/* @internal */
export function RoutingFees_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_hash(o);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z RoutingFees_write(const struct LDKRoutingFees *NONNULL_PTR obj);
/* @internal */
export function RoutingFees_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_RoutingFeesDecodeErrorZ RoutingFees_read(struct LDKu8slice ser);
/* @internal */
export function RoutingFees_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_read(ser);
	return nativeResponseValue;
}
	// void NodeAnnouncementInfo_free(struct LDKNodeAnnouncementInfo this_obj);
/* @internal */
export function NodeAnnouncementInfo_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_free(this_obj);
	// debug statements here
}
	// struct LDKNodeFeatures NodeAnnouncementInfo_get_features(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);
/* @internal */
export function NodeAnnouncementInfo_get_features(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_get_features(this_ptr);
	return nativeResponseValue;
}
	// void NodeAnnouncementInfo_set_features(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);
/* @internal */
export function NodeAnnouncementInfo_set_features(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_set_features(this_ptr, val);
	// debug statements here
}
	// uint32_t NodeAnnouncementInfo_get_last_update(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);
/* @internal */
export function NodeAnnouncementInfo_get_last_update(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_get_last_update(this_ptr);
	return nativeResponseValue;
}
	// void NodeAnnouncementInfo_set_last_update(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function NodeAnnouncementInfo_set_last_update(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_set_last_update(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*NodeAnnouncementInfo_get_rgb(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr))[3];
/* @internal */
export function NodeAnnouncementInfo_get_rgb(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_get_rgb(this_ptr);
	return nativeResponseValue;
}
	// void NodeAnnouncementInfo_set_rgb(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKThreeBytes val);
/* @internal */
export function NodeAnnouncementInfo_set_rgb(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_set_rgb(this_ptr, val);
	// debug statements here
}
	// struct LDKNodeAlias NodeAnnouncementInfo_get_alias(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);
/* @internal */
export function NodeAnnouncementInfo_get_alias(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_get_alias(this_ptr);
	return nativeResponseValue;
}
	// void NodeAnnouncementInfo_set_alias(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeAlias val);
/* @internal */
export function NodeAnnouncementInfo_set_alias(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_set_alias(this_ptr, val);
	// debug statements here
}
	// struct LDKNodeAnnouncement NodeAnnouncementInfo_get_announcement_message(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);
/* @internal */
export function NodeAnnouncementInfo_get_announcement_message(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_get_announcement_message(this_ptr);
	return nativeResponseValue;
}
	// void NodeAnnouncementInfo_set_announcement_message(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeAnnouncement val);
/* @internal */
export function NodeAnnouncementInfo_set_announcement_message(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_set_announcement_message(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKNodeAnnouncementInfo NodeAnnouncementInfo_new(struct LDKNodeFeatures features_arg, uint32_t last_update_arg, struct LDKThreeBytes rgb_arg, struct LDKNodeAlias alias_arg, struct LDKNodeAnnouncement announcement_message_arg);
/* @internal */
export function NodeAnnouncementInfo_new(features_arg: bigint, last_update_arg: number, rgb_arg: number, alias_arg: bigint, announcement_message_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_new(features_arg, last_update_arg, rgb_arg, alias_arg, announcement_message_arg);
	return nativeResponseValue;
}
	// uint64_t NodeAnnouncementInfo_clone_ptr(LDKNodeAnnouncementInfo *NONNULL_PTR arg);
/* @internal */
export function NodeAnnouncementInfo_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKNodeAnnouncementInfo NodeAnnouncementInfo_clone(const struct LDKNodeAnnouncementInfo *NONNULL_PTR orig);
/* @internal */
export function NodeAnnouncementInfo_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_clone(orig);
	return nativeResponseValue;
}
	// bool NodeAnnouncementInfo_eq(const struct LDKNodeAnnouncementInfo *NONNULL_PTR a, const struct LDKNodeAnnouncementInfo *NONNULL_PTR b);
/* @internal */
export function NodeAnnouncementInfo_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_NetAddressZ NodeAnnouncementInfo_addresses(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_arg);
/* @internal */
export function NodeAnnouncementInfo_addresses(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_addresses(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z NodeAnnouncementInfo_write(const struct LDKNodeAnnouncementInfo *NONNULL_PTR obj);
/* @internal */
export function NodeAnnouncementInfo_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ NodeAnnouncementInfo_read(struct LDKu8slice ser);
/* @internal */
export function NodeAnnouncementInfo_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_read(ser);
	return nativeResponseValue;
}
	// void NodeAlias_free(struct LDKNodeAlias this_obj);
/* @internal */
export function NodeAlias_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAlias_free(this_obj);
	// debug statements here
}
	// const uint8_t (*NodeAlias_get_a(const struct LDKNodeAlias *NONNULL_PTR this_ptr))[32];
/* @internal */
export function NodeAlias_get_a(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAlias_get_a(this_ptr);
	return nativeResponseValue;
}
	// void NodeAlias_set_a(struct LDKNodeAlias *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function NodeAlias_set_a(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAlias_set_a(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKNodeAlias NodeAlias_new(struct LDKThirtyTwoBytes a_arg);
/* @internal */
export function NodeAlias_new(a_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAlias_new(a_arg);
	return nativeResponseValue;
}
	// uint64_t NodeAlias_clone_ptr(LDKNodeAlias *NONNULL_PTR arg);
/* @internal */
export function NodeAlias_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAlias_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKNodeAlias NodeAlias_clone(const struct LDKNodeAlias *NONNULL_PTR orig);
/* @internal */
export function NodeAlias_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAlias_clone(orig);
	return nativeResponseValue;
}
	// bool NodeAlias_eq(const struct LDKNodeAlias *NONNULL_PTR a, const struct LDKNodeAlias *NONNULL_PTR b);
/* @internal */
export function NodeAlias_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAlias_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z NodeAlias_write(const struct LDKNodeAlias *NONNULL_PTR obj);
/* @internal */
export function NodeAlias_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAlias_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAliasDecodeErrorZ NodeAlias_read(struct LDKu8slice ser);
/* @internal */
export function NodeAlias_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAlias_read(ser);
	return nativeResponseValue;
}
	// void NodeInfo_free(struct LDKNodeInfo this_obj);
/* @internal */
export function NodeInfo_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_free(this_obj);
	// debug statements here
}
	// struct LDKCVec_u64Z NodeInfo_get_channels(const struct LDKNodeInfo *NONNULL_PTR this_ptr);
/* @internal */
export function NodeInfo_get_channels(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_get_channels(this_ptr);
	return nativeResponseValue;
}
	// void NodeInfo_set_channels(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);
/* @internal */
export function NodeInfo_set_channels(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_set_channels(this_ptr, val);
	// debug statements here
}
	// struct LDKNodeAnnouncementInfo NodeInfo_get_announcement_info(const struct LDKNodeInfo *NONNULL_PTR this_ptr);
/* @internal */
export function NodeInfo_get_announcement_info(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_get_announcement_info(this_ptr);
	return nativeResponseValue;
}
	// void NodeInfo_set_announcement_info(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKNodeAnnouncementInfo val);
/* @internal */
export function NodeInfo_set_announcement_info(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_set_announcement_info(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKNodeInfo NodeInfo_new(struct LDKCVec_u64Z channels_arg, struct LDKNodeAnnouncementInfo announcement_info_arg);
/* @internal */
export function NodeInfo_new(channels_arg: number, announcement_info_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_new(channels_arg, announcement_info_arg);
	return nativeResponseValue;
}
	// uint64_t NodeInfo_clone_ptr(LDKNodeInfo *NONNULL_PTR arg);
/* @internal */
export function NodeInfo_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKNodeInfo NodeInfo_clone(const struct LDKNodeInfo *NONNULL_PTR orig);
/* @internal */
export function NodeInfo_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_clone(orig);
	return nativeResponseValue;
}
	// bool NodeInfo_eq(const struct LDKNodeInfo *NONNULL_PTR a, const struct LDKNodeInfo *NONNULL_PTR b);
/* @internal */
export function NodeInfo_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z NodeInfo_write(const struct LDKNodeInfo *NONNULL_PTR obj);
/* @internal */
export function NodeInfo_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeInfoDecodeErrorZ NodeInfo_read(struct LDKu8slice ser);
/* @internal */
export function NodeInfo_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z NetworkGraph_write(const struct LDKNetworkGraph *NONNULL_PTR obj);
/* @internal */
export function NetworkGraph_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_NetworkGraphDecodeErrorZ NetworkGraph_read(struct LDKu8slice ser, struct LDKLogger arg);
/* @internal */
export function NetworkGraph_read(ser: number, arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_read(ser, arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKNetworkGraph NetworkGraph_new(enum LDKNetwork network, struct LDKLogger logger);
/* @internal */
export function NetworkGraph_new(network: Network, logger: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_new(network, logger);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKReadOnlyNetworkGraph NetworkGraph_read_only(const struct LDKNetworkGraph *NONNULL_PTR this_arg);
/* @internal */
export function NetworkGraph_read_only(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_read_only(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_u32Z NetworkGraph_get_last_rapid_gossip_sync_timestamp(const struct LDKNetworkGraph *NONNULL_PTR this_arg);
/* @internal */
export function NetworkGraph_get_last_rapid_gossip_sync_timestamp(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_get_last_rapid_gossip_sync_timestamp(this_arg);
	return nativeResponseValue;
}
	// void NetworkGraph_set_last_rapid_gossip_sync_timestamp(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint32_t last_rapid_gossip_sync_timestamp);
/* @internal */
export function NetworkGraph_set_last_rapid_gossip_sync_timestamp(this_arg: bigint, last_rapid_gossip_sync_timestamp: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_set_last_rapid_gossip_sync_timestamp(this_arg, last_rapid_gossip_sync_timestamp);
	// debug statements here
}
	// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_node_from_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKNodeAnnouncement *NONNULL_PTR msg);
/* @internal */
export function NetworkGraph_update_node_from_announcement(this_arg: bigint, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_update_node_from_announcement(this_arg, msg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_node_from_unsigned_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR msg);
/* @internal */
export function NetworkGraph_update_node_from_unsigned_announcement(this_arg: bigint, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_update_node_from_unsigned_announcement(this_arg, msg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg, struct LDKCOption_UtxoLookupZ utxo_lookup);
/* @internal */
export function NetworkGraph_update_channel_from_announcement(this_arg: bigint, msg: bigint, utxo_lookup: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_update_channel_from_announcement(this_arg, msg, utxo_lookup);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_announcement_no_lookup(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg);
/* @internal */
export function NetworkGraph_update_channel_from_announcement_no_lookup(this_arg: bigint, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_update_channel_from_announcement_no_lookup(this_arg, msg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_unsigned_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR msg, struct LDKCOption_UtxoLookupZ utxo_lookup);
/* @internal */
export function NetworkGraph_update_channel_from_unsigned_announcement(this_arg: bigint, msg: bigint, utxo_lookup: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_update_channel_from_unsigned_announcement(this_arg, msg, utxo_lookup);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_add_channel_from_partial_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint64_t short_channel_id, uint64_t timestamp, struct LDKChannelFeatures features, struct LDKPublicKey node_id_1, struct LDKPublicKey node_id_2);
/* @internal */
export function NetworkGraph_add_channel_from_partial_announcement(this_arg: bigint, short_channel_id: bigint, timestamp: bigint, features: bigint, node_id_1: number, node_id_2: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_add_channel_from_partial_announcement(this_arg, short_channel_id, timestamp, features, node_id_1, node_id_2);
	return nativeResponseValue;
}
	// void NetworkGraph_channel_failed_permanent(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint64_t short_channel_id);
/* @internal */
export function NetworkGraph_channel_failed_permanent(this_arg: bigint, short_channel_id: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_channel_failed_permanent(this_arg, short_channel_id);
	// debug statements here
}
	// void NetworkGraph_node_failed_permanent(const struct LDKNetworkGraph *NONNULL_PTR this_arg, struct LDKPublicKey node_id);
/* @internal */
export function NetworkGraph_node_failed_permanent(this_arg: bigint, node_id: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_node_failed_permanent(this_arg, node_id);
	// debug statements here
}
	// void NetworkGraph_remove_stale_channels_and_tracking_with_time(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint64_t current_time_unix);
/* @internal */
export function NetworkGraph_remove_stale_channels_and_tracking_with_time(this_arg: bigint, current_time_unix: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_remove_stale_channels_and_tracking_with_time(this_arg, current_time_unix);
	// debug statements here
}
	// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelUpdate *NONNULL_PTR msg);
/* @internal */
export function NetworkGraph_update_channel(this_arg: bigint, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_update_channel(this_arg, msg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_unsigned(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedChannelUpdate *NONNULL_PTR msg);
/* @internal */
export function NetworkGraph_update_channel_unsigned(this_arg: bigint, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_update_channel_unsigned(this_arg, msg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelInfo ReadOnlyNetworkGraph_channel(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg, uint64_t short_channel_id);
/* @internal */
export function ReadOnlyNetworkGraph_channel(this_arg: bigint, short_channel_id: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReadOnlyNetworkGraph_channel(this_arg, short_channel_id);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_u64Z ReadOnlyNetworkGraph_list_channels(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg);
/* @internal */
export function ReadOnlyNetworkGraph_list_channels(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReadOnlyNetworkGraph_list_channels(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKNodeInfo ReadOnlyNetworkGraph_node(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR node_id);
/* @internal */
export function ReadOnlyNetworkGraph_node(this_arg: bigint, node_id: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReadOnlyNetworkGraph_node(this_arg, node_id);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_NodeIdZ ReadOnlyNetworkGraph_list_nodes(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg);
/* @internal */
export function ReadOnlyNetworkGraph_list_nodes(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReadOnlyNetworkGraph_list_nodes(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_CVec_NetAddressZZ ReadOnlyNetworkGraph_get_addresses(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg, struct LDKPublicKey pubkey);
/* @internal */
export function ReadOnlyNetworkGraph_get_addresses(this_arg: bigint, pubkey: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReadOnlyNetworkGraph_get_addresses(this_arg, pubkey);
	return nativeResponseValue;
}
	// void DefaultRouter_free(struct LDKDefaultRouter this_obj);
/* @internal */
export function DefaultRouter_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DefaultRouter_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKDefaultRouter DefaultRouter_new(const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKLogger logger, struct LDKThirtyTwoBytes random_seed_bytes, struct LDKLockableScore scorer, struct LDKProbabilisticScoringFeeParameters score_params);
/* @internal */
export function DefaultRouter_new(network_graph: bigint, logger: bigint, random_seed_bytes: number, scorer: bigint, score_params: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DefaultRouter_new(network_graph, logger, random_seed_bytes, scorer, score_params);
	return nativeResponseValue;
}
	// struct LDKRouter DefaultRouter_as_Router(const struct LDKDefaultRouter *NONNULL_PTR this_arg);
/* @internal */
export function DefaultRouter_as_Router(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DefaultRouter_as_Router(this_arg);
	return nativeResponseValue;
}
	// void Router_free(struct LDKRouter this_ptr);
/* @internal */
export function Router_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Router_free(this_ptr);
	// debug statements here
}
	// void ScorerAccountingForInFlightHtlcs_free(struct LDKScorerAccountingForInFlightHtlcs this_obj);
/* @internal */
export function ScorerAccountingForInFlightHtlcs_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScorerAccountingForInFlightHtlcs_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKScorerAccountingForInFlightHtlcs ScorerAccountingForInFlightHtlcs_new(struct LDKScore scorer, const struct LDKInFlightHtlcs *NONNULL_PTR inflight_htlcs);
/* @internal */
export function ScorerAccountingForInFlightHtlcs_new(scorer: bigint, inflight_htlcs: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScorerAccountingForInFlightHtlcs_new(scorer, inflight_htlcs);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ScorerAccountingForInFlightHtlcs_write(const struct LDKScorerAccountingForInFlightHtlcs *NONNULL_PTR obj);
/* @internal */
export function ScorerAccountingForInFlightHtlcs_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScorerAccountingForInFlightHtlcs_write(obj);
	return nativeResponseValue;
}
	// struct LDKScore ScorerAccountingForInFlightHtlcs_as_Score(const struct LDKScorerAccountingForInFlightHtlcs *NONNULL_PTR this_arg);
/* @internal */
export function ScorerAccountingForInFlightHtlcs_as_Score(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScorerAccountingForInFlightHtlcs_as_Score(this_arg);
	return nativeResponseValue;
}
	// void InFlightHtlcs_free(struct LDKInFlightHtlcs this_obj);
/* @internal */
export function InFlightHtlcs_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InFlightHtlcs_free(this_obj);
	// debug statements here
}
	// uint64_t InFlightHtlcs_clone_ptr(LDKInFlightHtlcs *NONNULL_PTR arg);
/* @internal */
export function InFlightHtlcs_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InFlightHtlcs_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKInFlightHtlcs InFlightHtlcs_clone(const struct LDKInFlightHtlcs *NONNULL_PTR orig);
/* @internal */
export function InFlightHtlcs_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InFlightHtlcs_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInFlightHtlcs InFlightHtlcs_new(void);
/* @internal */
export function InFlightHtlcs_new(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InFlightHtlcs_new();
	return nativeResponseValue;
}
	// void InFlightHtlcs_process_path(struct LDKInFlightHtlcs *NONNULL_PTR this_arg, const struct LDKPath *NONNULL_PTR path, struct LDKPublicKey payer_node_id);
/* @internal */
export function InFlightHtlcs_process_path(this_arg: bigint, path: bigint, payer_node_id: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InFlightHtlcs_process_path(this_arg, path, payer_node_id);
	// debug statements here
}
	// void InFlightHtlcs_add_inflight_htlc(struct LDKInFlightHtlcs *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR source, const struct LDKNodeId *NONNULL_PTR target, uint64_t channel_scid, uint64_t used_msat);
/* @internal */
export function InFlightHtlcs_add_inflight_htlc(this_arg: bigint, source: bigint, target: bigint, channel_scid: bigint, used_msat: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InFlightHtlcs_add_inflight_htlc(this_arg, source, target, channel_scid, used_msat);
	// debug statements here
}
	// MUST_USE_RES struct LDKCOption_u64Z InFlightHtlcs_used_liquidity_msat(const struct LDKInFlightHtlcs *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR source, const struct LDKNodeId *NONNULL_PTR target, uint64_t channel_scid);
/* @internal */
export function InFlightHtlcs_used_liquidity_msat(this_arg: bigint, source: bigint, target: bigint, channel_scid: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InFlightHtlcs_used_liquidity_msat(this_arg, source, target, channel_scid);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z InFlightHtlcs_write(const struct LDKInFlightHtlcs *NONNULL_PTR obj);
/* @internal */
export function InFlightHtlcs_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InFlightHtlcs_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_InFlightHtlcsDecodeErrorZ InFlightHtlcs_read(struct LDKu8slice ser);
/* @internal */
export function InFlightHtlcs_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InFlightHtlcs_read(ser);
	return nativeResponseValue;
}
	// void RouteHop_free(struct LDKRouteHop this_obj);
/* @internal */
export function RouteHop_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_free(this_obj);
	// debug statements here
}
	// struct LDKPublicKey RouteHop_get_pubkey(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHop_get_pubkey(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_get_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void RouteHop_set_pubkey(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function RouteHop_set_pubkey(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_set_pubkey(this_ptr, val);
	// debug statements here
}
	// struct LDKNodeFeatures RouteHop_get_node_features(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHop_get_node_features(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_get_node_features(this_ptr);
	return nativeResponseValue;
}
	// void RouteHop_set_node_features(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);
/* @internal */
export function RouteHop_set_node_features(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_set_node_features(this_ptr, val);
	// debug statements here
}
	// uint64_t RouteHop_get_short_channel_id(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHop_get_short_channel_id(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_get_short_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void RouteHop_set_short_channel_id(struct LDKRouteHop *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function RouteHop_set_short_channel_id(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_set_short_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelFeatures RouteHop_get_channel_features(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHop_get_channel_features(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_get_channel_features(this_ptr);
	return nativeResponseValue;
}
	// void RouteHop_set_channel_features(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);
/* @internal */
export function RouteHop_set_channel_features(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_set_channel_features(this_ptr, val);
	// debug statements here
}
	// uint64_t RouteHop_get_fee_msat(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHop_get_fee_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_get_fee_msat(this_ptr);
	return nativeResponseValue;
}
	// void RouteHop_set_fee_msat(struct LDKRouteHop *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function RouteHop_set_fee_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_set_fee_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t RouteHop_get_cltv_expiry_delta(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHop_get_cltv_expiry_delta(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_get_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void RouteHop_set_cltv_expiry_delta(struct LDKRouteHop *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function RouteHop_set_cltv_expiry_delta(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_set_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKRouteHop RouteHop_new(struct LDKPublicKey pubkey_arg, struct LDKNodeFeatures node_features_arg, uint64_t short_channel_id_arg, struct LDKChannelFeatures channel_features_arg, uint64_t fee_msat_arg, uint32_t cltv_expiry_delta_arg);
/* @internal */
export function RouteHop_new(pubkey_arg: number, node_features_arg: bigint, short_channel_id_arg: bigint, channel_features_arg: bigint, fee_msat_arg: bigint, cltv_expiry_delta_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_new(pubkey_arg, node_features_arg, short_channel_id_arg, channel_features_arg, fee_msat_arg, cltv_expiry_delta_arg);
	return nativeResponseValue;
}
	// uint64_t RouteHop_clone_ptr(LDKRouteHop *NONNULL_PTR arg);
/* @internal */
export function RouteHop_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRouteHop RouteHop_clone(const struct LDKRouteHop *NONNULL_PTR orig);
/* @internal */
export function RouteHop_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_clone(orig);
	return nativeResponseValue;
}
	// uint64_t RouteHop_hash(const struct LDKRouteHop *NONNULL_PTR o);
/* @internal */
export function RouteHop_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_hash(o);
	return nativeResponseValue;
}
	// bool RouteHop_eq(const struct LDKRouteHop *NONNULL_PTR a, const struct LDKRouteHop *NONNULL_PTR b);
/* @internal */
export function RouteHop_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z RouteHop_write(const struct LDKRouteHop *NONNULL_PTR obj);
/* @internal */
export function RouteHop_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHopDecodeErrorZ RouteHop_read(struct LDKu8slice ser);
/* @internal */
export function RouteHop_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_read(ser);
	return nativeResponseValue;
}
	// void BlindedTail_free(struct LDKBlindedTail this_obj);
/* @internal */
export function BlindedTail_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedTail_free(this_obj);
	// debug statements here
}
	// struct LDKCVec_BlindedHopZ BlindedTail_get_hops(const struct LDKBlindedTail *NONNULL_PTR this_ptr);
/* @internal */
export function BlindedTail_get_hops(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedTail_get_hops(this_ptr);
	return nativeResponseValue;
}
	// void BlindedTail_set_hops(struct LDKBlindedTail *NONNULL_PTR this_ptr, struct LDKCVec_BlindedHopZ val);
/* @internal */
export function BlindedTail_set_hops(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedTail_set_hops(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey BlindedTail_get_blinding_point(const struct LDKBlindedTail *NONNULL_PTR this_ptr);
/* @internal */
export function BlindedTail_get_blinding_point(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedTail_get_blinding_point(this_ptr);
	return nativeResponseValue;
}
	// void BlindedTail_set_blinding_point(struct LDKBlindedTail *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function BlindedTail_set_blinding_point(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedTail_set_blinding_point(this_ptr, val);
	// debug statements here
}
	// uint32_t BlindedTail_get_excess_final_cltv_expiry_delta(const struct LDKBlindedTail *NONNULL_PTR this_ptr);
/* @internal */
export function BlindedTail_get_excess_final_cltv_expiry_delta(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedTail_get_excess_final_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void BlindedTail_set_excess_final_cltv_expiry_delta(struct LDKBlindedTail *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function BlindedTail_set_excess_final_cltv_expiry_delta(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedTail_set_excess_final_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// uint64_t BlindedTail_get_final_value_msat(const struct LDKBlindedTail *NONNULL_PTR this_ptr);
/* @internal */
export function BlindedTail_get_final_value_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedTail_get_final_value_msat(this_ptr);
	return nativeResponseValue;
}
	// void BlindedTail_set_final_value_msat(struct LDKBlindedTail *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function BlindedTail_set_final_value_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedTail_set_final_value_msat(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKBlindedTail BlindedTail_new(struct LDKCVec_BlindedHopZ hops_arg, struct LDKPublicKey blinding_point_arg, uint32_t excess_final_cltv_expiry_delta_arg, uint64_t final_value_msat_arg);
/* @internal */
export function BlindedTail_new(hops_arg: number, blinding_point_arg: number, excess_final_cltv_expiry_delta_arg: number, final_value_msat_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedTail_new(hops_arg, blinding_point_arg, excess_final_cltv_expiry_delta_arg, final_value_msat_arg);
	return nativeResponseValue;
}
	// uint64_t BlindedTail_clone_ptr(LDKBlindedTail *NONNULL_PTR arg);
/* @internal */
export function BlindedTail_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedTail_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBlindedTail BlindedTail_clone(const struct LDKBlindedTail *NONNULL_PTR orig);
/* @internal */
export function BlindedTail_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedTail_clone(orig);
	return nativeResponseValue;
}
	// uint64_t BlindedTail_hash(const struct LDKBlindedTail *NONNULL_PTR o);
/* @internal */
export function BlindedTail_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedTail_hash(o);
	return nativeResponseValue;
}
	// bool BlindedTail_eq(const struct LDKBlindedTail *NONNULL_PTR a, const struct LDKBlindedTail *NONNULL_PTR b);
/* @internal */
export function BlindedTail_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedTail_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z BlindedTail_write(const struct LDKBlindedTail *NONNULL_PTR obj);
/* @internal */
export function BlindedTail_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedTail_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedTailDecodeErrorZ BlindedTail_read(struct LDKu8slice ser);
/* @internal */
export function BlindedTail_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedTail_read(ser);
	return nativeResponseValue;
}
	// void Path_free(struct LDKPath this_obj);
/* @internal */
export function Path_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Path_free(this_obj);
	// debug statements here
}
	// struct LDKCVec_RouteHopZ Path_get_hops(const struct LDKPath *NONNULL_PTR this_ptr);
/* @internal */
export function Path_get_hops(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Path_get_hops(this_ptr);
	return nativeResponseValue;
}
	// void Path_set_hops(struct LDKPath *NONNULL_PTR this_ptr, struct LDKCVec_RouteHopZ val);
/* @internal */
export function Path_set_hops(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Path_set_hops(this_ptr, val);
	// debug statements here
}
	// struct LDKBlindedTail Path_get_blinded_tail(const struct LDKPath *NONNULL_PTR this_ptr);
/* @internal */
export function Path_get_blinded_tail(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Path_get_blinded_tail(this_ptr);
	return nativeResponseValue;
}
	// void Path_set_blinded_tail(struct LDKPath *NONNULL_PTR this_ptr, struct LDKBlindedTail val);
/* @internal */
export function Path_set_blinded_tail(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Path_set_blinded_tail(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKPath Path_new(struct LDKCVec_RouteHopZ hops_arg, struct LDKBlindedTail blinded_tail_arg);
/* @internal */
export function Path_new(hops_arg: number, blinded_tail_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Path_new(hops_arg, blinded_tail_arg);
	return nativeResponseValue;
}
	// uint64_t Path_clone_ptr(LDKPath *NONNULL_PTR arg);
/* @internal */
export function Path_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Path_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPath Path_clone(const struct LDKPath *NONNULL_PTR orig);
/* @internal */
export function Path_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Path_clone(orig);
	return nativeResponseValue;
}
	// uint64_t Path_hash(const struct LDKPath *NONNULL_PTR o);
/* @internal */
export function Path_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Path_hash(o);
	return nativeResponseValue;
}
	// bool Path_eq(const struct LDKPath *NONNULL_PTR a, const struct LDKPath *NONNULL_PTR b);
/* @internal */
export function Path_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Path_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Path_fee_msat(const struct LDKPath *NONNULL_PTR this_arg);
/* @internal */
export function Path_fee_msat(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Path_fee_msat(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Path_final_value_msat(const struct LDKPath *NONNULL_PTR this_arg);
/* @internal */
export function Path_final_value_msat(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Path_final_value_msat(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_u32Z Path_final_cltv_expiry_delta(const struct LDKPath *NONNULL_PTR this_arg);
/* @internal */
export function Path_final_cltv_expiry_delta(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Path_final_cltv_expiry_delta(this_arg);
	return nativeResponseValue;
}
	// void Route_free(struct LDKRoute this_obj);
/* @internal */
export function Route_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_free(this_obj);
	// debug statements here
}
	// struct LDKCVec_PathZ Route_get_paths(const struct LDKRoute *NONNULL_PTR this_ptr);
/* @internal */
export function Route_get_paths(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_get_paths(this_ptr);
	return nativeResponseValue;
}
	// void Route_set_paths(struct LDKRoute *NONNULL_PTR this_ptr, struct LDKCVec_PathZ val);
/* @internal */
export function Route_set_paths(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_set_paths(this_ptr, val);
	// debug statements here
}
	// struct LDKPaymentParameters Route_get_payment_params(const struct LDKRoute *NONNULL_PTR this_ptr);
/* @internal */
export function Route_get_payment_params(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_get_payment_params(this_ptr);
	return nativeResponseValue;
}
	// void Route_set_payment_params(struct LDKRoute *NONNULL_PTR this_ptr, struct LDKPaymentParameters val);
/* @internal */
export function Route_set_payment_params(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_set_payment_params(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKRoute Route_new(struct LDKCVec_PathZ paths_arg, struct LDKPaymentParameters payment_params_arg);
/* @internal */
export function Route_new(paths_arg: number, payment_params_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_new(paths_arg, payment_params_arg);
	return nativeResponseValue;
}
	// uint64_t Route_clone_ptr(LDKRoute *NONNULL_PTR arg);
/* @internal */
export function Route_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRoute Route_clone(const struct LDKRoute *NONNULL_PTR orig);
/* @internal */
export function Route_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_clone(orig);
	return nativeResponseValue;
}
	// uint64_t Route_hash(const struct LDKRoute *NONNULL_PTR o);
/* @internal */
export function Route_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_hash(o);
	return nativeResponseValue;
}
	// bool Route_eq(const struct LDKRoute *NONNULL_PTR a, const struct LDKRoute *NONNULL_PTR b);
/* @internal */
export function Route_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Route_get_total_fees(const struct LDKRoute *NONNULL_PTR this_arg);
/* @internal */
export function Route_get_total_fees(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_get_total_fees(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Route_get_total_amount(const struct LDKRoute *NONNULL_PTR this_arg);
/* @internal */
export function Route_get_total_amount(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_get_total_amount(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Route_write(const struct LDKRoute *NONNULL_PTR obj);
/* @internal */
export function Route_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteDecodeErrorZ Route_read(struct LDKu8slice ser);
/* @internal */
export function Route_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_read(ser);
	return nativeResponseValue;
}
	// void RouteParameters_free(struct LDKRouteParameters this_obj);
/* @internal */
export function RouteParameters_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_free(this_obj);
	// debug statements here
}
	// struct LDKPaymentParameters RouteParameters_get_payment_params(const struct LDKRouteParameters *NONNULL_PTR this_ptr);
/* @internal */
export function RouteParameters_get_payment_params(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_get_payment_params(this_ptr);
	return nativeResponseValue;
}
	// void RouteParameters_set_payment_params(struct LDKRouteParameters *NONNULL_PTR this_ptr, struct LDKPaymentParameters val);
/* @internal */
export function RouteParameters_set_payment_params(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_set_payment_params(this_ptr, val);
	// debug statements here
}
	// uint64_t RouteParameters_get_final_value_msat(const struct LDKRouteParameters *NONNULL_PTR this_ptr);
/* @internal */
export function RouteParameters_get_final_value_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_get_final_value_msat(this_ptr);
	return nativeResponseValue;
}
	// void RouteParameters_set_final_value_msat(struct LDKRouteParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function RouteParameters_set_final_value_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_set_final_value_msat(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKRouteParameters RouteParameters_new(struct LDKPaymentParameters payment_params_arg, uint64_t final_value_msat_arg);
/* @internal */
export function RouteParameters_new(payment_params_arg: bigint, final_value_msat_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_new(payment_params_arg, final_value_msat_arg);
	return nativeResponseValue;
}
	// uint64_t RouteParameters_clone_ptr(LDKRouteParameters *NONNULL_PTR arg);
/* @internal */
export function RouteParameters_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRouteParameters RouteParameters_clone(const struct LDKRouteParameters *NONNULL_PTR orig);
/* @internal */
export function RouteParameters_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_clone(orig);
	return nativeResponseValue;
}
	// bool RouteParameters_eq(const struct LDKRouteParameters *NONNULL_PTR a, const struct LDKRouteParameters *NONNULL_PTR b);
/* @internal */
export function RouteParameters_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z RouteParameters_write(const struct LDKRouteParameters *NONNULL_PTR obj);
/* @internal */
export function RouteParameters_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteParametersDecodeErrorZ RouteParameters_read(struct LDKu8slice ser);
/* @internal */
export function RouteParameters_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_read(ser);
	return nativeResponseValue;
}
	// void PaymentParameters_free(struct LDKPaymentParameters this_obj);
/* @internal */
export function PaymentParameters_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_free(this_obj);
	// debug statements here
}
	// struct LDKPayee PaymentParameters_get_payee(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);
/* @internal */
export function PaymentParameters_get_payee(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_get_payee(this_ptr);
	return nativeResponseValue;
}
	// void PaymentParameters_set_payee(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKPayee val);
/* @internal */
export function PaymentParameters_set_payee(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_set_payee(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z PaymentParameters_get_expiry_time(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);
/* @internal */
export function PaymentParameters_get_expiry_time(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_get_expiry_time(this_ptr);
	return nativeResponseValue;
}
	// void PaymentParameters_set_expiry_time(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function PaymentParameters_set_expiry_time(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_set_expiry_time(this_ptr, val);
	// debug statements here
}
	// uint32_t PaymentParameters_get_max_total_cltv_expiry_delta(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);
/* @internal */
export function PaymentParameters_get_max_total_cltv_expiry_delta(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_get_max_total_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void PaymentParameters_set_max_total_cltv_expiry_delta(struct LDKPaymentParameters *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function PaymentParameters_set_max_total_cltv_expiry_delta(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_set_max_total_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// uint8_t PaymentParameters_get_max_path_count(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);
/* @internal */
export function PaymentParameters_get_max_path_count(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_get_max_path_count(this_ptr);
	return nativeResponseValue;
}
	// void PaymentParameters_set_max_path_count(struct LDKPaymentParameters *NONNULL_PTR this_ptr, uint8_t val);
/* @internal */
export function PaymentParameters_set_max_path_count(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_set_max_path_count(this_ptr, val);
	// debug statements here
}
	// uint8_t PaymentParameters_get_max_channel_saturation_power_of_half(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);
/* @internal */
export function PaymentParameters_get_max_channel_saturation_power_of_half(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_get_max_channel_saturation_power_of_half(this_ptr);
	return nativeResponseValue;
}
	// void PaymentParameters_set_max_channel_saturation_power_of_half(struct LDKPaymentParameters *NONNULL_PTR this_ptr, uint8_t val);
/* @internal */
export function PaymentParameters_set_max_channel_saturation_power_of_half(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_set_max_channel_saturation_power_of_half(this_ptr, val);
	// debug statements here
}
	// struct LDKCVec_u64Z PaymentParameters_get_previously_failed_channels(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);
/* @internal */
export function PaymentParameters_get_previously_failed_channels(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_get_previously_failed_channels(this_ptr);
	return nativeResponseValue;
}
	// void PaymentParameters_set_previously_failed_channels(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);
/* @internal */
export function PaymentParameters_set_previously_failed_channels(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_set_previously_failed_channels(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKPaymentParameters PaymentParameters_new(struct LDKPayee payee_arg, struct LDKCOption_u64Z expiry_time_arg, uint32_t max_total_cltv_expiry_delta_arg, uint8_t max_path_count_arg, uint8_t max_channel_saturation_power_of_half_arg, struct LDKCVec_u64Z previously_failed_channels_arg);
/* @internal */
export function PaymentParameters_new(payee_arg: bigint, expiry_time_arg: bigint, max_total_cltv_expiry_delta_arg: number, max_path_count_arg: number, max_channel_saturation_power_of_half_arg: number, previously_failed_channels_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_new(payee_arg, expiry_time_arg, max_total_cltv_expiry_delta_arg, max_path_count_arg, max_channel_saturation_power_of_half_arg, previously_failed_channels_arg);
	return nativeResponseValue;
}
	// uint64_t PaymentParameters_clone_ptr(LDKPaymentParameters *NONNULL_PTR arg);
/* @internal */
export function PaymentParameters_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPaymentParameters PaymentParameters_clone(const struct LDKPaymentParameters *NONNULL_PTR orig);
/* @internal */
export function PaymentParameters_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_clone(orig);
	return nativeResponseValue;
}
	// uint64_t PaymentParameters_hash(const struct LDKPaymentParameters *NONNULL_PTR o);
/* @internal */
export function PaymentParameters_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_hash(o);
	return nativeResponseValue;
}
	// bool PaymentParameters_eq(const struct LDKPaymentParameters *NONNULL_PTR a, const struct LDKPaymentParameters *NONNULL_PTR b);
/* @internal */
export function PaymentParameters_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z PaymentParameters_write(const struct LDKPaymentParameters *NONNULL_PTR obj);
/* @internal */
export function PaymentParameters_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentParametersDecodeErrorZ PaymentParameters_read(struct LDKu8slice ser, uint32_t arg);
/* @internal */
export function PaymentParameters_read(ser: number, arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_read(ser, arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPaymentParameters PaymentParameters_from_node_id(struct LDKPublicKey payee_pubkey, uint32_t final_cltv_expiry_delta);
/* @internal */
export function PaymentParameters_from_node_id(payee_pubkey: number, final_cltv_expiry_delta: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_from_node_id(payee_pubkey, final_cltv_expiry_delta);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPaymentParameters PaymentParameters_for_keysend(struct LDKPublicKey payee_pubkey, uint32_t final_cltv_expiry_delta, bool allow_mpp);
/* @internal */
export function PaymentParameters_for_keysend(payee_pubkey: number, final_cltv_expiry_delta: number, allow_mpp: boolean): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_for_keysend(payee_pubkey, final_cltv_expiry_delta, allow_mpp);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPaymentParameters PaymentParameters_from_bolt12_invoice(const struct LDKBolt12Invoice *NONNULL_PTR invoice);
/* @internal */
export function PaymentParameters_from_bolt12_invoice(invoice: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_from_bolt12_invoice(invoice);
	return nativeResponseValue;
}
	// void Payee_free(struct LDKPayee this_ptr);
/* @internal */
export function Payee_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Payee_free(this_ptr);
	// debug statements here
}
	// uint64_t Payee_clone_ptr(LDKPayee *NONNULL_PTR arg);
/* @internal */
export function Payee_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Payee_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPayee Payee_clone(const struct LDKPayee *NONNULL_PTR orig);
/* @internal */
export function Payee_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Payee_clone(orig);
	return nativeResponseValue;
}
	// struct LDKPayee Payee_blinded(struct LDKCVec_C2Tuple_BlindedPayInfoBlindedPathZZ route_hints, struct LDKBolt12InvoiceFeatures features);
/* @internal */
export function Payee_blinded(route_hints: number, features: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Payee_blinded(route_hints, features);
	return nativeResponseValue;
}
	// struct LDKPayee Payee_clear(struct LDKPublicKey node_id, struct LDKCVec_RouteHintZ route_hints, struct LDKBolt11InvoiceFeatures features, uint32_t final_cltv_expiry_delta);
/* @internal */
export function Payee_clear(node_id: number, route_hints: number, features: bigint, final_cltv_expiry_delta: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Payee_clear(node_id, route_hints, features, final_cltv_expiry_delta);
	return nativeResponseValue;
}
	// uint64_t Payee_hash(const struct LDKPayee *NONNULL_PTR o);
/* @internal */
export function Payee_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Payee_hash(o);
	return nativeResponseValue;
}
	// bool Payee_eq(const struct LDKPayee *NONNULL_PTR a, const struct LDKPayee *NONNULL_PTR b);
/* @internal */
export function Payee_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Payee_eq(a, b);
	return nativeResponseValue;
}
	// void RouteHint_free(struct LDKRouteHint this_obj);
/* @internal */
export function RouteHint_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_free(this_obj);
	// debug statements here
}
	// struct LDKCVec_RouteHintHopZ RouteHint_get_a(const struct LDKRouteHint *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHint_get_a(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_get_a(this_ptr);
	return nativeResponseValue;
}
	// void RouteHint_set_a(struct LDKRouteHint *NONNULL_PTR this_ptr, struct LDKCVec_RouteHintHopZ val);
/* @internal */
export function RouteHint_set_a(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_set_a(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKRouteHint RouteHint_new(struct LDKCVec_RouteHintHopZ a_arg);
/* @internal */
export function RouteHint_new(a_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_new(a_arg);
	return nativeResponseValue;
}
	// uint64_t RouteHint_clone_ptr(LDKRouteHint *NONNULL_PTR arg);
/* @internal */
export function RouteHint_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRouteHint RouteHint_clone(const struct LDKRouteHint *NONNULL_PTR orig);
/* @internal */
export function RouteHint_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_clone(orig);
	return nativeResponseValue;
}
	// uint64_t RouteHint_hash(const struct LDKRouteHint *NONNULL_PTR o);
/* @internal */
export function RouteHint_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_hash(o);
	return nativeResponseValue;
}
	// bool RouteHint_eq(const struct LDKRouteHint *NONNULL_PTR a, const struct LDKRouteHint *NONNULL_PTR b);
/* @internal */
export function RouteHint_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z RouteHint_write(const struct LDKRouteHint *NONNULL_PTR obj);
/* @internal */
export function RouteHint_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHintDecodeErrorZ RouteHint_read(struct LDKu8slice ser);
/* @internal */
export function RouteHint_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_read(ser);
	return nativeResponseValue;
}
	// void RouteHintHop_free(struct LDKRouteHintHop this_obj);
/* @internal */
export function RouteHintHop_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_free(this_obj);
	// debug statements here
}
	// struct LDKPublicKey RouteHintHop_get_src_node_id(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHintHop_get_src_node_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_get_src_node_id(this_ptr);
	return nativeResponseValue;
}
	// void RouteHintHop_set_src_node_id(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function RouteHintHop_set_src_node_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_set_src_node_id(this_ptr, val);
	// debug statements here
}
	// uint64_t RouteHintHop_get_short_channel_id(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHintHop_get_short_channel_id(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_get_short_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void RouteHintHop_set_short_channel_id(struct LDKRouteHintHop *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function RouteHintHop_set_short_channel_id(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_set_short_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKRoutingFees RouteHintHop_get_fees(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHintHop_get_fees(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_get_fees(this_ptr);
	return nativeResponseValue;
}
	// void RouteHintHop_set_fees(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKRoutingFees val);
/* @internal */
export function RouteHintHop_set_fees(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_set_fees(this_ptr, val);
	// debug statements here
}
	// uint16_t RouteHintHop_get_cltv_expiry_delta(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHintHop_get_cltv_expiry_delta(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_get_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void RouteHintHop_set_cltv_expiry_delta(struct LDKRouteHintHop *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function RouteHintHop_set_cltv_expiry_delta(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_set_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z RouteHintHop_get_htlc_minimum_msat(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHintHop_get_htlc_minimum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_get_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void RouteHintHop_set_htlc_minimum_msat(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function RouteHintHop_set_htlc_minimum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_set_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z RouteHintHop_get_htlc_maximum_msat(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHintHop_get_htlc_maximum_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_get_htlc_maximum_msat(this_ptr);
	return nativeResponseValue;
}
	// void RouteHintHop_set_htlc_maximum_msat(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function RouteHintHop_set_htlc_maximum_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_set_htlc_maximum_msat(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKRouteHintHop RouteHintHop_new(struct LDKPublicKey src_node_id_arg, uint64_t short_channel_id_arg, struct LDKRoutingFees fees_arg, uint16_t cltv_expiry_delta_arg, struct LDKCOption_u64Z htlc_minimum_msat_arg, struct LDKCOption_u64Z htlc_maximum_msat_arg);
/* @internal */
export function RouteHintHop_new(src_node_id_arg: number, short_channel_id_arg: bigint, fees_arg: bigint, cltv_expiry_delta_arg: number, htlc_minimum_msat_arg: bigint, htlc_maximum_msat_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_new(src_node_id_arg, short_channel_id_arg, fees_arg, cltv_expiry_delta_arg, htlc_minimum_msat_arg, htlc_maximum_msat_arg);
	return nativeResponseValue;
}
	// uint64_t RouteHintHop_clone_ptr(LDKRouteHintHop *NONNULL_PTR arg);
/* @internal */
export function RouteHintHop_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRouteHintHop RouteHintHop_clone(const struct LDKRouteHintHop *NONNULL_PTR orig);
/* @internal */
export function RouteHintHop_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_clone(orig);
	return nativeResponseValue;
}
	// uint64_t RouteHintHop_hash(const struct LDKRouteHintHop *NONNULL_PTR o);
/* @internal */
export function RouteHintHop_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_hash(o);
	return nativeResponseValue;
}
	// bool RouteHintHop_eq(const struct LDKRouteHintHop *NONNULL_PTR a, const struct LDKRouteHintHop *NONNULL_PTR b);
/* @internal */
export function RouteHintHop_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z RouteHintHop_write(const struct LDKRouteHintHop *NONNULL_PTR obj);
/* @internal */
export function RouteHintHop_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHintHopDecodeErrorZ RouteHintHop_read(struct LDKu8slice ser);
/* @internal */
export function RouteHintHop_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_read(ser);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteLightningErrorZ find_route(struct LDKPublicKey our_node_pubkey, const struct LDKRouteParameters *NONNULL_PTR route_params, const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKCVec_ChannelDetailsZ *first_hops, struct LDKLogger logger, const struct LDKScore *NONNULL_PTR scorer, const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR score_params, const uint8_t (*random_seed_bytes)[32]);
/* @internal */
export function find_route(our_node_pubkey: number, route_params: bigint, network_graph: bigint, first_hops: number, logger: bigint, scorer: bigint, score_params: bigint, random_seed_bytes: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_find_route(our_node_pubkey, route_params, network_graph, first_hops, logger, scorer, score_params, random_seed_bytes);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteLightningErrorZ build_route_from_hops(struct LDKPublicKey our_node_pubkey, struct LDKCVec_PublicKeyZ hops, const struct LDKRouteParameters *NONNULL_PTR route_params, const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKLogger logger, const uint8_t (*random_seed_bytes)[32]);
/* @internal */
export function build_route_from_hops(our_node_pubkey: number, hops: number, route_params: bigint, network_graph: bigint, logger: bigint, random_seed_bytes: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_build_route_from_hops(our_node_pubkey, hops, route_params, network_graph, logger, random_seed_bytes);
	return nativeResponseValue;
}
	// void Score_free(struct LDKScore this_ptr);
/* @internal */
export function Score_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Score_free(this_ptr);
	// debug statements here
}
	// void LockableScore_free(struct LDKLockableScore this_ptr);
/* @internal */
export function LockableScore_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LockableScore_free(this_ptr);
	// debug statements here
}
	// void WriteableScore_free(struct LDKWriteableScore this_ptr);
/* @internal */
export function WriteableScore_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WriteableScore_free(this_ptr);
	// debug statements here
}
	// void MultiThreadedLockableScore_free(struct LDKMultiThreadedLockableScore this_obj);
/* @internal */
export function MultiThreadedLockableScore_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MultiThreadedLockableScore_free(this_obj);
	// debug statements here
}
	// struct LDKLockableScore MultiThreadedLockableScore_as_LockableScore(const struct LDKMultiThreadedLockableScore *NONNULL_PTR this_arg);
/* @internal */
export function MultiThreadedLockableScore_as_LockableScore(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MultiThreadedLockableScore_as_LockableScore(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z MultiThreadedLockableScore_write(const struct LDKMultiThreadedLockableScore *NONNULL_PTR obj);
/* @internal */
export function MultiThreadedLockableScore_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MultiThreadedLockableScore_write(obj);
	return nativeResponseValue;
}
	// struct LDKWriteableScore MultiThreadedLockableScore_as_WriteableScore(const struct LDKMultiThreadedLockableScore *NONNULL_PTR this_arg);
/* @internal */
export function MultiThreadedLockableScore_as_WriteableScore(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MultiThreadedLockableScore_as_WriteableScore(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKMultiThreadedLockableScore MultiThreadedLockableScore_new(struct LDKScore score);
/* @internal */
export function MultiThreadedLockableScore_new(score: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MultiThreadedLockableScore_new(score);
	return nativeResponseValue;
}
	// void MultiThreadedScoreLock_free(struct LDKMultiThreadedScoreLock this_obj);
/* @internal */
export function MultiThreadedScoreLock_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MultiThreadedScoreLock_free(this_obj);
	// debug statements here
}
	// struct LDKCVec_u8Z MultiThreadedScoreLock_write(const struct LDKMultiThreadedScoreLock *NONNULL_PTR obj);
/* @internal */
export function MultiThreadedScoreLock_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MultiThreadedScoreLock_write(obj);
	return nativeResponseValue;
}
	// struct LDKScore MultiThreadedScoreLock_as_Score(const struct LDKMultiThreadedScoreLock *NONNULL_PTR this_arg);
/* @internal */
export function MultiThreadedScoreLock_as_Score(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MultiThreadedScoreLock_as_Score(this_arg);
	return nativeResponseValue;
}
	// void ChannelUsage_free(struct LDKChannelUsage this_obj);
/* @internal */
export function ChannelUsage_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUsage_free(this_obj);
	// debug statements here
}
	// uint64_t ChannelUsage_get_amount_msat(const struct LDKChannelUsage *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUsage_get_amount_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUsage_get_amount_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUsage_set_amount_msat(struct LDKChannelUsage *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelUsage_set_amount_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUsage_set_amount_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelUsage_get_inflight_htlc_msat(const struct LDKChannelUsage *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUsage_get_inflight_htlc_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUsage_get_inflight_htlc_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUsage_set_inflight_htlc_msat(struct LDKChannelUsage *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelUsage_set_inflight_htlc_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUsage_set_inflight_htlc_msat(this_ptr, val);
	// debug statements here
}
	// struct LDKEffectiveCapacity ChannelUsage_get_effective_capacity(const struct LDKChannelUsage *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUsage_get_effective_capacity(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUsage_get_effective_capacity(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUsage_set_effective_capacity(struct LDKChannelUsage *NONNULL_PTR this_ptr, struct LDKEffectiveCapacity val);
/* @internal */
export function ChannelUsage_set_effective_capacity(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUsage_set_effective_capacity(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelUsage ChannelUsage_new(uint64_t amount_msat_arg, uint64_t inflight_htlc_msat_arg, struct LDKEffectiveCapacity effective_capacity_arg);
/* @internal */
export function ChannelUsage_new(amount_msat_arg: bigint, inflight_htlc_msat_arg: bigint, effective_capacity_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUsage_new(amount_msat_arg, inflight_htlc_msat_arg, effective_capacity_arg);
	return nativeResponseValue;
}
	// uint64_t ChannelUsage_clone_ptr(LDKChannelUsage *NONNULL_PTR arg);
/* @internal */
export function ChannelUsage_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUsage_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelUsage ChannelUsage_clone(const struct LDKChannelUsage *NONNULL_PTR orig);
/* @internal */
export function ChannelUsage_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUsage_clone(orig);
	return nativeResponseValue;
}
	// void FixedPenaltyScorer_free(struct LDKFixedPenaltyScorer this_obj);
/* @internal */
export function FixedPenaltyScorer_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FixedPenaltyScorer_free(this_obj);
	// debug statements here
}
	// uint64_t FixedPenaltyScorer_clone_ptr(LDKFixedPenaltyScorer *NONNULL_PTR arg);
/* @internal */
export function FixedPenaltyScorer_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FixedPenaltyScorer_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKFixedPenaltyScorer FixedPenaltyScorer_clone(const struct LDKFixedPenaltyScorer *NONNULL_PTR orig);
/* @internal */
export function FixedPenaltyScorer_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FixedPenaltyScorer_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKFixedPenaltyScorer FixedPenaltyScorer_with_penalty(uint64_t penalty_msat);
/* @internal */
export function FixedPenaltyScorer_with_penalty(penalty_msat: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FixedPenaltyScorer_with_penalty(penalty_msat);
	return nativeResponseValue;
}
	// struct LDKScore FixedPenaltyScorer_as_Score(const struct LDKFixedPenaltyScorer *NONNULL_PTR this_arg);
/* @internal */
export function FixedPenaltyScorer_as_Score(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FixedPenaltyScorer_as_Score(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z FixedPenaltyScorer_write(const struct LDKFixedPenaltyScorer *NONNULL_PTR obj);
/* @internal */
export function FixedPenaltyScorer_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FixedPenaltyScorer_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_FixedPenaltyScorerDecodeErrorZ FixedPenaltyScorer_read(struct LDKu8slice ser, uint64_t arg);
/* @internal */
export function FixedPenaltyScorer_read(ser: number, arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FixedPenaltyScorer_read(ser, arg);
	return nativeResponseValue;
}
	// void ProbabilisticScorer_free(struct LDKProbabilisticScorer this_obj);
/* @internal */
export function ProbabilisticScorer_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScorer_free(this_obj);
	// debug statements here
}
	// void ProbabilisticScoringFeeParameters_free(struct LDKProbabilisticScoringFeeParameters this_obj);
/* @internal */
export function ProbabilisticScoringFeeParameters_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_free(this_obj);
	// debug statements here
}
	// uint64_t ProbabilisticScoringFeeParameters_get_base_penalty_msat(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ProbabilisticScoringFeeParameters_get_base_penalty_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_get_base_penalty_msat(this_ptr);
	return nativeResponseValue;
}
	// void ProbabilisticScoringFeeParameters_set_base_penalty_msat(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ProbabilisticScoringFeeParameters_set_base_penalty_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_set_base_penalty_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ProbabilisticScoringFeeParameters_get_base_penalty_amount_multiplier_msat(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ProbabilisticScoringFeeParameters_get_base_penalty_amount_multiplier_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_get_base_penalty_amount_multiplier_msat(this_ptr);
	return nativeResponseValue;
}
	// void ProbabilisticScoringFeeParameters_set_base_penalty_amount_multiplier_msat(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ProbabilisticScoringFeeParameters_set_base_penalty_amount_multiplier_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_set_base_penalty_amount_multiplier_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ProbabilisticScoringFeeParameters_get_liquidity_penalty_multiplier_msat(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ProbabilisticScoringFeeParameters_get_liquidity_penalty_multiplier_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_get_liquidity_penalty_multiplier_msat(this_ptr);
	return nativeResponseValue;
}
	// void ProbabilisticScoringFeeParameters_set_liquidity_penalty_multiplier_msat(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ProbabilisticScoringFeeParameters_set_liquidity_penalty_multiplier_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_set_liquidity_penalty_multiplier_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ProbabilisticScoringFeeParameters_get_liquidity_penalty_amount_multiplier_msat(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ProbabilisticScoringFeeParameters_get_liquidity_penalty_amount_multiplier_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_get_liquidity_penalty_amount_multiplier_msat(this_ptr);
	return nativeResponseValue;
}
	// void ProbabilisticScoringFeeParameters_set_liquidity_penalty_amount_multiplier_msat(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ProbabilisticScoringFeeParameters_set_liquidity_penalty_amount_multiplier_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_set_liquidity_penalty_amount_multiplier_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ProbabilisticScoringFeeParameters_get_historical_liquidity_penalty_multiplier_msat(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ProbabilisticScoringFeeParameters_get_historical_liquidity_penalty_multiplier_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_get_historical_liquidity_penalty_multiplier_msat(this_ptr);
	return nativeResponseValue;
}
	// void ProbabilisticScoringFeeParameters_set_historical_liquidity_penalty_multiplier_msat(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ProbabilisticScoringFeeParameters_set_historical_liquidity_penalty_multiplier_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_set_historical_liquidity_penalty_multiplier_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ProbabilisticScoringFeeParameters_get_historical_liquidity_penalty_amount_multiplier_msat(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ProbabilisticScoringFeeParameters_get_historical_liquidity_penalty_amount_multiplier_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_get_historical_liquidity_penalty_amount_multiplier_msat(this_ptr);
	return nativeResponseValue;
}
	// void ProbabilisticScoringFeeParameters_set_historical_liquidity_penalty_amount_multiplier_msat(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ProbabilisticScoringFeeParameters_set_historical_liquidity_penalty_amount_multiplier_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_set_historical_liquidity_penalty_amount_multiplier_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ProbabilisticScoringFeeParameters_get_anti_probing_penalty_msat(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ProbabilisticScoringFeeParameters_get_anti_probing_penalty_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_get_anti_probing_penalty_msat(this_ptr);
	return nativeResponseValue;
}
	// void ProbabilisticScoringFeeParameters_set_anti_probing_penalty_msat(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ProbabilisticScoringFeeParameters_set_anti_probing_penalty_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_set_anti_probing_penalty_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ProbabilisticScoringFeeParameters_get_considered_impossible_penalty_msat(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ProbabilisticScoringFeeParameters_get_considered_impossible_penalty_msat(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_get_considered_impossible_penalty_msat(this_ptr);
	return nativeResponseValue;
}
	// void ProbabilisticScoringFeeParameters_set_considered_impossible_penalty_msat(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ProbabilisticScoringFeeParameters_set_considered_impossible_penalty_msat(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_set_considered_impossible_penalty_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ProbabilisticScoringFeeParameters_clone_ptr(LDKProbabilisticScoringFeeParameters *NONNULL_PTR arg);
/* @internal */
export function ProbabilisticScoringFeeParameters_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKProbabilisticScoringFeeParameters ProbabilisticScoringFeeParameters_clone(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR orig);
/* @internal */
export function ProbabilisticScoringFeeParameters_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKProbabilisticScoringFeeParameters ProbabilisticScoringFeeParameters_default(void);
/* @internal */
export function ProbabilisticScoringFeeParameters_default(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_default();
	return nativeResponseValue;
}
	// void ProbabilisticScoringFeeParameters_add_banned(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR node_id);
/* @internal */
export function ProbabilisticScoringFeeParameters_add_banned(this_arg: bigint, node_id: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_add_banned(this_arg, node_id);
	// debug statements here
}
	// void ProbabilisticScoringFeeParameters_add_banned_from_list(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_arg, struct LDKCVec_NodeIdZ node_ids);
/* @internal */
export function ProbabilisticScoringFeeParameters_add_banned_from_list(this_arg: bigint, node_ids: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_add_banned_from_list(this_arg, node_ids);
	// debug statements here
}
	// void ProbabilisticScoringFeeParameters_remove_banned(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR node_id);
/* @internal */
export function ProbabilisticScoringFeeParameters_remove_banned(this_arg: bigint, node_id: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_remove_banned(this_arg, node_id);
	// debug statements here
}
	// void ProbabilisticScoringFeeParameters_set_manual_penalty(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR node_id, uint64_t penalty);
/* @internal */
export function ProbabilisticScoringFeeParameters_set_manual_penalty(this_arg: bigint, node_id: bigint, penalty: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_set_manual_penalty(this_arg, node_id, penalty);
	// debug statements here
}
	// void ProbabilisticScoringFeeParameters_remove_manual_penalty(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR node_id);
/* @internal */
export function ProbabilisticScoringFeeParameters_remove_manual_penalty(this_arg: bigint, node_id: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_remove_manual_penalty(this_arg, node_id);
	// debug statements here
}
	// void ProbabilisticScoringFeeParameters_clear_manual_penalties(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_arg);
/* @internal */
export function ProbabilisticScoringFeeParameters_clear_manual_penalties(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringFeeParameters_clear_manual_penalties(this_arg);
	// debug statements here
}
	// void ProbabilisticScoringDecayParameters_free(struct LDKProbabilisticScoringDecayParameters this_obj);
/* @internal */
export function ProbabilisticScoringDecayParameters_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringDecayParameters_free(this_obj);
	// debug statements here
}
	// uint64_t ProbabilisticScoringDecayParameters_get_historical_no_updates_half_life(const struct LDKProbabilisticScoringDecayParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ProbabilisticScoringDecayParameters_get_historical_no_updates_half_life(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringDecayParameters_get_historical_no_updates_half_life(this_ptr);
	return nativeResponseValue;
}
	// void ProbabilisticScoringDecayParameters_set_historical_no_updates_half_life(struct LDKProbabilisticScoringDecayParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ProbabilisticScoringDecayParameters_set_historical_no_updates_half_life(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringDecayParameters_set_historical_no_updates_half_life(this_ptr, val);
	// debug statements here
}
	// uint64_t ProbabilisticScoringDecayParameters_get_liquidity_offset_half_life(const struct LDKProbabilisticScoringDecayParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ProbabilisticScoringDecayParameters_get_liquidity_offset_half_life(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringDecayParameters_get_liquidity_offset_half_life(this_ptr);
	return nativeResponseValue;
}
	// void ProbabilisticScoringDecayParameters_set_liquidity_offset_half_life(struct LDKProbabilisticScoringDecayParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ProbabilisticScoringDecayParameters_set_liquidity_offset_half_life(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringDecayParameters_set_liquidity_offset_half_life(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKProbabilisticScoringDecayParameters ProbabilisticScoringDecayParameters_new(uint64_t historical_no_updates_half_life_arg, uint64_t liquidity_offset_half_life_arg);
/* @internal */
export function ProbabilisticScoringDecayParameters_new(historical_no_updates_half_life_arg: bigint, liquidity_offset_half_life_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringDecayParameters_new(historical_no_updates_half_life_arg, liquidity_offset_half_life_arg);
	return nativeResponseValue;
}
	// uint64_t ProbabilisticScoringDecayParameters_clone_ptr(LDKProbabilisticScoringDecayParameters *NONNULL_PTR arg);
/* @internal */
export function ProbabilisticScoringDecayParameters_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringDecayParameters_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKProbabilisticScoringDecayParameters ProbabilisticScoringDecayParameters_clone(const struct LDKProbabilisticScoringDecayParameters *NONNULL_PTR orig);
/* @internal */
export function ProbabilisticScoringDecayParameters_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringDecayParameters_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKProbabilisticScoringDecayParameters ProbabilisticScoringDecayParameters_default(void);
/* @internal */
export function ProbabilisticScoringDecayParameters_default(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringDecayParameters_default();
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKProbabilisticScorer ProbabilisticScorer_new(struct LDKProbabilisticScoringDecayParameters decay_params, const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKLogger logger);
/* @internal */
export function ProbabilisticScorer_new(decay_params: bigint, network_graph: bigint, logger: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScorer_new(decay_params, network_graph, logger);
	return nativeResponseValue;
}
	// void ProbabilisticScorer_debug_log_liquidity_stats(const struct LDKProbabilisticScorer *NONNULL_PTR this_arg);
/* @internal */
export function ProbabilisticScorer_debug_log_liquidity_stats(this_arg: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScorer_debug_log_liquidity_stats(this_arg);
	// debug statements here
}
	// MUST_USE_RES struct LDKCOption_C2Tuple_u64u64ZZ ProbabilisticScorer_estimated_channel_liquidity_range(const struct LDKProbabilisticScorer *NONNULL_PTR this_arg, uint64_t scid, const struct LDKNodeId *NONNULL_PTR target);
/* @internal */
export function ProbabilisticScorer_estimated_channel_liquidity_range(this_arg: bigint, scid: bigint, target: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScorer_estimated_channel_liquidity_range(this_arg, scid, target);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_C2Tuple_EightU16sEightU16sZZ ProbabilisticScorer_historical_estimated_channel_liquidity_probabilities(const struct LDKProbabilisticScorer *NONNULL_PTR this_arg, uint64_t scid, const struct LDKNodeId *NONNULL_PTR target);
/* @internal */
export function ProbabilisticScorer_historical_estimated_channel_liquidity_probabilities(this_arg: bigint, scid: bigint, target: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScorer_historical_estimated_channel_liquidity_probabilities(this_arg, scid, target);
	return nativeResponseValue;
}
	// struct LDKScore ProbabilisticScorer_as_Score(const struct LDKProbabilisticScorer *NONNULL_PTR this_arg);
/* @internal */
export function ProbabilisticScorer_as_Score(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScorer_as_Score(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ProbabilisticScorer_write(const struct LDKProbabilisticScorer *NONNULL_PTR obj);
/* @internal */
export function ProbabilisticScorer_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScorer_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ProbabilisticScorerDecodeErrorZ ProbabilisticScorer_read(struct LDKu8slice ser, struct LDKProbabilisticScoringDecayParameters arg_a, const struct LDKNetworkGraph *NONNULL_PTR arg_b, struct LDKLogger arg_c);
/* @internal */
export function ProbabilisticScorer_read(ser: number, arg_a: bigint, arg_b: bigint, arg_c: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScorer_read(ser, arg_a, arg_b, arg_c);
	return nativeResponseValue;
}
	// void DelayedPaymentOutputDescriptor_free(struct LDKDelayedPaymentOutputDescriptor this_obj);
/* @internal */
export function DelayedPaymentOutputDescriptor_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_free(this_obj);
	// debug statements here
}
	// struct LDKOutPoint DelayedPaymentOutputDescriptor_get_outpoint(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function DelayedPaymentOutputDescriptor_get_outpoint(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_outpoint(this_ptr);
	return nativeResponseValue;
}
	// void DelayedPaymentOutputDescriptor_set_outpoint(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */
export function DelayedPaymentOutputDescriptor_set_outpoint(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_outpoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey DelayedPaymentOutputDescriptor_get_per_commitment_point(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function DelayedPaymentOutputDescriptor_get_per_commitment_point(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void DelayedPaymentOutputDescriptor_set_per_commitment_point(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function DelayedPaymentOutputDescriptor_set_per_commitment_point(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// uint16_t DelayedPaymentOutputDescriptor_get_to_self_delay(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function DelayedPaymentOutputDescriptor_get_to_self_delay(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_to_self_delay(this_ptr);
	return nativeResponseValue;
}
	// void DelayedPaymentOutputDescriptor_set_to_self_delay(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function DelayedPaymentOutputDescriptor_set_to_self_delay(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_to_self_delay(this_ptr, val);
	// debug statements here
}
	// struct LDKTxOut DelayedPaymentOutputDescriptor_get_output(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function DelayedPaymentOutputDescriptor_get_output(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_output(this_ptr);
	return nativeResponseValue;
}
	// void DelayedPaymentOutputDescriptor_set_output(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKTxOut val);
/* @internal */
export function DelayedPaymentOutputDescriptor_set_output(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_output(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey DelayedPaymentOutputDescriptor_get_revocation_pubkey(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function DelayedPaymentOutputDescriptor_get_revocation_pubkey(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_revocation_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void DelayedPaymentOutputDescriptor_set_revocation_pubkey(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function DelayedPaymentOutputDescriptor_set_revocation_pubkey(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_revocation_pubkey(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*DelayedPaymentOutputDescriptor_get_channel_keys_id(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr))[32];
/* @internal */
export function DelayedPaymentOutputDescriptor_get_channel_keys_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_channel_keys_id(this_ptr);
	return nativeResponseValue;
}
	// void DelayedPaymentOutputDescriptor_set_channel_keys_id(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function DelayedPaymentOutputDescriptor_set_channel_keys_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_channel_keys_id(this_ptr, val);
	// debug statements here
}
	// uint64_t DelayedPaymentOutputDescriptor_get_channel_value_satoshis(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function DelayedPaymentOutputDescriptor_get_channel_value_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_channel_value_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void DelayedPaymentOutputDescriptor_set_channel_value_satoshis(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function DelayedPaymentOutputDescriptor_set_channel_value_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_channel_value_satoshis(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_new(struct LDKOutPoint outpoint_arg, struct LDKPublicKey per_commitment_point_arg, uint16_t to_self_delay_arg, struct LDKTxOut output_arg, struct LDKPublicKey revocation_pubkey_arg, struct LDKThirtyTwoBytes channel_keys_id_arg, uint64_t channel_value_satoshis_arg);
/* @internal */
export function DelayedPaymentOutputDescriptor_new(outpoint_arg: bigint, per_commitment_point_arg: number, to_self_delay_arg: number, output_arg: bigint, revocation_pubkey_arg: number, channel_keys_id_arg: number, channel_value_satoshis_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_new(outpoint_arg, per_commitment_point_arg, to_self_delay_arg, output_arg, revocation_pubkey_arg, channel_keys_id_arg, channel_value_satoshis_arg);
	return nativeResponseValue;
}
	// uint64_t DelayedPaymentOutputDescriptor_clone_ptr(LDKDelayedPaymentOutputDescriptor *NONNULL_PTR arg);
/* @internal */
export function DelayedPaymentOutputDescriptor_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_clone(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR orig);
/* @internal */
export function DelayedPaymentOutputDescriptor_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_clone(orig);
	return nativeResponseValue;
}
	// bool DelayedPaymentOutputDescriptor_eq(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR a, const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR b);
/* @internal */
export function DelayedPaymentOutputDescriptor_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z DelayedPaymentOutputDescriptor_write(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR obj);
/* @internal */
export function DelayedPaymentOutputDescriptor_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ DelayedPaymentOutputDescriptor_read(struct LDKu8slice ser);
/* @internal */
export function DelayedPaymentOutputDescriptor_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_read(ser);
	return nativeResponseValue;
}
	// void StaticPaymentOutputDescriptor_free(struct LDKStaticPaymentOutputDescriptor this_obj);
/* @internal */
export function StaticPaymentOutputDescriptor_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_free(this_obj);
	// debug statements here
}
	// struct LDKOutPoint StaticPaymentOutputDescriptor_get_outpoint(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function StaticPaymentOutputDescriptor_get_outpoint(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_get_outpoint(this_ptr);
	return nativeResponseValue;
}
	// void StaticPaymentOutputDescriptor_set_outpoint(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */
export function StaticPaymentOutputDescriptor_set_outpoint(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_set_outpoint(this_ptr, val);
	// debug statements here
}
	// struct LDKTxOut StaticPaymentOutputDescriptor_get_output(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function StaticPaymentOutputDescriptor_get_output(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_get_output(this_ptr);
	return nativeResponseValue;
}
	// void StaticPaymentOutputDescriptor_set_output(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKTxOut val);
/* @internal */
export function StaticPaymentOutputDescriptor_set_output(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_set_output(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*StaticPaymentOutputDescriptor_get_channel_keys_id(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr))[32];
/* @internal */
export function StaticPaymentOutputDescriptor_get_channel_keys_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_get_channel_keys_id(this_ptr);
	return nativeResponseValue;
}
	// void StaticPaymentOutputDescriptor_set_channel_keys_id(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function StaticPaymentOutputDescriptor_set_channel_keys_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_set_channel_keys_id(this_ptr, val);
	// debug statements here
}
	// uint64_t StaticPaymentOutputDescriptor_get_channel_value_satoshis(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function StaticPaymentOutputDescriptor_get_channel_value_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_get_channel_value_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void StaticPaymentOutputDescriptor_set_channel_value_satoshis(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function StaticPaymentOutputDescriptor_set_channel_value_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_set_channel_value_satoshis(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_new(struct LDKOutPoint outpoint_arg, struct LDKTxOut output_arg, struct LDKThirtyTwoBytes channel_keys_id_arg, uint64_t channel_value_satoshis_arg);
/* @internal */
export function StaticPaymentOutputDescriptor_new(outpoint_arg: bigint, output_arg: bigint, channel_keys_id_arg: number, channel_value_satoshis_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_new(outpoint_arg, output_arg, channel_keys_id_arg, channel_value_satoshis_arg);
	return nativeResponseValue;
}
	// uint64_t StaticPaymentOutputDescriptor_clone_ptr(LDKStaticPaymentOutputDescriptor *NONNULL_PTR arg);
/* @internal */
export function StaticPaymentOutputDescriptor_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_clone(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR orig);
/* @internal */
export function StaticPaymentOutputDescriptor_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_clone(orig);
	return nativeResponseValue;
}
	// bool StaticPaymentOutputDescriptor_eq(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR a, const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR b);
/* @internal */
export function StaticPaymentOutputDescriptor_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z StaticPaymentOutputDescriptor_write(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR obj);
/* @internal */
export function StaticPaymentOutputDescriptor_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ StaticPaymentOutputDescriptor_read(struct LDKu8slice ser);
/* @internal */
export function StaticPaymentOutputDescriptor_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_read(ser);
	return nativeResponseValue;
}
	// void SpendableOutputDescriptor_free(struct LDKSpendableOutputDescriptor this_ptr);
/* @internal */
export function SpendableOutputDescriptor_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_free(this_ptr);
	// debug statements here
}
	// uint64_t SpendableOutputDescriptor_clone_ptr(LDKSpendableOutputDescriptor *NONNULL_PTR arg);
/* @internal */
export function SpendableOutputDescriptor_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_clone(const struct LDKSpendableOutputDescriptor *NONNULL_PTR orig);
/* @internal */
export function SpendableOutputDescriptor_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_clone(orig);
	return nativeResponseValue;
}
	// struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_static_output(struct LDKOutPoint outpoint, struct LDKTxOut output);
/* @internal */
export function SpendableOutputDescriptor_static_output(outpoint: bigint, output: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_static_output(outpoint, output);
	return nativeResponseValue;
}
	// struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_delayed_payment_output(struct LDKDelayedPaymentOutputDescriptor a);
/* @internal */
export function SpendableOutputDescriptor_delayed_payment_output(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_delayed_payment_output(a);
	return nativeResponseValue;
}
	// struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_static_payment_output(struct LDKStaticPaymentOutputDescriptor a);
/* @internal */
export function SpendableOutputDescriptor_static_payment_output(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_static_payment_output(a);
	return nativeResponseValue;
}
	// bool SpendableOutputDescriptor_eq(const struct LDKSpendableOutputDescriptor *NONNULL_PTR a, const struct LDKSpendableOutputDescriptor *NONNULL_PTR b);
/* @internal */
export function SpendableOutputDescriptor_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z SpendableOutputDescriptor_write(const struct LDKSpendableOutputDescriptor *NONNULL_PTR obj);
/* @internal */
export function SpendableOutputDescriptor_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ SpendableOutputDescriptor_read(struct LDKu8slice ser);
/* @internal */
export function SpendableOutputDescriptor_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_read(ser);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_C2Tuple_PartiallySignedTransactionusizeZNoneZ SpendableOutputDescriptor_create_spendable_outputs_psbt(struct LDKCVec_SpendableOutputDescriptorZ descriptors, struct LDKCVec_TxOutZ outputs, struct LDKCVec_u8Z change_destination_script, uint32_t feerate_sat_per_1000_weight, struct LDKCOption_PackedLockTimeZ locktime);
/* @internal */
export function SpendableOutputDescriptor_create_spendable_outputs_psbt(descriptors: number, outputs: number, change_destination_script: number, feerate_sat_per_1000_weight: number, locktime: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_create_spendable_outputs_psbt(descriptors, outputs, change_destination_script, feerate_sat_per_1000_weight, locktime);
	return nativeResponseValue;
}
	// void ChannelSigner_free(struct LDKChannelSigner this_ptr);
/* @internal */
export function ChannelSigner_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelSigner_free(this_ptr);
	// debug statements here
}
	// void EcdsaChannelSigner_free(struct LDKEcdsaChannelSigner this_ptr);
/* @internal */
export function EcdsaChannelSigner_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EcdsaChannelSigner_free(this_ptr);
	// debug statements here
}
	// uint64_t WriteableEcdsaChannelSigner_clone_ptr(LDKWriteableEcdsaChannelSigner *NONNULL_PTR arg);
/* @internal */
export function WriteableEcdsaChannelSigner_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WriteableEcdsaChannelSigner_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKWriteableEcdsaChannelSigner WriteableEcdsaChannelSigner_clone(const struct LDKWriteableEcdsaChannelSigner *NONNULL_PTR orig);
/* @internal */
export function WriteableEcdsaChannelSigner_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WriteableEcdsaChannelSigner_clone(orig);
	return nativeResponseValue;
}
	// void WriteableEcdsaChannelSigner_free(struct LDKWriteableEcdsaChannelSigner this_ptr);
/* @internal */
export function WriteableEcdsaChannelSigner_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WriteableEcdsaChannelSigner_free(this_ptr);
	// debug statements here
}
	// enum LDKRecipient Recipient_clone(const enum LDKRecipient *NONNULL_PTR orig);
/* @internal */
export function Recipient_clone(orig: bigint): Recipient {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Recipient_clone(orig);
	return nativeResponseValue;
}
	// enum LDKRecipient Recipient_node(void);
/* @internal */
export function Recipient_node(): Recipient {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Recipient_node();
	return nativeResponseValue;
}
	// enum LDKRecipient Recipient_phantom_node(void);
/* @internal */
export function Recipient_phantom_node(): Recipient {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Recipient_phantom_node();
	return nativeResponseValue;
}
	// void EntropySource_free(struct LDKEntropySource this_ptr);
/* @internal */
export function EntropySource_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EntropySource_free(this_ptr);
	// debug statements here
}
	// void NodeSigner_free(struct LDKNodeSigner this_ptr);
/* @internal */
export function NodeSigner_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeSigner_free(this_ptr);
	// debug statements here
}
	// void SignerProvider_free(struct LDKSignerProvider this_ptr);
/* @internal */
export function SignerProvider_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignerProvider_free(this_ptr);
	// debug statements here
}
	// void InMemorySigner_free(struct LDKInMemorySigner this_obj);
/* @internal */
export function InMemorySigner_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_free(this_obj);
	// debug statements here
}
	// const uint8_t (*InMemorySigner_get_funding_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */
export function InMemorySigner_get_funding_key(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_get_funding_key(this_ptr);
	return nativeResponseValue;
}
	// void InMemorySigner_set_funding_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);
/* @internal */
export function InMemorySigner_set_funding_key(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_set_funding_key(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*InMemorySigner_get_revocation_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */
export function InMemorySigner_get_revocation_base_key(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_get_revocation_base_key(this_ptr);
	return nativeResponseValue;
}
	// void InMemorySigner_set_revocation_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);
/* @internal */
export function InMemorySigner_set_revocation_base_key(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_set_revocation_base_key(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*InMemorySigner_get_payment_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */
export function InMemorySigner_get_payment_key(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_get_payment_key(this_ptr);
	return nativeResponseValue;
}
	// void InMemorySigner_set_payment_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);
/* @internal */
export function InMemorySigner_set_payment_key(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_set_payment_key(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*InMemorySigner_get_delayed_payment_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */
export function InMemorySigner_get_delayed_payment_base_key(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_get_delayed_payment_base_key(this_ptr);
	return nativeResponseValue;
}
	// void InMemorySigner_set_delayed_payment_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);
/* @internal */
export function InMemorySigner_set_delayed_payment_base_key(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_set_delayed_payment_base_key(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*InMemorySigner_get_htlc_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */
export function InMemorySigner_get_htlc_base_key(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_get_htlc_base_key(this_ptr);
	return nativeResponseValue;
}
	// void InMemorySigner_set_htlc_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);
/* @internal */
export function InMemorySigner_set_htlc_base_key(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_set_htlc_base_key(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*InMemorySigner_get_commitment_seed(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */
export function InMemorySigner_get_commitment_seed(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_get_commitment_seed(this_ptr);
	return nativeResponseValue;
}
	// void InMemorySigner_set_commitment_seed(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function InMemorySigner_set_commitment_seed(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_set_commitment_seed(this_ptr, val);
	// debug statements here
}
	// uint64_t InMemorySigner_clone_ptr(LDKInMemorySigner *NONNULL_PTR arg);
/* @internal */
export function InMemorySigner_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKInMemorySigner InMemorySigner_clone(const struct LDKInMemorySigner *NONNULL_PTR orig);
/* @internal */
export function InMemorySigner_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInMemorySigner InMemorySigner_new(struct LDKSecretKey funding_key, struct LDKSecretKey revocation_base_key, struct LDKSecretKey payment_key, struct LDKSecretKey delayed_payment_base_key, struct LDKSecretKey htlc_base_key, struct LDKThirtyTwoBytes commitment_seed, uint64_t channel_value_satoshis, struct LDKThirtyTwoBytes channel_keys_id, struct LDKThirtyTwoBytes rand_bytes_unique_start);
/* @internal */
export function InMemorySigner_new(funding_key: number, revocation_base_key: number, payment_key: number, delayed_payment_base_key: number, htlc_base_key: number, commitment_seed: number, channel_value_satoshis: bigint, channel_keys_id: number, rand_bytes_unique_start: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_new(funding_key, revocation_base_key, payment_key, delayed_payment_base_key, htlc_base_key, commitment_seed, channel_value_satoshis, channel_keys_id, rand_bytes_unique_start);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelPublicKeys InMemorySigner_counterparty_pubkeys(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_counterparty_pubkeys(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_counterparty_pubkeys(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint16_t InMemorySigner_counterparty_selected_contest_delay(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_counterparty_selected_contest_delay(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_counterparty_selected_contest_delay(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint16_t InMemorySigner_holder_selected_contest_delay(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_holder_selected_contest_delay(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_holder_selected_contest_delay(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InMemorySigner_is_outbound(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_is_outbound(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_is_outbound(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKOutPoint InMemorySigner_funding_outpoint(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_funding_outpoint(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_funding_outpoint(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelTransactionParameters InMemorySigner_get_channel_parameters(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_get_channel_parameters(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_get_channel_parameters(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelTypeFeatures InMemorySigner_channel_type_features(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_channel_type_features(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_channel_type_features(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_counterparty_payment_input(const struct LDKInMemorySigner *NONNULL_PTR this_arg, struct LDKTransaction spend_tx, uintptr_t input_idx, const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR descriptor);
/* @internal */
export function InMemorySigner_sign_counterparty_payment_input(this_arg: bigint, spend_tx: number, input_idx: number, descriptor: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_sign_counterparty_payment_input(this_arg, spend_tx, input_idx, descriptor);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_dynamic_p2wsh_input(const struct LDKInMemorySigner *NONNULL_PTR this_arg, struct LDKTransaction spend_tx, uintptr_t input_idx, const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR descriptor);
/* @internal */
export function InMemorySigner_sign_dynamic_p2wsh_input(this_arg: bigint, spend_tx: number, input_idx: number, descriptor: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_sign_dynamic_p2wsh_input(this_arg, spend_tx, input_idx, descriptor);
	return nativeResponseValue;
}
	// struct LDKEntropySource InMemorySigner_as_EntropySource(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_as_EntropySource(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_as_EntropySource(this_arg);
	return nativeResponseValue;
}
	// struct LDKChannelSigner InMemorySigner_as_ChannelSigner(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_as_ChannelSigner(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_as_ChannelSigner(this_arg);
	return nativeResponseValue;
}
	// struct LDKEcdsaChannelSigner InMemorySigner_as_EcdsaChannelSigner(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_as_EcdsaChannelSigner(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_as_EcdsaChannelSigner(this_arg);
	return nativeResponseValue;
}
	// struct LDKWriteableEcdsaChannelSigner InMemorySigner_as_WriteableEcdsaChannelSigner(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_as_WriteableEcdsaChannelSigner(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_as_WriteableEcdsaChannelSigner(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z InMemorySigner_write(const struct LDKInMemorySigner *NONNULL_PTR obj);
/* @internal */
export function InMemorySigner_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_InMemorySignerDecodeErrorZ InMemorySigner_read(struct LDKu8slice ser, struct LDKEntropySource arg);
/* @internal */
export function InMemorySigner_read(ser: number, arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_read(ser, arg);
	return nativeResponseValue;
}
	// void KeysManager_free(struct LDKKeysManager this_obj);
/* @internal */
export function KeysManager_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysManager_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKKeysManager KeysManager_new(const uint8_t (*seed)[32], uint64_t starting_time_secs, uint32_t starting_time_nanos);
/* @internal */
export function KeysManager_new(seed: number, starting_time_secs: bigint, starting_time_nanos: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysManager_new(seed, starting_time_secs, starting_time_nanos);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKSecretKey KeysManager_get_node_secret_key(const struct LDKKeysManager *NONNULL_PTR this_arg);
/* @internal */
export function KeysManager_get_node_secret_key(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysManager_get_node_secret_key(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInMemorySigner KeysManager_derive_channel_keys(const struct LDKKeysManager *NONNULL_PTR this_arg, uint64_t channel_value_satoshis, const uint8_t (*params)[32]);
/* @internal */
export function KeysManager_derive_channel_keys(this_arg: bigint, channel_value_satoshis: bigint, params: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysManager_derive_channel_keys(this_arg, channel_value_satoshis, params);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PartiallySignedTransactionNoneZ KeysManager_sign_spendable_outputs_psbt(const struct LDKKeysManager *NONNULL_PTR this_arg, struct LDKCVec_SpendableOutputDescriptorZ descriptors, struct LDKCVec_u8Z psbt);
/* @internal */
export function KeysManager_sign_spendable_outputs_psbt(this_arg: bigint, descriptors: number, psbt: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysManager_sign_spendable_outputs_psbt(this_arg, descriptors, psbt);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_TransactionNoneZ KeysManager_spend_spendable_outputs(const struct LDKKeysManager *NONNULL_PTR this_arg, struct LDKCVec_SpendableOutputDescriptorZ descriptors, struct LDKCVec_TxOutZ outputs, struct LDKCVec_u8Z change_destination_script, uint32_t feerate_sat_per_1000_weight, struct LDKCOption_PackedLockTimeZ locktime);
/* @internal */
export function KeysManager_spend_spendable_outputs(this_arg: bigint, descriptors: number, outputs: number, change_destination_script: number, feerate_sat_per_1000_weight: number, locktime: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysManager_spend_spendable_outputs(this_arg, descriptors, outputs, change_destination_script, feerate_sat_per_1000_weight, locktime);
	return nativeResponseValue;
}
	// struct LDKEntropySource KeysManager_as_EntropySource(const struct LDKKeysManager *NONNULL_PTR this_arg);
/* @internal */
export function KeysManager_as_EntropySource(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysManager_as_EntropySource(this_arg);
	return nativeResponseValue;
}
	// struct LDKNodeSigner KeysManager_as_NodeSigner(const struct LDKKeysManager *NONNULL_PTR this_arg);
/* @internal */
export function KeysManager_as_NodeSigner(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysManager_as_NodeSigner(this_arg);
	return nativeResponseValue;
}
	// struct LDKSignerProvider KeysManager_as_SignerProvider(const struct LDKKeysManager *NONNULL_PTR this_arg);
/* @internal */
export function KeysManager_as_SignerProvider(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysManager_as_SignerProvider(this_arg);
	return nativeResponseValue;
}
	// void PhantomKeysManager_free(struct LDKPhantomKeysManager this_obj);
/* @internal */
export function PhantomKeysManager_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomKeysManager_free(this_obj);
	// debug statements here
}
	// struct LDKEntropySource PhantomKeysManager_as_EntropySource(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg);
/* @internal */
export function PhantomKeysManager_as_EntropySource(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomKeysManager_as_EntropySource(this_arg);
	return nativeResponseValue;
}
	// struct LDKNodeSigner PhantomKeysManager_as_NodeSigner(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg);
/* @internal */
export function PhantomKeysManager_as_NodeSigner(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomKeysManager_as_NodeSigner(this_arg);
	return nativeResponseValue;
}
	// struct LDKSignerProvider PhantomKeysManager_as_SignerProvider(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg);
/* @internal */
export function PhantomKeysManager_as_SignerProvider(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomKeysManager_as_SignerProvider(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPhantomKeysManager PhantomKeysManager_new(const uint8_t (*seed)[32], uint64_t starting_time_secs, uint32_t starting_time_nanos, const uint8_t (*cross_node_seed)[32]);
/* @internal */
export function PhantomKeysManager_new(seed: number, starting_time_secs: bigint, starting_time_nanos: number, cross_node_seed: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomKeysManager_new(seed, starting_time_secs, starting_time_nanos, cross_node_seed);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_TransactionNoneZ PhantomKeysManager_spend_spendable_outputs(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg, struct LDKCVec_SpendableOutputDescriptorZ descriptors, struct LDKCVec_TxOutZ outputs, struct LDKCVec_u8Z change_destination_script, uint32_t feerate_sat_per_1000_weight, struct LDKCOption_PackedLockTimeZ locktime);
/* @internal */
export function PhantomKeysManager_spend_spendable_outputs(this_arg: bigint, descriptors: number, outputs: number, change_destination_script: number, feerate_sat_per_1000_weight: number, locktime: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomKeysManager_spend_spendable_outputs(this_arg, descriptors, outputs, change_destination_script, feerate_sat_per_1000_weight, locktime);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInMemorySigner PhantomKeysManager_derive_channel_keys(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg, uint64_t channel_value_satoshis, const uint8_t (*params)[32]);
/* @internal */
export function PhantomKeysManager_derive_channel_keys(this_arg: bigint, channel_value_satoshis: bigint, params: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomKeysManager_derive_channel_keys(this_arg, channel_value_satoshis, params);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKSecretKey PhantomKeysManager_get_node_secret_key(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg);
/* @internal */
export function PhantomKeysManager_get_node_secret_key(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomKeysManager_get_node_secret_key(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKSecretKey PhantomKeysManager_get_phantom_node_secret_key(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg);
/* @internal */
export function PhantomKeysManager_get_phantom_node_secret_key(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomKeysManager_get_phantom_node_secret_key(this_arg);
	return nativeResponseValue;
}
	// void OnionMessenger_free(struct LDKOnionMessenger this_obj);
/* @internal */
export function OnionMessenger_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessenger_free(this_obj);
	// debug statements here
}
	// void MessageRouter_free(struct LDKMessageRouter this_ptr);
/* @internal */
export function MessageRouter_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageRouter_free(this_ptr);
	// debug statements here
}
	// void DefaultMessageRouter_free(struct LDKDefaultMessageRouter this_obj);
/* @internal */
export function DefaultMessageRouter_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DefaultMessageRouter_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKDefaultMessageRouter DefaultMessageRouter_new(void);
/* @internal */
export function DefaultMessageRouter_new(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DefaultMessageRouter_new();
	return nativeResponseValue;
}
	// struct LDKMessageRouter DefaultMessageRouter_as_MessageRouter(const struct LDKDefaultMessageRouter *NONNULL_PTR this_arg);
/* @internal */
export function DefaultMessageRouter_as_MessageRouter(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DefaultMessageRouter_as_MessageRouter(this_arg);
	return nativeResponseValue;
}
	// void OnionMessagePath_free(struct LDKOnionMessagePath this_obj);
/* @internal */
export function OnionMessagePath_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessagePath_free(this_obj);
	// debug statements here
}
	// struct LDKCVec_PublicKeyZ OnionMessagePath_get_intermediate_nodes(const struct LDKOnionMessagePath *NONNULL_PTR this_ptr);
/* @internal */
export function OnionMessagePath_get_intermediate_nodes(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessagePath_get_intermediate_nodes(this_ptr);
	return nativeResponseValue;
}
	// void OnionMessagePath_set_intermediate_nodes(struct LDKOnionMessagePath *NONNULL_PTR this_ptr, struct LDKCVec_PublicKeyZ val);
/* @internal */
export function OnionMessagePath_set_intermediate_nodes(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessagePath_set_intermediate_nodes(this_ptr, val);
	// debug statements here
}
	// struct LDKDestination OnionMessagePath_get_destination(const struct LDKOnionMessagePath *NONNULL_PTR this_ptr);
/* @internal */
export function OnionMessagePath_get_destination(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessagePath_get_destination(this_ptr);
	return nativeResponseValue;
}
	// void OnionMessagePath_set_destination(struct LDKOnionMessagePath *NONNULL_PTR this_ptr, struct LDKDestination val);
/* @internal */
export function OnionMessagePath_set_destination(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessagePath_set_destination(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKOnionMessagePath OnionMessagePath_new(struct LDKCVec_PublicKeyZ intermediate_nodes_arg, struct LDKDestination destination_arg);
/* @internal */
export function OnionMessagePath_new(intermediate_nodes_arg: number, destination_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessagePath_new(intermediate_nodes_arg, destination_arg);
	return nativeResponseValue;
}
	// uint64_t OnionMessagePath_clone_ptr(LDKOnionMessagePath *NONNULL_PTR arg);
/* @internal */
export function OnionMessagePath_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessagePath_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKOnionMessagePath OnionMessagePath_clone(const struct LDKOnionMessagePath *NONNULL_PTR orig);
/* @internal */
export function OnionMessagePath_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessagePath_clone(orig);
	return nativeResponseValue;
}
	// void Destination_free(struct LDKDestination this_ptr);
/* @internal */
export function Destination_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Destination_free(this_ptr);
	// debug statements here
}
	// uint64_t Destination_clone_ptr(LDKDestination *NONNULL_PTR arg);
/* @internal */
export function Destination_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Destination_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKDestination Destination_clone(const struct LDKDestination *NONNULL_PTR orig);
/* @internal */
export function Destination_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Destination_clone(orig);
	return nativeResponseValue;
}
	// struct LDKDestination Destination_node(struct LDKPublicKey a);
/* @internal */
export function Destination_node(a: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Destination_node(a);
	return nativeResponseValue;
}
	// struct LDKDestination Destination_blinded_path(struct LDKBlindedPath a);
/* @internal */
export function Destination_blinded_path(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Destination_blinded_path(a);
	return nativeResponseValue;
}
	// void SendError_free(struct LDKSendError this_ptr);
/* @internal */
export function SendError_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SendError_free(this_ptr);
	// debug statements here
}
	// uint64_t SendError_clone_ptr(LDKSendError *NONNULL_PTR arg);
/* @internal */
export function SendError_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SendError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKSendError SendError_clone(const struct LDKSendError *NONNULL_PTR orig);
/* @internal */
export function SendError_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SendError_clone(orig);
	return nativeResponseValue;
}
	// struct LDKSendError SendError_secp256k1(enum LDKSecp256k1Error a);
/* @internal */
export function SendError_secp256k1(a: Secp256k1Error): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SendError_secp256k1(a);
	return nativeResponseValue;
}
	// struct LDKSendError SendError_too_big_packet(void);
/* @internal */
export function SendError_too_big_packet(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SendError_too_big_packet();
	return nativeResponseValue;
}
	// struct LDKSendError SendError_too_few_blinded_hops(void);
/* @internal */
export function SendError_too_few_blinded_hops(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SendError_too_few_blinded_hops();
	return nativeResponseValue;
}
	// struct LDKSendError SendError_invalid_first_hop(void);
/* @internal */
export function SendError_invalid_first_hop(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SendError_invalid_first_hop();
	return nativeResponseValue;
}
	// struct LDKSendError SendError_invalid_message(void);
/* @internal */
export function SendError_invalid_message(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SendError_invalid_message();
	return nativeResponseValue;
}
	// struct LDKSendError SendError_buffer_full(void);
/* @internal */
export function SendError_buffer_full(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SendError_buffer_full();
	return nativeResponseValue;
}
	// struct LDKSendError SendError_get_node_id_failed(void);
/* @internal */
export function SendError_get_node_id_failed(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SendError_get_node_id_failed();
	return nativeResponseValue;
}
	// struct LDKSendError SendError_blinded_path_advance_failed(void);
/* @internal */
export function SendError_blinded_path_advance_failed(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SendError_blinded_path_advance_failed();
	return nativeResponseValue;
}
	// bool SendError_eq(const struct LDKSendError *NONNULL_PTR a, const struct LDKSendError *NONNULL_PTR b);
/* @internal */
export function SendError_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SendError_eq(a, b);
	return nativeResponseValue;
}
	// void CustomOnionMessageHandler_free(struct LDKCustomOnionMessageHandler this_ptr);
/* @internal */
export function CustomOnionMessageHandler_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomOnionMessageHandler_free(this_ptr);
	// debug statements here
}
	// MUST_USE_RES struct LDKOnionMessenger OnionMessenger_new(struct LDKEntropySource entropy_source, struct LDKNodeSigner node_signer, struct LDKLogger logger, struct LDKMessageRouter message_router, struct LDKOffersMessageHandler offers_handler, struct LDKCustomOnionMessageHandler custom_handler);
/* @internal */
export function OnionMessenger_new(entropy_source: bigint, node_signer: bigint, logger: bigint, message_router: bigint, offers_handler: bigint, custom_handler: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessenger_new(entropy_source, node_signer, logger, message_router, offers_handler, custom_handler);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneSendErrorZ OnionMessenger_send_onion_message(const struct LDKOnionMessenger *NONNULL_PTR this_arg, struct LDKOnionMessagePath path, struct LDKOnionMessageContents message, struct LDKBlindedPath reply_path);
/* @internal */
export function OnionMessenger_send_onion_message(this_arg: bigint, path: bigint, message: bigint, reply_path: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessenger_send_onion_message(this_arg, path, message, reply_path);
	return nativeResponseValue;
}
	// struct LDKOnionMessageHandler OnionMessenger_as_OnionMessageHandler(const struct LDKOnionMessenger *NONNULL_PTR this_arg);
/* @internal */
export function OnionMessenger_as_OnionMessageHandler(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessenger_as_OnionMessageHandler(this_arg);
	return nativeResponseValue;
}
	// struct LDKOnionMessageProvider OnionMessenger_as_OnionMessageProvider(const struct LDKOnionMessenger *NONNULL_PTR this_arg);
/* @internal */
export function OnionMessenger_as_OnionMessageProvider(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessenger_as_OnionMessageProvider(this_arg);
	return nativeResponseValue;
}
	// void OffersMessageHandler_free(struct LDKOffersMessageHandler this_ptr);
/* @internal */
export function OffersMessageHandler_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OffersMessageHandler_free(this_ptr);
	// debug statements here
}
	// void OffersMessage_free(struct LDKOffersMessage this_ptr);
/* @internal */
export function OffersMessage_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OffersMessage_free(this_ptr);
	// debug statements here
}
	// uint64_t OffersMessage_clone_ptr(LDKOffersMessage *NONNULL_PTR arg);
/* @internal */
export function OffersMessage_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OffersMessage_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKOffersMessage OffersMessage_clone(const struct LDKOffersMessage *NONNULL_PTR orig);
/* @internal */
export function OffersMessage_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OffersMessage_clone(orig);
	return nativeResponseValue;
}
	// struct LDKOffersMessage OffersMessage_invoice_request(struct LDKInvoiceRequest a);
/* @internal */
export function OffersMessage_invoice_request(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OffersMessage_invoice_request(a);
	return nativeResponseValue;
}
	// struct LDKOffersMessage OffersMessage_invoice(struct LDKBolt12Invoice a);
/* @internal */
export function OffersMessage_invoice(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OffersMessage_invoice(a);
	return nativeResponseValue;
}
	// struct LDKOffersMessage OffersMessage_invoice_error(struct LDKInvoiceError a);
/* @internal */
export function OffersMessage_invoice_error(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OffersMessage_invoice_error(a);
	return nativeResponseValue;
}
	// MUST_USE_RES bool OffersMessage_is_known_type(uint64_t tlv_type);
/* @internal */
export function OffersMessage_is_known_type(tlv_type: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OffersMessage_is_known_type(tlv_type);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t OffersMessage_tlv_type(const struct LDKOffersMessage *NONNULL_PTR this_arg);
/* @internal */
export function OffersMessage_tlv_type(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OffersMessage_tlv_type(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z OffersMessage_write(const struct LDKOffersMessage *NONNULL_PTR obj);
/* @internal */
export function OffersMessage_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OffersMessage_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_OffersMessageDecodeErrorZ OffersMessage_read(struct LDKu8slice ser, uint64_t arg_a, const struct LDKLogger *NONNULL_PTR arg_b);
/* @internal */
export function OffersMessage_read(ser: number, arg_a: bigint, arg_b: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OffersMessage_read(ser, arg_a, arg_b);
	return nativeResponseValue;
}
	// void OnionMessageContents_free(struct LDKOnionMessageContents this_ptr);
/* @internal */
export function OnionMessageContents_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessageContents_free(this_ptr);
	// debug statements here
}
	// uint64_t OnionMessageContents_clone_ptr(LDKOnionMessageContents *NONNULL_PTR arg);
/* @internal */
export function OnionMessageContents_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessageContents_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKOnionMessageContents OnionMessageContents_clone(const struct LDKOnionMessageContents *NONNULL_PTR orig);
/* @internal */
export function OnionMessageContents_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessageContents_clone(orig);
	return nativeResponseValue;
}
	// struct LDKOnionMessageContents OnionMessageContents_offers(struct LDKOffersMessage a);
/* @internal */
export function OnionMessageContents_offers(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessageContents_offers(a);
	return nativeResponseValue;
}
	// struct LDKOnionMessageContents OnionMessageContents_custom(struct LDKCustomOnionMessageContents a);
/* @internal */
export function OnionMessageContents_custom(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessageContents_custom(a);
	return nativeResponseValue;
}
	// uint64_t CustomOnionMessageContents_clone_ptr(LDKCustomOnionMessageContents *NONNULL_PTR arg);
/* @internal */
export function CustomOnionMessageContents_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomOnionMessageContents_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCustomOnionMessageContents CustomOnionMessageContents_clone(const struct LDKCustomOnionMessageContents *NONNULL_PTR orig);
/* @internal */
export function CustomOnionMessageContents_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomOnionMessageContents_clone(orig);
	return nativeResponseValue;
}
	// void CustomOnionMessageContents_free(struct LDKCustomOnionMessageContents this_ptr);
/* @internal */
export function CustomOnionMessageContents_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomOnionMessageContents_free(this_ptr);
	// debug statements here
}
	// void BlindedPath_free(struct LDKBlindedPath this_obj);
/* @internal */
export function BlindedPath_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPath_free(this_obj);
	// debug statements here
}
	// uint64_t BlindedPath_clone_ptr(LDKBlindedPath *NONNULL_PTR arg);
/* @internal */
export function BlindedPath_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPath_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBlindedPath BlindedPath_clone(const struct LDKBlindedPath *NONNULL_PTR orig);
/* @internal */
export function BlindedPath_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPath_clone(orig);
	return nativeResponseValue;
}
	// uint64_t BlindedPath_hash(const struct LDKBlindedPath *NONNULL_PTR o);
/* @internal */
export function BlindedPath_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPath_hash(o);
	return nativeResponseValue;
}
	// bool BlindedPath_eq(const struct LDKBlindedPath *NONNULL_PTR a, const struct LDKBlindedPath *NONNULL_PTR b);
/* @internal */
export function BlindedPath_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPath_eq(a, b);
	return nativeResponseValue;
}
	// void BlindedHop_free(struct LDKBlindedHop this_obj);
/* @internal */
export function BlindedHop_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHop_free(this_obj);
	// debug statements here
}
	// uint64_t BlindedHop_clone_ptr(LDKBlindedHop *NONNULL_PTR arg);
/* @internal */
export function BlindedHop_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHop_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBlindedHop BlindedHop_clone(const struct LDKBlindedHop *NONNULL_PTR orig);
/* @internal */
export function BlindedHop_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHop_clone(orig);
	return nativeResponseValue;
}
	// uint64_t BlindedHop_hash(const struct LDKBlindedHop *NONNULL_PTR o);
/* @internal */
export function BlindedHop_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHop_hash(o);
	return nativeResponseValue;
}
	// bool BlindedHop_eq(const struct LDKBlindedHop *NONNULL_PTR a, const struct LDKBlindedHop *NONNULL_PTR b);
/* @internal */
export function BlindedHop_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHop_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_BlindedPathNoneZ BlindedPath_new_for_message(struct LDKCVec_PublicKeyZ node_pks, const struct LDKEntropySource *NONNULL_PTR entropy_source);
/* @internal */
export function BlindedPath_new_for_message(node_pks: number, entropy_source: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPath_new_for_message(node_pks, entropy_source);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z BlindedPath_write(const struct LDKBlindedPath *NONNULL_PTR obj);
/* @internal */
export function BlindedPath_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPath_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedPathDecodeErrorZ BlindedPath_read(struct LDKu8slice ser);
/* @internal */
export function BlindedPath_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedPath_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z BlindedHop_write(const struct LDKBlindedHop *NONNULL_PTR obj);
/* @internal */
export function BlindedHop_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHop_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_BlindedHopDecodeErrorZ BlindedHop_read(struct LDKu8slice ser);
/* @internal */
export function BlindedHop_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BlindedHop_read(ser);
	return nativeResponseValue;
}
	// void PaymentPurpose_free(struct LDKPaymentPurpose this_ptr);
/* @internal */
export function PaymentPurpose_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentPurpose_free(this_ptr);
	// debug statements here
}
	// uint64_t PaymentPurpose_clone_ptr(LDKPaymentPurpose *NONNULL_PTR arg);
/* @internal */
export function PaymentPurpose_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentPurpose_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPaymentPurpose PaymentPurpose_clone(const struct LDKPaymentPurpose *NONNULL_PTR orig);
/* @internal */
export function PaymentPurpose_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentPurpose_clone(orig);
	return nativeResponseValue;
}
	// struct LDKPaymentPurpose PaymentPurpose_invoice_payment(struct LDKCOption_PaymentPreimageZ payment_preimage, struct LDKThirtyTwoBytes payment_secret);
/* @internal */
export function PaymentPurpose_invoice_payment(payment_preimage: bigint, payment_secret: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentPurpose_invoice_payment(payment_preimage, payment_secret);
	return nativeResponseValue;
}
	// struct LDKPaymentPurpose PaymentPurpose_spontaneous_payment(struct LDKThirtyTwoBytes a);
/* @internal */
export function PaymentPurpose_spontaneous_payment(a: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentPurpose_spontaneous_payment(a);
	return nativeResponseValue;
}
	// bool PaymentPurpose_eq(const struct LDKPaymentPurpose *NONNULL_PTR a, const struct LDKPaymentPurpose *NONNULL_PTR b);
/* @internal */
export function PaymentPurpose_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentPurpose_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z PaymentPurpose_write(const struct LDKPaymentPurpose *NONNULL_PTR obj);
/* @internal */
export function PaymentPurpose_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentPurpose_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentPurposeDecodeErrorZ PaymentPurpose_read(struct LDKu8slice ser);
/* @internal */
export function PaymentPurpose_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentPurpose_read(ser);
	return nativeResponseValue;
}
	// void PathFailure_free(struct LDKPathFailure this_ptr);
/* @internal */
export function PathFailure_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PathFailure_free(this_ptr);
	// debug statements here
}
	// uint64_t PathFailure_clone_ptr(LDKPathFailure *NONNULL_PTR arg);
/* @internal */
export function PathFailure_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PathFailure_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPathFailure PathFailure_clone(const struct LDKPathFailure *NONNULL_PTR orig);
/* @internal */
export function PathFailure_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PathFailure_clone(orig);
	return nativeResponseValue;
}
	// struct LDKPathFailure PathFailure_initial_send(struct LDKAPIError err);
/* @internal */
export function PathFailure_initial_send(err: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PathFailure_initial_send(err);
	return nativeResponseValue;
}
	// struct LDKPathFailure PathFailure_on_path(struct LDKCOption_NetworkUpdateZ network_update);
/* @internal */
export function PathFailure_on_path(network_update: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PathFailure_on_path(network_update);
	return nativeResponseValue;
}
	// bool PathFailure_eq(const struct LDKPathFailure *NONNULL_PTR a, const struct LDKPathFailure *NONNULL_PTR b);
/* @internal */
export function PathFailure_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PathFailure_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z PathFailure_write(const struct LDKPathFailure *NONNULL_PTR obj);
/* @internal */
export function PathFailure_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PathFailure_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_PathFailureZDecodeErrorZ PathFailure_read(struct LDKu8slice ser);
/* @internal */
export function PathFailure_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PathFailure_read(ser);
	return nativeResponseValue;
}
	// void ClosureReason_free(struct LDKClosureReason this_ptr);
/* @internal */
export function ClosureReason_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_free(this_ptr);
	// debug statements here
}
	// uint64_t ClosureReason_clone_ptr(LDKClosureReason *NONNULL_PTR arg);
/* @internal */
export function ClosureReason_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_clone(const struct LDKClosureReason *NONNULL_PTR orig);
/* @internal */
export function ClosureReason_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_clone(orig);
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_counterparty_force_closed(struct LDKUntrustedString peer_msg);
/* @internal */
export function ClosureReason_counterparty_force_closed(peer_msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_counterparty_force_closed(peer_msg);
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_holder_force_closed(void);
/* @internal */
export function ClosureReason_holder_force_closed(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_holder_force_closed();
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_cooperative_closure(void);
/* @internal */
export function ClosureReason_cooperative_closure(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_cooperative_closure();
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_commitment_tx_confirmed(void);
/* @internal */
export function ClosureReason_commitment_tx_confirmed(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_commitment_tx_confirmed();
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_funding_timed_out(void);
/* @internal */
export function ClosureReason_funding_timed_out(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_funding_timed_out();
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_processing_error(struct LDKStr err);
/* @internal */
export function ClosureReason_processing_error(err: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_processing_error(err);
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_disconnected_peer(void);
/* @internal */
export function ClosureReason_disconnected_peer(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_disconnected_peer();
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_outdated_channel_manager(void);
/* @internal */
export function ClosureReason_outdated_channel_manager(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_outdated_channel_manager();
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_counterparty_coop_closed_unfunded_channel(void);
/* @internal */
export function ClosureReason_counterparty_coop_closed_unfunded_channel(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_counterparty_coop_closed_unfunded_channel();
	return nativeResponseValue;
}
	// bool ClosureReason_eq(const struct LDKClosureReason *NONNULL_PTR a, const struct LDKClosureReason *NONNULL_PTR b);
/* @internal */
export function ClosureReason_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ClosureReason_write(const struct LDKClosureReason *NONNULL_PTR obj);
/* @internal */
export function ClosureReason_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_ClosureReasonZDecodeErrorZ ClosureReason_read(struct LDKu8slice ser);
/* @internal */
export function ClosureReason_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_read(ser);
	return nativeResponseValue;
}
	// void HTLCDestination_free(struct LDKHTLCDestination this_ptr);
/* @internal */
export function HTLCDestination_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDestination_free(this_ptr);
	// debug statements here
}
	// uint64_t HTLCDestination_clone_ptr(LDKHTLCDestination *NONNULL_PTR arg);
/* @internal */
export function HTLCDestination_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDestination_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKHTLCDestination HTLCDestination_clone(const struct LDKHTLCDestination *NONNULL_PTR orig);
/* @internal */
export function HTLCDestination_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDestination_clone(orig);
	return nativeResponseValue;
}
	// struct LDKHTLCDestination HTLCDestination_next_hop_channel(struct LDKPublicKey node_id, struct LDKThirtyTwoBytes channel_id);
/* @internal */
export function HTLCDestination_next_hop_channel(node_id: number, channel_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDestination_next_hop_channel(node_id, channel_id);
	return nativeResponseValue;
}
	// struct LDKHTLCDestination HTLCDestination_unknown_next_hop(uint64_t requested_forward_scid);
/* @internal */
export function HTLCDestination_unknown_next_hop(requested_forward_scid: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDestination_unknown_next_hop(requested_forward_scid);
	return nativeResponseValue;
}
	// struct LDKHTLCDestination HTLCDestination_invalid_forward(uint64_t requested_forward_scid);
/* @internal */
export function HTLCDestination_invalid_forward(requested_forward_scid: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDestination_invalid_forward(requested_forward_scid);
	return nativeResponseValue;
}
	// struct LDKHTLCDestination HTLCDestination_failed_payment(struct LDKThirtyTwoBytes payment_hash);
/* @internal */
export function HTLCDestination_failed_payment(payment_hash: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDestination_failed_payment(payment_hash);
	return nativeResponseValue;
}
	// bool HTLCDestination_eq(const struct LDKHTLCDestination *NONNULL_PTR a, const struct LDKHTLCDestination *NONNULL_PTR b);
/* @internal */
export function HTLCDestination_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDestination_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z HTLCDestination_write(const struct LDKHTLCDestination *NONNULL_PTR obj);
/* @internal */
export function HTLCDestination_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDestination_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ HTLCDestination_read(struct LDKu8slice ser);
/* @internal */
export function HTLCDestination_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDestination_read(ser);
	return nativeResponseValue;
}
	// enum LDKPaymentFailureReason PaymentFailureReason_clone(const enum LDKPaymentFailureReason *NONNULL_PTR orig);
/* @internal */
export function PaymentFailureReason_clone(orig: bigint): PaymentFailureReason {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentFailureReason_clone(orig);
	return nativeResponseValue;
}
	// enum LDKPaymentFailureReason PaymentFailureReason_recipient_rejected(void);
/* @internal */
export function PaymentFailureReason_recipient_rejected(): PaymentFailureReason {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentFailureReason_recipient_rejected();
	return nativeResponseValue;
}
	// enum LDKPaymentFailureReason PaymentFailureReason_user_abandoned(void);
/* @internal */
export function PaymentFailureReason_user_abandoned(): PaymentFailureReason {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentFailureReason_user_abandoned();
	return nativeResponseValue;
}
	// enum LDKPaymentFailureReason PaymentFailureReason_retries_exhausted(void);
/* @internal */
export function PaymentFailureReason_retries_exhausted(): PaymentFailureReason {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentFailureReason_retries_exhausted();
	return nativeResponseValue;
}
	// enum LDKPaymentFailureReason PaymentFailureReason_payment_expired(void);
/* @internal */
export function PaymentFailureReason_payment_expired(): PaymentFailureReason {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentFailureReason_payment_expired();
	return nativeResponseValue;
}
	// enum LDKPaymentFailureReason PaymentFailureReason_route_not_found(void);
/* @internal */
export function PaymentFailureReason_route_not_found(): PaymentFailureReason {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentFailureReason_route_not_found();
	return nativeResponseValue;
}
	// enum LDKPaymentFailureReason PaymentFailureReason_unexpected_error(void);
/* @internal */
export function PaymentFailureReason_unexpected_error(): PaymentFailureReason {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentFailureReason_unexpected_error();
	return nativeResponseValue;
}
	// bool PaymentFailureReason_eq(const enum LDKPaymentFailureReason *NONNULL_PTR a, const enum LDKPaymentFailureReason *NONNULL_PTR b);
/* @internal */
export function PaymentFailureReason_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentFailureReason_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z PaymentFailureReason_write(const enum LDKPaymentFailureReason *NONNULL_PTR obj);
/* @internal */
export function PaymentFailureReason_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentFailureReason_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentFailureReasonDecodeErrorZ PaymentFailureReason_read(struct LDKu8slice ser);
/* @internal */
export function PaymentFailureReason_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentFailureReason_read(ser);
	return nativeResponseValue;
}
	// void Event_free(struct LDKEvent this_ptr);
/* @internal */
export function Event_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_free(this_ptr);
	// debug statements here
}
	// uint64_t Event_clone_ptr(LDKEvent *NONNULL_PTR arg);
/* @internal */
export function Event_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKEvent Event_clone(const struct LDKEvent *NONNULL_PTR orig);
/* @internal */
export function Event_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_clone(orig);
	return nativeResponseValue;
}
	// struct LDKEvent Event_funding_generation_ready(struct LDKThirtyTwoBytes temporary_channel_id, struct LDKPublicKey counterparty_node_id, uint64_t channel_value_satoshis, struct LDKCVec_u8Z output_script, struct LDKU128 user_channel_id);
/* @internal */
export function Event_funding_generation_ready(temporary_channel_id: number, counterparty_node_id: number, channel_value_satoshis: bigint, output_script: number, user_channel_id: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_funding_generation_ready(temporary_channel_id, counterparty_node_id, channel_value_satoshis, output_script, user_channel_id);
	return nativeResponseValue;
}
	// struct LDKEvent Event_payment_claimable(struct LDKPublicKey receiver_node_id, struct LDKThirtyTwoBytes payment_hash, struct LDKRecipientOnionFields onion_fields, uint64_t amount_msat, uint64_t counterparty_skimmed_fee_msat, struct LDKPaymentPurpose purpose, struct LDKThirtyTwoBytes via_channel_id, struct LDKCOption_u128Z via_user_channel_id, struct LDKCOption_u32Z claim_deadline);
/* @internal */
export function Event_payment_claimable(receiver_node_id: number, payment_hash: number, onion_fields: bigint, amount_msat: bigint, counterparty_skimmed_fee_msat: bigint, purpose: bigint, via_channel_id: number, via_user_channel_id: bigint, claim_deadline: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_payment_claimable(receiver_node_id, payment_hash, onion_fields, amount_msat, counterparty_skimmed_fee_msat, purpose, via_channel_id, via_user_channel_id, claim_deadline);
	return nativeResponseValue;
}
	// struct LDKEvent Event_payment_claimed(struct LDKPublicKey receiver_node_id, struct LDKThirtyTwoBytes payment_hash, uint64_t amount_msat, struct LDKPaymentPurpose purpose);
/* @internal */
export function Event_payment_claimed(receiver_node_id: number, payment_hash: number, amount_msat: bigint, purpose: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_payment_claimed(receiver_node_id, payment_hash, amount_msat, purpose);
	return nativeResponseValue;
}
	// struct LDKEvent Event_payment_sent(struct LDKCOption_PaymentIdZ payment_id, struct LDKThirtyTwoBytes payment_preimage, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u64Z fee_paid_msat);
/* @internal */
export function Event_payment_sent(payment_id: bigint, payment_preimage: number, payment_hash: number, fee_paid_msat: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_payment_sent(payment_id, payment_preimage, payment_hash, fee_paid_msat);
	return nativeResponseValue;
}
	// struct LDKEvent Event_payment_failed(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_PaymentFailureReasonZ reason);
/* @internal */
export function Event_payment_failed(payment_id: number, payment_hash: number, reason: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_payment_failed(payment_id, payment_hash, reason);
	return nativeResponseValue;
}
	// struct LDKEvent Event_payment_path_successful(struct LDKThirtyTwoBytes payment_id, struct LDKCOption_PaymentHashZ payment_hash, struct LDKPath path);
/* @internal */
export function Event_payment_path_successful(payment_id: number, payment_hash: bigint, path: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_payment_path_successful(payment_id, payment_hash, path);
	return nativeResponseValue;
}
	// struct LDKEvent Event_payment_path_failed(struct LDKCOption_PaymentIdZ payment_id, struct LDKThirtyTwoBytes payment_hash, bool payment_failed_permanently, struct LDKPathFailure failure, struct LDKPath path, struct LDKCOption_u64Z short_channel_id);
/* @internal */
export function Event_payment_path_failed(payment_id: bigint, payment_hash: number, payment_failed_permanently: boolean, failure: bigint, path: bigint, short_channel_id: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_payment_path_failed(payment_id, payment_hash, payment_failed_permanently, failure, path, short_channel_id);
	return nativeResponseValue;
}
	// struct LDKEvent Event_probe_successful(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash, struct LDKPath path);
/* @internal */
export function Event_probe_successful(payment_id: number, payment_hash: number, path: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_probe_successful(payment_id, payment_hash, path);
	return nativeResponseValue;
}
	// struct LDKEvent Event_probe_failed(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash, struct LDKPath path, struct LDKCOption_u64Z short_channel_id);
/* @internal */
export function Event_probe_failed(payment_id: number, payment_hash: number, path: bigint, short_channel_id: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_probe_failed(payment_id, payment_hash, path, short_channel_id);
	return nativeResponseValue;
}
	// struct LDKEvent Event_pending_htlcs_forwardable(uint64_t time_forwardable);
/* @internal */
export function Event_pending_htlcs_forwardable(time_forwardable: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_pending_htlcs_forwardable(time_forwardable);
	return nativeResponseValue;
}
	// struct LDKEvent Event_htlcintercepted(struct LDKThirtyTwoBytes intercept_id, uint64_t requested_next_hop_scid, struct LDKThirtyTwoBytes payment_hash, uint64_t inbound_amount_msat, uint64_t expected_outbound_amount_msat);
/* @internal */
export function Event_htlcintercepted(intercept_id: number, requested_next_hop_scid: bigint, payment_hash: number, inbound_amount_msat: bigint, expected_outbound_amount_msat: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_htlcintercepted(intercept_id, requested_next_hop_scid, payment_hash, inbound_amount_msat, expected_outbound_amount_msat);
	return nativeResponseValue;
}
	// struct LDKEvent Event_spendable_outputs(struct LDKCVec_SpendableOutputDescriptorZ outputs);
/* @internal */
export function Event_spendable_outputs(outputs: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_spendable_outputs(outputs);
	return nativeResponseValue;
}
	// struct LDKEvent Event_payment_forwarded(struct LDKThirtyTwoBytes prev_channel_id, struct LDKThirtyTwoBytes next_channel_id, struct LDKCOption_u64Z fee_earned_msat, bool claim_from_onchain_tx, struct LDKCOption_u64Z outbound_amount_forwarded_msat);
/* @internal */
export function Event_payment_forwarded(prev_channel_id: number, next_channel_id: number, fee_earned_msat: bigint, claim_from_onchain_tx: boolean, outbound_amount_forwarded_msat: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_payment_forwarded(prev_channel_id, next_channel_id, fee_earned_msat, claim_from_onchain_tx, outbound_amount_forwarded_msat);
	return nativeResponseValue;
}
	// struct LDKEvent Event_channel_pending(struct LDKThirtyTwoBytes channel_id, struct LDKU128 user_channel_id, struct LDKThirtyTwoBytes former_temporary_channel_id, struct LDKPublicKey counterparty_node_id, struct LDKOutPoint funding_txo);
/* @internal */
export function Event_channel_pending(channel_id: number, user_channel_id: number, former_temporary_channel_id: number, counterparty_node_id: number, funding_txo: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_channel_pending(channel_id, user_channel_id, former_temporary_channel_id, counterparty_node_id, funding_txo);
	return nativeResponseValue;
}
	// struct LDKEvent Event_channel_ready(struct LDKThirtyTwoBytes channel_id, struct LDKU128 user_channel_id, struct LDKPublicKey counterparty_node_id, struct LDKChannelTypeFeatures channel_type);
/* @internal */
export function Event_channel_ready(channel_id: number, user_channel_id: number, counterparty_node_id: number, channel_type: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_channel_ready(channel_id, user_channel_id, counterparty_node_id, channel_type);
	return nativeResponseValue;
}
	// struct LDKEvent Event_channel_closed(struct LDKThirtyTwoBytes channel_id, struct LDKU128 user_channel_id, struct LDKClosureReason reason);
/* @internal */
export function Event_channel_closed(channel_id: number, user_channel_id: number, reason: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_channel_closed(channel_id, user_channel_id, reason);
	return nativeResponseValue;
}
	// struct LDKEvent Event_discard_funding(struct LDKThirtyTwoBytes channel_id, struct LDKTransaction transaction);
/* @internal */
export function Event_discard_funding(channel_id: number, transaction: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_discard_funding(channel_id, transaction);
	return nativeResponseValue;
}
	// struct LDKEvent Event_open_channel_request(struct LDKThirtyTwoBytes temporary_channel_id, struct LDKPublicKey counterparty_node_id, uint64_t funding_satoshis, uint64_t push_msat, struct LDKChannelTypeFeatures channel_type);
/* @internal */
export function Event_open_channel_request(temporary_channel_id: number, counterparty_node_id: number, funding_satoshis: bigint, push_msat: bigint, channel_type: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_open_channel_request(temporary_channel_id, counterparty_node_id, funding_satoshis, push_msat, channel_type);
	return nativeResponseValue;
}
	// struct LDKEvent Event_htlchandling_failed(struct LDKThirtyTwoBytes prev_channel_id, struct LDKHTLCDestination failed_next_destination);
/* @internal */
export function Event_htlchandling_failed(prev_channel_id: number, failed_next_destination: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_htlchandling_failed(prev_channel_id, failed_next_destination);
	return nativeResponseValue;
}
	// struct LDKEvent Event_bump_transaction(struct LDKBumpTransactionEvent a);
/* @internal */
export function Event_bump_transaction(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_bump_transaction(a);
	return nativeResponseValue;
}
	// bool Event_eq(const struct LDKEvent *NONNULL_PTR a, const struct LDKEvent *NONNULL_PTR b);
/* @internal */
export function Event_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Event_write(const struct LDKEvent *NONNULL_PTR obj);
/* @internal */
export function Event_write(obj: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_EventZDecodeErrorZ Event_read(struct LDKu8slice ser);
/* @internal */
export function Event_read(ser: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_read(ser);
	return nativeResponseValue;
}
	// void MessageSendEvent_free(struct LDKMessageSendEvent this_ptr);
/* @internal */
export function MessageSendEvent_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_free(this_ptr);
	// debug statements here
}
	// uint64_t MessageSendEvent_clone_ptr(LDKMessageSendEvent *NONNULL_PTR arg);
/* @internal */
export function MessageSendEvent_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_clone(const struct LDKMessageSendEvent *NONNULL_PTR orig);
/* @internal */
export function MessageSendEvent_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_clone(orig);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_accept_channel(struct LDKPublicKey node_id, struct LDKAcceptChannel msg);
/* @internal */
export function MessageSendEvent_send_accept_channel(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_accept_channel(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_accept_channel_v2(struct LDKPublicKey node_id, struct LDKAcceptChannelV2 msg);
/* @internal */
export function MessageSendEvent_send_accept_channel_v2(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_accept_channel_v2(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_open_channel(struct LDKPublicKey node_id, struct LDKOpenChannel msg);
/* @internal */
export function MessageSendEvent_send_open_channel(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_open_channel(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_open_channel_v2(struct LDKPublicKey node_id, struct LDKOpenChannelV2 msg);
/* @internal */
export function MessageSendEvent_send_open_channel_v2(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_open_channel_v2(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_funding_created(struct LDKPublicKey node_id, struct LDKFundingCreated msg);
/* @internal */
export function MessageSendEvent_send_funding_created(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_funding_created(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_funding_signed(struct LDKPublicKey node_id, struct LDKFundingSigned msg);
/* @internal */
export function MessageSendEvent_send_funding_signed(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_funding_signed(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_tx_add_input(struct LDKPublicKey node_id, struct LDKTxAddInput msg);
/* @internal */
export function MessageSendEvent_send_tx_add_input(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_tx_add_input(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_tx_add_output(struct LDKPublicKey node_id, struct LDKTxAddOutput msg);
/* @internal */
export function MessageSendEvent_send_tx_add_output(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_tx_add_output(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_tx_remove_input(struct LDKPublicKey node_id, struct LDKTxRemoveInput msg);
/* @internal */
export function MessageSendEvent_send_tx_remove_input(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_tx_remove_input(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_tx_remove_output(struct LDKPublicKey node_id, struct LDKTxRemoveOutput msg);
/* @internal */
export function MessageSendEvent_send_tx_remove_output(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_tx_remove_output(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_tx_complete(struct LDKPublicKey node_id, struct LDKTxComplete msg);
/* @internal */
export function MessageSendEvent_send_tx_complete(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_tx_complete(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_tx_signatures(struct LDKPublicKey node_id, struct LDKTxSignatures msg);
/* @internal */
export function MessageSendEvent_send_tx_signatures(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_tx_signatures(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_tx_init_rbf(struct LDKPublicKey node_id, struct LDKTxInitRbf msg);
/* @internal */
export function MessageSendEvent_send_tx_init_rbf(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_tx_init_rbf(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_tx_ack_rbf(struct LDKPublicKey node_id, struct LDKTxAckRbf msg);
/* @internal */
export function MessageSendEvent_send_tx_ack_rbf(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_tx_ack_rbf(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_tx_abort(struct LDKPublicKey node_id, struct LDKTxAddInput msg);
/* @internal */
export function MessageSendEvent_send_tx_abort(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_tx_abort(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_channel_ready(struct LDKPublicKey node_id, struct LDKChannelReady msg);
/* @internal */
export function MessageSendEvent_send_channel_ready(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_channel_ready(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_announcement_signatures(struct LDKPublicKey node_id, struct LDKAnnouncementSignatures msg);
/* @internal */
export function MessageSendEvent_send_announcement_signatures(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_announcement_signatures(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_update_htlcs(struct LDKPublicKey node_id, struct LDKCommitmentUpdate updates);
/* @internal */
export function MessageSendEvent_update_htlcs(node_id: number, updates: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_update_htlcs(node_id, updates);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_revoke_and_ack(struct LDKPublicKey node_id, struct LDKRevokeAndACK msg);
/* @internal */
export function MessageSendEvent_send_revoke_and_ack(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_revoke_and_ack(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_closing_signed(struct LDKPublicKey node_id, struct LDKClosingSigned msg);
/* @internal */
export function MessageSendEvent_send_closing_signed(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_closing_signed(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_shutdown(struct LDKPublicKey node_id, struct LDKShutdown msg);
/* @internal */
export function MessageSendEvent_send_shutdown(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_shutdown(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_channel_reestablish(struct LDKPublicKey node_id, struct LDKChannelReestablish msg);
/* @internal */
export function MessageSendEvent_send_channel_reestablish(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_channel_reestablish(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_channel_announcement(struct LDKPublicKey node_id, struct LDKChannelAnnouncement msg, struct LDKChannelUpdate update_msg);
/* @internal */
export function MessageSendEvent_send_channel_announcement(node_id: number, msg: bigint, update_msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_channel_announcement(node_id, msg, update_msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_broadcast_channel_announcement(struct LDKChannelAnnouncement msg, struct LDKChannelUpdate update_msg);
/* @internal */
export function MessageSendEvent_broadcast_channel_announcement(msg: bigint, update_msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_broadcast_channel_announcement(msg, update_msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_broadcast_channel_update(struct LDKChannelUpdate msg);
/* @internal */
export function MessageSendEvent_broadcast_channel_update(msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_broadcast_channel_update(msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_broadcast_node_announcement(struct LDKNodeAnnouncement msg);
/* @internal */
export function MessageSendEvent_broadcast_node_announcement(msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_broadcast_node_announcement(msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_channel_update(struct LDKPublicKey node_id, struct LDKChannelUpdate msg);
/* @internal */
export function MessageSendEvent_send_channel_update(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_channel_update(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_handle_error(struct LDKPublicKey node_id, struct LDKErrorAction action);
/* @internal */
export function MessageSendEvent_handle_error(node_id: number, action: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_handle_error(node_id, action);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_channel_range_query(struct LDKPublicKey node_id, struct LDKQueryChannelRange msg);
/* @internal */
export function MessageSendEvent_send_channel_range_query(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_channel_range_query(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_short_ids_query(struct LDKPublicKey node_id, struct LDKQueryShortChannelIds msg);
/* @internal */
export function MessageSendEvent_send_short_ids_query(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_short_ids_query(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_reply_channel_range(struct LDKPublicKey node_id, struct LDKReplyChannelRange msg);
/* @internal */
export function MessageSendEvent_send_reply_channel_range(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_reply_channel_range(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_gossip_timestamp_filter(struct LDKPublicKey node_id, struct LDKGossipTimestampFilter msg);
/* @internal */
export function MessageSendEvent_send_gossip_timestamp_filter(node_id: number, msg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_gossip_timestamp_filter(node_id, msg);
	return nativeResponseValue;
}
	// void MessageSendEventsProvider_free(struct LDKMessageSendEventsProvider this_ptr);
/* @internal */
export function MessageSendEventsProvider_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEventsProvider_free(this_ptr);
	// debug statements here
}
	// void OnionMessageProvider_free(struct LDKOnionMessageProvider this_ptr);
/* @internal */
export function OnionMessageProvider_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OnionMessageProvider_free(this_ptr);
	// debug statements here
}
	// void EventsProvider_free(struct LDKEventsProvider this_ptr);
/* @internal */
export function EventsProvider_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EventsProvider_free(this_ptr);
	// debug statements here
}
	// void EventHandler_free(struct LDKEventHandler this_ptr);
/* @internal */
export function EventHandler_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EventHandler_free(this_ptr);
	// debug statements here
}
	// void ChannelDerivationParameters_free(struct LDKChannelDerivationParameters this_obj);
/* @internal */
export function ChannelDerivationParameters_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDerivationParameters_free(this_obj);
	// debug statements here
}
	// uint64_t ChannelDerivationParameters_get_value_satoshis(const struct LDKChannelDerivationParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDerivationParameters_get_value_satoshis(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDerivationParameters_get_value_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDerivationParameters_set_value_satoshis(struct LDKChannelDerivationParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelDerivationParameters_set_value_satoshis(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDerivationParameters_set_value_satoshis(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*ChannelDerivationParameters_get_keys_id(const struct LDKChannelDerivationParameters *NONNULL_PTR this_ptr))[32];
/* @internal */
export function ChannelDerivationParameters_get_keys_id(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDerivationParameters_get_keys_id(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDerivationParameters_set_keys_id(struct LDKChannelDerivationParameters *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function ChannelDerivationParameters_set_keys_id(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDerivationParameters_set_keys_id(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelTransactionParameters ChannelDerivationParameters_get_transaction_parameters(const struct LDKChannelDerivationParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDerivationParameters_get_transaction_parameters(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDerivationParameters_get_transaction_parameters(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDerivationParameters_set_transaction_parameters(struct LDKChannelDerivationParameters *NONNULL_PTR this_ptr, struct LDKChannelTransactionParameters val);
/* @internal */
export function ChannelDerivationParameters_set_transaction_parameters(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDerivationParameters_set_transaction_parameters(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelDerivationParameters ChannelDerivationParameters_new(uint64_t value_satoshis_arg, struct LDKThirtyTwoBytes keys_id_arg, struct LDKChannelTransactionParameters transaction_parameters_arg);
/* @internal */
export function ChannelDerivationParameters_new(value_satoshis_arg: bigint, keys_id_arg: number, transaction_parameters_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDerivationParameters_new(value_satoshis_arg, keys_id_arg, transaction_parameters_arg);
	return nativeResponseValue;
}
	// uint64_t ChannelDerivationParameters_clone_ptr(LDKChannelDerivationParameters *NONNULL_PTR arg);
/* @internal */
export function ChannelDerivationParameters_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDerivationParameters_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelDerivationParameters ChannelDerivationParameters_clone(const struct LDKChannelDerivationParameters *NONNULL_PTR orig);
/* @internal */
export function ChannelDerivationParameters_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDerivationParameters_clone(orig);
	return nativeResponseValue;
}
	// bool ChannelDerivationParameters_eq(const struct LDKChannelDerivationParameters *NONNULL_PTR a, const struct LDKChannelDerivationParameters *NONNULL_PTR b);
/* @internal */
export function ChannelDerivationParameters_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDerivationParameters_eq(a, b);
	return nativeResponseValue;
}
	// void AnchorDescriptor_free(struct LDKAnchorDescriptor this_obj);
/* @internal */
export function AnchorDescriptor_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnchorDescriptor_free(this_obj);
	// debug statements here
}
	// struct LDKChannelDerivationParameters AnchorDescriptor_get_channel_derivation_parameters(const struct LDKAnchorDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function AnchorDescriptor_get_channel_derivation_parameters(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnchorDescriptor_get_channel_derivation_parameters(this_ptr);
	return nativeResponseValue;
}
	// void AnchorDescriptor_set_channel_derivation_parameters(struct LDKAnchorDescriptor *NONNULL_PTR this_ptr, struct LDKChannelDerivationParameters val);
/* @internal */
export function AnchorDescriptor_set_channel_derivation_parameters(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnchorDescriptor_set_channel_derivation_parameters(this_ptr, val);
	// debug statements here
}
	// struct LDKOutPoint AnchorDescriptor_get_outpoint(const struct LDKAnchorDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function AnchorDescriptor_get_outpoint(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnchorDescriptor_get_outpoint(this_ptr);
	return nativeResponseValue;
}
	// void AnchorDescriptor_set_outpoint(struct LDKAnchorDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */
export function AnchorDescriptor_set_outpoint(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnchorDescriptor_set_outpoint(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKAnchorDescriptor AnchorDescriptor_new(struct LDKChannelDerivationParameters channel_derivation_parameters_arg, struct LDKOutPoint outpoint_arg);
/* @internal */
export function AnchorDescriptor_new(channel_derivation_parameters_arg: bigint, outpoint_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnchorDescriptor_new(channel_derivation_parameters_arg, outpoint_arg);
	return nativeResponseValue;
}
	// uint64_t AnchorDescriptor_clone_ptr(LDKAnchorDescriptor *NONNULL_PTR arg);
/* @internal */
export function AnchorDescriptor_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnchorDescriptor_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKAnchorDescriptor AnchorDescriptor_clone(const struct LDKAnchorDescriptor *NONNULL_PTR orig);
/* @internal */
export function AnchorDescriptor_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnchorDescriptor_clone(orig);
	return nativeResponseValue;
}
	// bool AnchorDescriptor_eq(const struct LDKAnchorDescriptor *NONNULL_PTR a, const struct LDKAnchorDescriptor *NONNULL_PTR b);
/* @internal */
export function AnchorDescriptor_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnchorDescriptor_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKTxOut AnchorDescriptor_previous_utxo(const struct LDKAnchorDescriptor *NONNULL_PTR this_arg);
/* @internal */
export function AnchorDescriptor_previous_utxo(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnchorDescriptor_previous_utxo(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKTxIn AnchorDescriptor_unsigned_tx_input(const struct LDKAnchorDescriptor *NONNULL_PTR this_arg);
/* @internal */
export function AnchorDescriptor_unsigned_tx_input(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnchorDescriptor_unsigned_tx_input(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_u8Z AnchorDescriptor_witness_script(const struct LDKAnchorDescriptor *NONNULL_PTR this_arg);
/* @internal */
export function AnchorDescriptor_witness_script(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnchorDescriptor_witness_script(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKWitness AnchorDescriptor_tx_input_witness(const struct LDKAnchorDescriptor *NONNULL_PTR this_arg, struct LDKSignature signature);
/* @internal */
export function AnchorDescriptor_tx_input_witness(this_arg: bigint, signature: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnchorDescriptor_tx_input_witness(this_arg, signature);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKWriteableEcdsaChannelSigner AnchorDescriptor_derive_channel_signer(const struct LDKAnchorDescriptor *NONNULL_PTR this_arg, const struct LDKSignerProvider *NONNULL_PTR signer_provider);
/* @internal */
export function AnchorDescriptor_derive_channel_signer(this_arg: bigint, signer_provider: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnchorDescriptor_derive_channel_signer(this_arg, signer_provider);
	return nativeResponseValue;
}
	// void HTLCDescriptor_free(struct LDKHTLCDescriptor this_obj);
/* @internal */
export function HTLCDescriptor_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_free(this_obj);
	// debug statements here
}
	// struct LDKChannelDerivationParameters HTLCDescriptor_get_channel_derivation_parameters(const struct LDKHTLCDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function HTLCDescriptor_get_channel_derivation_parameters(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_get_channel_derivation_parameters(this_ptr);
	return nativeResponseValue;
}
	// void HTLCDescriptor_set_channel_derivation_parameters(struct LDKHTLCDescriptor *NONNULL_PTR this_ptr, struct LDKChannelDerivationParameters val);
/* @internal */
export function HTLCDescriptor_set_channel_derivation_parameters(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_set_channel_derivation_parameters(this_ptr, val);
	// debug statements here
}
	// uint64_t HTLCDescriptor_get_per_commitment_number(const struct LDKHTLCDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function HTLCDescriptor_get_per_commitment_number(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_get_per_commitment_number(this_ptr);
	return nativeResponseValue;
}
	// void HTLCDescriptor_set_per_commitment_number(struct LDKHTLCDescriptor *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function HTLCDescriptor_set_per_commitment_number(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_set_per_commitment_number(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey HTLCDescriptor_get_per_commitment_point(const struct LDKHTLCDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function HTLCDescriptor_get_per_commitment_point(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_get_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void HTLCDescriptor_set_per_commitment_point(struct LDKHTLCDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function HTLCDescriptor_set_per_commitment_point(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_set_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// struct LDKHTLCOutputInCommitment HTLCDescriptor_get_htlc(const struct LDKHTLCDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function HTLCDescriptor_get_htlc(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_get_htlc(this_ptr);
	return nativeResponseValue;
}
	// void HTLCDescriptor_set_htlc(struct LDKHTLCDescriptor *NONNULL_PTR this_ptr, struct LDKHTLCOutputInCommitment val);
/* @internal */
export function HTLCDescriptor_set_htlc(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_set_htlc(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_PaymentPreimageZ HTLCDescriptor_get_preimage(const struct LDKHTLCDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function HTLCDescriptor_get_preimage(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_get_preimage(this_ptr);
	return nativeResponseValue;
}
	// void HTLCDescriptor_set_preimage(struct LDKHTLCDescriptor *NONNULL_PTR this_ptr, struct LDKCOption_PaymentPreimageZ val);
/* @internal */
export function HTLCDescriptor_set_preimage(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_set_preimage(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature HTLCDescriptor_get_counterparty_sig(const struct LDKHTLCDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function HTLCDescriptor_get_counterparty_sig(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_get_counterparty_sig(this_ptr);
	return nativeResponseValue;
}
	// void HTLCDescriptor_set_counterparty_sig(struct LDKHTLCDescriptor *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function HTLCDescriptor_set_counterparty_sig(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_set_counterparty_sig(this_ptr, val);
	// debug statements here
}
	// uint64_t HTLCDescriptor_clone_ptr(LDKHTLCDescriptor *NONNULL_PTR arg);
/* @internal */
export function HTLCDescriptor_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKHTLCDescriptor HTLCDescriptor_clone(const struct LDKHTLCDescriptor *NONNULL_PTR orig);
/* @internal */
export function HTLCDescriptor_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_clone(orig);
	return nativeResponseValue;
}
	// bool HTLCDescriptor_eq(const struct LDKHTLCDescriptor *NONNULL_PTR a, const struct LDKHTLCDescriptor *NONNULL_PTR b);
/* @internal */
export function HTLCDescriptor_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKOutPoint HTLCDescriptor_outpoint(const struct LDKHTLCDescriptor *NONNULL_PTR this_arg);
/* @internal */
export function HTLCDescriptor_outpoint(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_outpoint(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKTxOut HTLCDescriptor_previous_utxo(const struct LDKHTLCDescriptor *NONNULL_PTR this_arg);
/* @internal */
export function HTLCDescriptor_previous_utxo(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_previous_utxo(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKTxIn HTLCDescriptor_unsigned_tx_input(const struct LDKHTLCDescriptor *NONNULL_PTR this_arg);
/* @internal */
export function HTLCDescriptor_unsigned_tx_input(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_unsigned_tx_input(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKTxOut HTLCDescriptor_tx_output(const struct LDKHTLCDescriptor *NONNULL_PTR this_arg);
/* @internal */
export function HTLCDescriptor_tx_output(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_tx_output(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_u8Z HTLCDescriptor_witness_script(const struct LDKHTLCDescriptor *NONNULL_PTR this_arg);
/* @internal */
export function HTLCDescriptor_witness_script(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_witness_script(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKWitness HTLCDescriptor_tx_input_witness(const struct LDKHTLCDescriptor *NONNULL_PTR this_arg, struct LDKSignature signature, struct LDKu8slice witness_script);
/* @internal */
export function HTLCDescriptor_tx_input_witness(this_arg: bigint, signature: number, witness_script: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_tx_input_witness(this_arg, signature, witness_script);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKWriteableEcdsaChannelSigner HTLCDescriptor_derive_channel_signer(const struct LDKHTLCDescriptor *NONNULL_PTR this_arg, const struct LDKSignerProvider *NONNULL_PTR signer_provider);
/* @internal */
export function HTLCDescriptor_derive_channel_signer(this_arg: bigint, signer_provider: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCDescriptor_derive_channel_signer(this_arg, signer_provider);
	return nativeResponseValue;
}
	// void BumpTransactionEvent_free(struct LDKBumpTransactionEvent this_ptr);
/* @internal */
export function BumpTransactionEvent_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BumpTransactionEvent_free(this_ptr);
	// debug statements here
}
	// uint64_t BumpTransactionEvent_clone_ptr(LDKBumpTransactionEvent *NONNULL_PTR arg);
/* @internal */
export function BumpTransactionEvent_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BumpTransactionEvent_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBumpTransactionEvent BumpTransactionEvent_clone(const struct LDKBumpTransactionEvent *NONNULL_PTR orig);
/* @internal */
export function BumpTransactionEvent_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BumpTransactionEvent_clone(orig);
	return nativeResponseValue;
}
	// struct LDKBumpTransactionEvent BumpTransactionEvent_channel_close(struct LDKThirtyTwoBytes claim_id, uint32_t package_target_feerate_sat_per_1000_weight, struct LDKTransaction commitment_tx, uint64_t commitment_tx_fee_satoshis, struct LDKAnchorDescriptor anchor_descriptor, struct LDKCVec_HTLCOutputInCommitmentZ pending_htlcs);
/* @internal */
export function BumpTransactionEvent_channel_close(claim_id: number, package_target_feerate_sat_per_1000_weight: number, commitment_tx: number, commitment_tx_fee_satoshis: bigint, anchor_descriptor: bigint, pending_htlcs: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BumpTransactionEvent_channel_close(claim_id, package_target_feerate_sat_per_1000_weight, commitment_tx, commitment_tx_fee_satoshis, anchor_descriptor, pending_htlcs);
	return nativeResponseValue;
}
	// struct LDKBumpTransactionEvent BumpTransactionEvent_htlcresolution(struct LDKThirtyTwoBytes claim_id, uint32_t target_feerate_sat_per_1000_weight, struct LDKCVec_HTLCDescriptorZ htlc_descriptors, uint32_t tx_lock_time);
/* @internal */
export function BumpTransactionEvent_htlcresolution(claim_id: number, target_feerate_sat_per_1000_weight: number, htlc_descriptors: number, tx_lock_time: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BumpTransactionEvent_htlcresolution(claim_id, target_feerate_sat_per_1000_weight, htlc_descriptors, tx_lock_time);
	return nativeResponseValue;
}
	// bool BumpTransactionEvent_eq(const struct LDKBumpTransactionEvent *NONNULL_PTR a, const struct LDKBumpTransactionEvent *NONNULL_PTR b);
/* @internal */
export function BumpTransactionEvent_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BumpTransactionEvent_eq(a, b);
	return nativeResponseValue;
}
	// void Input_free(struct LDKInput this_obj);
/* @internal */
export function Input_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Input_free(this_obj);
	// debug statements here
}
	// struct LDKOutPoint Input_get_outpoint(const struct LDKInput *NONNULL_PTR this_ptr);
/* @internal */
export function Input_get_outpoint(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Input_get_outpoint(this_ptr);
	return nativeResponseValue;
}
	// void Input_set_outpoint(struct LDKInput *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */
export function Input_set_outpoint(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Input_set_outpoint(this_ptr, val);
	// debug statements here
}
	// struct LDKTxOut Input_get_previous_utxo(const struct LDKInput *NONNULL_PTR this_ptr);
/* @internal */
export function Input_get_previous_utxo(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Input_get_previous_utxo(this_ptr);
	return nativeResponseValue;
}
	// void Input_set_previous_utxo(struct LDKInput *NONNULL_PTR this_ptr, struct LDKTxOut val);
/* @internal */
export function Input_set_previous_utxo(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Input_set_previous_utxo(this_ptr, val);
	// debug statements here
}
	// uint64_t Input_get_satisfaction_weight(const struct LDKInput *NONNULL_PTR this_ptr);
/* @internal */
export function Input_get_satisfaction_weight(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Input_get_satisfaction_weight(this_ptr);
	return nativeResponseValue;
}
	// void Input_set_satisfaction_weight(struct LDKInput *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function Input_set_satisfaction_weight(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Input_set_satisfaction_weight(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKInput Input_new(struct LDKOutPoint outpoint_arg, struct LDKTxOut previous_utxo_arg, uint64_t satisfaction_weight_arg);
/* @internal */
export function Input_new(outpoint_arg: bigint, previous_utxo_arg: bigint, satisfaction_weight_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Input_new(outpoint_arg, previous_utxo_arg, satisfaction_weight_arg);
	return nativeResponseValue;
}
	// uint64_t Input_clone_ptr(LDKInput *NONNULL_PTR arg);
/* @internal */
export function Input_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Input_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKInput Input_clone(const struct LDKInput *NONNULL_PTR orig);
/* @internal */
export function Input_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Input_clone(orig);
	return nativeResponseValue;
}
	// uint64_t Input_hash(const struct LDKInput *NONNULL_PTR o);
/* @internal */
export function Input_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Input_hash(o);
	return nativeResponseValue;
}
	// bool Input_eq(const struct LDKInput *NONNULL_PTR a, const struct LDKInput *NONNULL_PTR b);
/* @internal */
export function Input_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Input_eq(a, b);
	return nativeResponseValue;
}
	// void Utxo_free(struct LDKUtxo this_obj);
/* @internal */
export function Utxo_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Utxo_free(this_obj);
	// debug statements here
}
	// struct LDKOutPoint Utxo_get_outpoint(const struct LDKUtxo *NONNULL_PTR this_ptr);
/* @internal */
export function Utxo_get_outpoint(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Utxo_get_outpoint(this_ptr);
	return nativeResponseValue;
}
	// void Utxo_set_outpoint(struct LDKUtxo *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */
export function Utxo_set_outpoint(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Utxo_set_outpoint(this_ptr, val);
	// debug statements here
}
	// struct LDKTxOut Utxo_get_output(const struct LDKUtxo *NONNULL_PTR this_ptr);
/* @internal */
export function Utxo_get_output(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Utxo_get_output(this_ptr);
	return nativeResponseValue;
}
	// void Utxo_set_output(struct LDKUtxo *NONNULL_PTR this_ptr, struct LDKTxOut val);
/* @internal */
export function Utxo_set_output(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Utxo_set_output(this_ptr, val);
	// debug statements here
}
	// uint64_t Utxo_get_satisfaction_weight(const struct LDKUtxo *NONNULL_PTR this_ptr);
/* @internal */
export function Utxo_get_satisfaction_weight(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Utxo_get_satisfaction_weight(this_ptr);
	return nativeResponseValue;
}
	// void Utxo_set_satisfaction_weight(struct LDKUtxo *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function Utxo_set_satisfaction_weight(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Utxo_set_satisfaction_weight(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKUtxo Utxo_new(struct LDKOutPoint outpoint_arg, struct LDKTxOut output_arg, uint64_t satisfaction_weight_arg);
/* @internal */
export function Utxo_new(outpoint_arg: bigint, output_arg: bigint, satisfaction_weight_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Utxo_new(outpoint_arg, output_arg, satisfaction_weight_arg);
	return nativeResponseValue;
}
	// uint64_t Utxo_clone_ptr(LDKUtxo *NONNULL_PTR arg);
/* @internal */
export function Utxo_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Utxo_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUtxo Utxo_clone(const struct LDKUtxo *NONNULL_PTR orig);
/* @internal */
export function Utxo_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Utxo_clone(orig);
	return nativeResponseValue;
}
	// uint64_t Utxo_hash(const struct LDKUtxo *NONNULL_PTR o);
/* @internal */
export function Utxo_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Utxo_hash(o);
	return nativeResponseValue;
}
	// bool Utxo_eq(const struct LDKUtxo *NONNULL_PTR a, const struct LDKUtxo *NONNULL_PTR b);
/* @internal */
export function Utxo_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Utxo_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKUtxo Utxo_new_p2pkh(struct LDKOutPoint outpoint, uint64_t value, const uint8_t (*pubkey_hash)[20]);
/* @internal */
export function Utxo_new_p2pkh(outpoint: bigint, value: bigint, pubkey_hash: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Utxo_new_p2pkh(outpoint, value, pubkey_hash);
	return nativeResponseValue;
}
	// void CoinSelection_free(struct LDKCoinSelection this_obj);
/* @internal */
export function CoinSelection_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CoinSelection_free(this_obj);
	// debug statements here
}
	// struct LDKCVec_UtxoZ CoinSelection_get_confirmed_utxos(const struct LDKCoinSelection *NONNULL_PTR this_ptr);
/* @internal */
export function CoinSelection_get_confirmed_utxos(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CoinSelection_get_confirmed_utxos(this_ptr);
	return nativeResponseValue;
}
	// void CoinSelection_set_confirmed_utxos(struct LDKCoinSelection *NONNULL_PTR this_ptr, struct LDKCVec_UtxoZ val);
/* @internal */
export function CoinSelection_set_confirmed_utxos(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CoinSelection_set_confirmed_utxos(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_TxOutZ CoinSelection_get_change_output(const struct LDKCoinSelection *NONNULL_PTR this_ptr);
/* @internal */
export function CoinSelection_get_change_output(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CoinSelection_get_change_output(this_ptr);
	return nativeResponseValue;
}
	// void CoinSelection_set_change_output(struct LDKCoinSelection *NONNULL_PTR this_ptr, struct LDKCOption_TxOutZ val);
/* @internal */
export function CoinSelection_set_change_output(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CoinSelection_set_change_output(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKCoinSelection CoinSelection_new(struct LDKCVec_UtxoZ confirmed_utxos_arg, struct LDKCOption_TxOutZ change_output_arg);
/* @internal */
export function CoinSelection_new(confirmed_utxos_arg: number, change_output_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CoinSelection_new(confirmed_utxos_arg, change_output_arg);
	return nativeResponseValue;
}
	// uint64_t CoinSelection_clone_ptr(LDKCoinSelection *NONNULL_PTR arg);
/* @internal */
export function CoinSelection_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CoinSelection_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCoinSelection CoinSelection_clone(const struct LDKCoinSelection *NONNULL_PTR orig);
/* @internal */
export function CoinSelection_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CoinSelection_clone(orig);
	return nativeResponseValue;
}
	// void CoinSelectionSource_free(struct LDKCoinSelectionSource this_ptr);
/* @internal */
export function CoinSelectionSource_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CoinSelectionSource_free(this_ptr);
	// debug statements here
}
	// void WalletSource_free(struct LDKWalletSource this_ptr);
/* @internal */
export function WalletSource_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WalletSource_free(this_ptr);
	// debug statements here
}
	// void Wallet_free(struct LDKWallet this_obj);
/* @internal */
export function Wallet_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Wallet_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKWallet Wallet_new(struct LDKWalletSource source, struct LDKLogger logger);
/* @internal */
export function Wallet_new(source: bigint, logger: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Wallet_new(source, logger);
	return nativeResponseValue;
}
	// struct LDKCoinSelectionSource Wallet_as_CoinSelectionSource(const struct LDKWallet *NONNULL_PTR this_arg);
/* @internal */
export function Wallet_as_CoinSelectionSource(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Wallet_as_CoinSelectionSource(this_arg);
	return nativeResponseValue;
}
	// void BumpTransactionEventHandler_free(struct LDKBumpTransactionEventHandler this_obj);
/* @internal */
export function BumpTransactionEventHandler_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BumpTransactionEventHandler_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKBumpTransactionEventHandler BumpTransactionEventHandler_new(struct LDKBroadcasterInterface broadcaster, struct LDKCoinSelectionSource utxo_source, struct LDKSignerProvider signer_provider, struct LDKLogger logger);
/* @internal */
export function BumpTransactionEventHandler_new(broadcaster: bigint, utxo_source: bigint, signer_provider: bigint, logger: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BumpTransactionEventHandler_new(broadcaster, utxo_source, signer_provider, logger);
	return nativeResponseValue;
}
	// void BumpTransactionEventHandler_handle_event(const struct LDKBumpTransactionEventHandler *NONNULL_PTR this_arg, const struct LDKBumpTransactionEvent *NONNULL_PTR event);
/* @internal */
export function BumpTransactionEventHandler_handle_event(this_arg: bigint, event: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BumpTransactionEventHandler_handle_event(this_arg, event);
	// debug statements here
}
	// void GossipSync_free(struct LDKGossipSync this_ptr);
/* @internal */
export function GossipSync_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipSync_free(this_ptr);
	// debug statements here
}
	// struct LDKGossipSync GossipSync_p2_p(const struct LDKP2PGossipSync *NONNULL_PTR a);
/* @internal */
export function GossipSync_p2_p(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipSync_p2_p(a);
	return nativeResponseValue;
}
	// struct LDKGossipSync GossipSync_rapid(const struct LDKRapidGossipSync *NONNULL_PTR a);
/* @internal */
export function GossipSync_rapid(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipSync_rapid(a);
	return nativeResponseValue;
}
	// struct LDKGossipSync GossipSync_none(void);
/* @internal */
export function GossipSync_none(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipSync_none();
	return nativeResponseValue;
}
	// void RapidGossipSync_free(struct LDKRapidGossipSync this_obj);
/* @internal */
export function RapidGossipSync_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RapidGossipSync_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKRapidGossipSync RapidGossipSync_new(const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKLogger logger);
/* @internal */
export function RapidGossipSync_new(network_graph: bigint, logger: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RapidGossipSync_new(network_graph, logger);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_u32GraphSyncErrorZ RapidGossipSync_update_network_graph_no_std(const struct LDKRapidGossipSync *NONNULL_PTR this_arg, struct LDKu8slice update_data, struct LDKCOption_u64Z current_time_unix);
/* @internal */
export function RapidGossipSync_update_network_graph_no_std(this_arg: bigint, update_data: number, current_time_unix: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RapidGossipSync_update_network_graph_no_std(this_arg, update_data, current_time_unix);
	return nativeResponseValue;
}
	// MUST_USE_RES bool RapidGossipSync_is_initial_sync_complete(const struct LDKRapidGossipSync *NONNULL_PTR this_arg);
/* @internal */
export function RapidGossipSync_is_initial_sync_complete(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RapidGossipSync_is_initial_sync_complete(this_arg);
	return nativeResponseValue;
}
	// void GraphSyncError_free(struct LDKGraphSyncError this_ptr);
/* @internal */
export function GraphSyncError_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GraphSyncError_free(this_ptr);
	// debug statements here
}
	// uint64_t GraphSyncError_clone_ptr(LDKGraphSyncError *NONNULL_PTR arg);
/* @internal */
export function GraphSyncError_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GraphSyncError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKGraphSyncError GraphSyncError_clone(const struct LDKGraphSyncError *NONNULL_PTR orig);
/* @internal */
export function GraphSyncError_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GraphSyncError_clone(orig);
	return nativeResponseValue;
}
	// struct LDKGraphSyncError GraphSyncError_decode_error(struct LDKDecodeError a);
/* @internal */
export function GraphSyncError_decode_error(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GraphSyncError_decode_error(a);
	return nativeResponseValue;
}
	// struct LDKGraphSyncError GraphSyncError_lightning_error(struct LDKLightningError a);
/* @internal */
export function GraphSyncError_lightning_error(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GraphSyncError_lightning_error(a);
	return nativeResponseValue;
}
	// void Bolt11ParseError_free(struct LDKBolt11ParseError this_ptr);
/* @internal */
export function Bolt11ParseError_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_free(this_ptr);
	// debug statements here
}
	// uint64_t Bolt11ParseError_clone_ptr(LDKBolt11ParseError *NONNULL_PTR arg);
/* @internal */
export function Bolt11ParseError_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_clone(const struct LDKBolt11ParseError *NONNULL_PTR orig);
/* @internal */
export function Bolt11ParseError_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_clone(orig);
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_bech32_error(struct LDKBech32Error a);
/* @internal */
export function Bolt11ParseError_bech32_error(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_bech32_error(a);
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_parse_amount_error(struct LDKError a);
/* @internal */
export function Bolt11ParseError_parse_amount_error(a: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_parse_amount_error(a);
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_malformed_signature(enum LDKSecp256k1Error a);
/* @internal */
export function Bolt11ParseError_malformed_signature(a: Secp256k1Error): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_malformed_signature(a);
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_bad_prefix(void);
/* @internal */
export function Bolt11ParseError_bad_prefix(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_bad_prefix();
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_unknown_currency(void);
/* @internal */
export function Bolt11ParseError_unknown_currency(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_unknown_currency();
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_unknown_si_prefix(void);
/* @internal */
export function Bolt11ParseError_unknown_si_prefix(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_unknown_si_prefix();
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_malformed_hrp(void);
/* @internal */
export function Bolt11ParseError_malformed_hrp(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_malformed_hrp();
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_too_short_data_part(void);
/* @internal */
export function Bolt11ParseError_too_short_data_part(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_too_short_data_part();
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_unexpected_end_of_tagged_fields(void);
/* @internal */
export function Bolt11ParseError_unexpected_end_of_tagged_fields(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_unexpected_end_of_tagged_fields();
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_description_decode_error(struct LDKError a);
/* @internal */
export function Bolt11ParseError_description_decode_error(a: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_description_decode_error(a);
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_padding_error(void);
/* @internal */
export function Bolt11ParseError_padding_error(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_padding_error();
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_integer_overflow_error(void);
/* @internal */
export function Bolt11ParseError_integer_overflow_error(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_integer_overflow_error();
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_invalid_seg_wit_program_length(void);
/* @internal */
export function Bolt11ParseError_invalid_seg_wit_program_length(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_invalid_seg_wit_program_length();
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_invalid_pub_key_hash_length(void);
/* @internal */
export function Bolt11ParseError_invalid_pub_key_hash_length(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_invalid_pub_key_hash_length();
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_invalid_script_hash_length(void);
/* @internal */
export function Bolt11ParseError_invalid_script_hash_length(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_invalid_script_hash_length();
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_invalid_recovery_id(void);
/* @internal */
export function Bolt11ParseError_invalid_recovery_id(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_invalid_recovery_id();
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_invalid_slice_length(struct LDKStr a);
/* @internal */
export function Bolt11ParseError_invalid_slice_length(a: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_invalid_slice_length(a);
	return nativeResponseValue;
}
	// struct LDKBolt11ParseError Bolt11ParseError_skip(void);
/* @internal */
export function Bolt11ParseError_skip(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_skip();
	return nativeResponseValue;
}
	// bool Bolt11ParseError_eq(const struct LDKBolt11ParseError *NONNULL_PTR a, const struct LDKBolt11ParseError *NONNULL_PTR b);
/* @internal */
export function Bolt11ParseError_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_eq(a, b);
	return nativeResponseValue;
}
	// void ParseOrSemanticError_free(struct LDKParseOrSemanticError this_ptr);
/* @internal */
export function ParseOrSemanticError_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseOrSemanticError_free(this_ptr);
	// debug statements here
}
	// uint64_t ParseOrSemanticError_clone_ptr(LDKParseOrSemanticError *NONNULL_PTR arg);
/* @internal */
export function ParseOrSemanticError_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseOrSemanticError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKParseOrSemanticError ParseOrSemanticError_clone(const struct LDKParseOrSemanticError *NONNULL_PTR orig);
/* @internal */
export function ParseOrSemanticError_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseOrSemanticError_clone(orig);
	return nativeResponseValue;
}
	// struct LDKParseOrSemanticError ParseOrSemanticError_parse_error(struct LDKBolt11ParseError a);
/* @internal */
export function ParseOrSemanticError_parse_error(a: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseOrSemanticError_parse_error(a);
	return nativeResponseValue;
}
	// struct LDKParseOrSemanticError ParseOrSemanticError_semantic_error(enum LDKBolt11SemanticError a);
/* @internal */
export function ParseOrSemanticError_semantic_error(a: Bolt11SemanticError): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseOrSemanticError_semantic_error(a);
	return nativeResponseValue;
}
	// bool ParseOrSemanticError_eq(const struct LDKParseOrSemanticError *NONNULL_PTR a, const struct LDKParseOrSemanticError *NONNULL_PTR b);
/* @internal */
export function ParseOrSemanticError_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseOrSemanticError_eq(a, b);
	return nativeResponseValue;
}
	// void Bolt11Invoice_free(struct LDKBolt11Invoice this_obj);
/* @internal */
export function Bolt11Invoice_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_free(this_obj);
	// debug statements here
}
	// bool Bolt11Invoice_eq(const struct LDKBolt11Invoice *NONNULL_PTR a, const struct LDKBolt11Invoice *NONNULL_PTR b);
/* @internal */
export function Bolt11Invoice_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_eq(a, b);
	return nativeResponseValue;
}
	// uint64_t Bolt11Invoice_clone_ptr(LDKBolt11Invoice *NONNULL_PTR arg);
/* @internal */
export function Bolt11Invoice_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBolt11Invoice Bolt11Invoice_clone(const struct LDKBolt11Invoice *NONNULL_PTR orig);
/* @internal */
export function Bolt11Invoice_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_clone(orig);
	return nativeResponseValue;
}
	// uint64_t Bolt11Invoice_hash(const struct LDKBolt11Invoice *NONNULL_PTR o);
/* @internal */
export function Bolt11Invoice_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_hash(o);
	return nativeResponseValue;
}
	// void SignedRawBolt11Invoice_free(struct LDKSignedRawBolt11Invoice this_obj);
/* @internal */
export function SignedRawBolt11Invoice_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawBolt11Invoice_free(this_obj);
	// debug statements here
}
	// bool SignedRawBolt11Invoice_eq(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR a, const struct LDKSignedRawBolt11Invoice *NONNULL_PTR b);
/* @internal */
export function SignedRawBolt11Invoice_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawBolt11Invoice_eq(a, b);
	return nativeResponseValue;
}
	// uint64_t SignedRawBolt11Invoice_clone_ptr(LDKSignedRawBolt11Invoice *NONNULL_PTR arg);
/* @internal */
export function SignedRawBolt11Invoice_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawBolt11Invoice_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKSignedRawBolt11Invoice SignedRawBolt11Invoice_clone(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR orig);
/* @internal */
export function SignedRawBolt11Invoice_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawBolt11Invoice_clone(orig);
	return nativeResponseValue;
}
	// uint64_t SignedRawBolt11Invoice_hash(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR o);
/* @internal */
export function SignedRawBolt11Invoice_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawBolt11Invoice_hash(o);
	return nativeResponseValue;
}
	// void RawBolt11Invoice_free(struct LDKRawBolt11Invoice this_obj);
/* @internal */
export function RawBolt11Invoice_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_free(this_obj);
	// debug statements here
}
	// struct LDKRawDataPart RawBolt11Invoice_get_data(const struct LDKRawBolt11Invoice *NONNULL_PTR this_ptr);
/* @internal */
export function RawBolt11Invoice_get_data(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_get_data(this_ptr);
	return nativeResponseValue;
}
	// void RawBolt11Invoice_set_data(struct LDKRawBolt11Invoice *NONNULL_PTR this_ptr, struct LDKRawDataPart val);
/* @internal */
export function RawBolt11Invoice_set_data(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_set_data(this_ptr, val);
	// debug statements here
}
	// bool RawBolt11Invoice_eq(const struct LDKRawBolt11Invoice *NONNULL_PTR a, const struct LDKRawBolt11Invoice *NONNULL_PTR b);
/* @internal */
export function RawBolt11Invoice_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_eq(a, b);
	return nativeResponseValue;
}
	// uint64_t RawBolt11Invoice_clone_ptr(LDKRawBolt11Invoice *NONNULL_PTR arg);
/* @internal */
export function RawBolt11Invoice_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRawBolt11Invoice RawBolt11Invoice_clone(const struct LDKRawBolt11Invoice *NONNULL_PTR orig);
/* @internal */
export function RawBolt11Invoice_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_clone(orig);
	return nativeResponseValue;
}
	// uint64_t RawBolt11Invoice_hash(const struct LDKRawBolt11Invoice *NONNULL_PTR o);
/* @internal */
export function RawBolt11Invoice_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_hash(o);
	return nativeResponseValue;
}
	// void RawDataPart_free(struct LDKRawDataPart this_obj);
/* @internal */
export function RawDataPart_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawDataPart_free(this_obj);
	// debug statements here
}
	// struct LDKPositiveTimestamp RawDataPart_get_timestamp(const struct LDKRawDataPart *NONNULL_PTR this_ptr);
/* @internal */
export function RawDataPart_get_timestamp(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawDataPart_get_timestamp(this_ptr);
	return nativeResponseValue;
}
	// void RawDataPart_set_timestamp(struct LDKRawDataPart *NONNULL_PTR this_ptr, struct LDKPositiveTimestamp val);
/* @internal */
export function RawDataPart_set_timestamp(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawDataPart_set_timestamp(this_ptr, val);
	// debug statements here
}
	// bool RawDataPart_eq(const struct LDKRawDataPart *NONNULL_PTR a, const struct LDKRawDataPart *NONNULL_PTR b);
/* @internal */
export function RawDataPart_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawDataPart_eq(a, b);
	return nativeResponseValue;
}
	// uint64_t RawDataPart_clone_ptr(LDKRawDataPart *NONNULL_PTR arg);
/* @internal */
export function RawDataPart_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawDataPart_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRawDataPart RawDataPart_clone(const struct LDKRawDataPart *NONNULL_PTR orig);
/* @internal */
export function RawDataPart_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawDataPart_clone(orig);
	return nativeResponseValue;
}
	// uint64_t RawDataPart_hash(const struct LDKRawDataPart *NONNULL_PTR o);
/* @internal */
export function RawDataPart_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawDataPart_hash(o);
	return nativeResponseValue;
}
	// void PositiveTimestamp_free(struct LDKPositiveTimestamp this_obj);
/* @internal */
export function PositiveTimestamp_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PositiveTimestamp_free(this_obj);
	// debug statements here
}
	// bool PositiveTimestamp_eq(const struct LDKPositiveTimestamp *NONNULL_PTR a, const struct LDKPositiveTimestamp *NONNULL_PTR b);
/* @internal */
export function PositiveTimestamp_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PositiveTimestamp_eq(a, b);
	return nativeResponseValue;
}
	// uint64_t PositiveTimestamp_clone_ptr(LDKPositiveTimestamp *NONNULL_PTR arg);
/* @internal */
export function PositiveTimestamp_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PositiveTimestamp_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPositiveTimestamp PositiveTimestamp_clone(const struct LDKPositiveTimestamp *NONNULL_PTR orig);
/* @internal */
export function PositiveTimestamp_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PositiveTimestamp_clone(orig);
	return nativeResponseValue;
}
	// uint64_t PositiveTimestamp_hash(const struct LDKPositiveTimestamp *NONNULL_PTR o);
/* @internal */
export function PositiveTimestamp_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PositiveTimestamp_hash(o);
	return nativeResponseValue;
}
	// enum LDKSiPrefix SiPrefix_clone(const enum LDKSiPrefix *NONNULL_PTR orig);
/* @internal */
export function SiPrefix_clone(orig: bigint): SiPrefix {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_clone(orig);
	return nativeResponseValue;
}
	// enum LDKSiPrefix SiPrefix_milli(void);
/* @internal */
export function SiPrefix_milli(): SiPrefix {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_milli();
	return nativeResponseValue;
}
	// enum LDKSiPrefix SiPrefix_micro(void);
/* @internal */
export function SiPrefix_micro(): SiPrefix {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_micro();
	return nativeResponseValue;
}
	// enum LDKSiPrefix SiPrefix_nano(void);
/* @internal */
export function SiPrefix_nano(): SiPrefix {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_nano();
	return nativeResponseValue;
}
	// enum LDKSiPrefix SiPrefix_pico(void);
/* @internal */
export function SiPrefix_pico(): SiPrefix {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_pico();
	return nativeResponseValue;
}
	// bool SiPrefix_eq(const enum LDKSiPrefix *NONNULL_PTR a, const enum LDKSiPrefix *NONNULL_PTR b);
/* @internal */
export function SiPrefix_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_eq(a, b);
	return nativeResponseValue;
}
	// uint64_t SiPrefix_hash(const enum LDKSiPrefix *NONNULL_PTR o);
/* @internal */
export function SiPrefix_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_hash(o);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t SiPrefix_multiplier(const enum LDKSiPrefix *NONNULL_PTR this_arg);
/* @internal */
export function SiPrefix_multiplier(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_multiplier(this_arg);
	return nativeResponseValue;
}
	// enum LDKCurrency Currency_clone(const enum LDKCurrency *NONNULL_PTR orig);
/* @internal */
export function Currency_clone(orig: bigint): Currency {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_clone(orig);
	return nativeResponseValue;
}
	// enum LDKCurrency Currency_bitcoin(void);
/* @internal */
export function Currency_bitcoin(): Currency {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_bitcoin();
	return nativeResponseValue;
}
	// enum LDKCurrency Currency_bitcoin_testnet(void);
/* @internal */
export function Currency_bitcoin_testnet(): Currency {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_bitcoin_testnet();
	return nativeResponseValue;
}
	// enum LDKCurrency Currency_regtest(void);
/* @internal */
export function Currency_regtest(): Currency {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_regtest();
	return nativeResponseValue;
}
	// enum LDKCurrency Currency_simnet(void);
/* @internal */
export function Currency_simnet(): Currency {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_simnet();
	return nativeResponseValue;
}
	// enum LDKCurrency Currency_signet(void);
/* @internal */
export function Currency_signet(): Currency {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_signet();
	return nativeResponseValue;
}
	// uint64_t Currency_hash(const enum LDKCurrency *NONNULL_PTR o);
/* @internal */
export function Currency_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_hash(o);
	return nativeResponseValue;
}
	// bool Currency_eq(const enum LDKCurrency *NONNULL_PTR a, const enum LDKCurrency *NONNULL_PTR b);
/* @internal */
export function Currency_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_eq(a, b);
	return nativeResponseValue;
}
	// void Sha256_free(struct LDKSha256 this_obj);
/* @internal */
export function Sha256_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Sha256_free(this_obj);
	// debug statements here
}
	// uint64_t Sha256_clone_ptr(LDKSha256 *NONNULL_PTR arg);
/* @internal */
export function Sha256_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Sha256_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKSha256 Sha256_clone(const struct LDKSha256 *NONNULL_PTR orig);
/* @internal */
export function Sha256_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Sha256_clone(orig);
	return nativeResponseValue;
}
	// uint64_t Sha256_hash(const struct LDKSha256 *NONNULL_PTR o);
/* @internal */
export function Sha256_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Sha256_hash(o);
	return nativeResponseValue;
}
	// bool Sha256_eq(const struct LDKSha256 *NONNULL_PTR a, const struct LDKSha256 *NONNULL_PTR b);
/* @internal */
export function Sha256_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Sha256_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKSha256 Sha256_from_bytes(const uint8_t (*bytes)[32]);
/* @internal */
export function Sha256_from_bytes(bytes: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Sha256_from_bytes(bytes);
	return nativeResponseValue;
}
	// void Description_free(struct LDKDescription this_obj);
/* @internal */
export function Description_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Description_free(this_obj);
	// debug statements here
}
	// uint64_t Description_clone_ptr(LDKDescription *NONNULL_PTR arg);
/* @internal */
export function Description_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Description_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKDescription Description_clone(const struct LDKDescription *NONNULL_PTR orig);
/* @internal */
export function Description_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Description_clone(orig);
	return nativeResponseValue;
}
	// uint64_t Description_hash(const struct LDKDescription *NONNULL_PTR o);
/* @internal */
export function Description_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Description_hash(o);
	return nativeResponseValue;
}
	// bool Description_eq(const struct LDKDescription *NONNULL_PTR a, const struct LDKDescription *NONNULL_PTR b);
/* @internal */
export function Description_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Description_eq(a, b);
	return nativeResponseValue;
}
	// void PayeePubKey_free(struct LDKPayeePubKey this_obj);
/* @internal */
export function PayeePubKey_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PayeePubKey_free(this_obj);
	// debug statements here
}
	// struct LDKPublicKey PayeePubKey_get_a(const struct LDKPayeePubKey *NONNULL_PTR this_ptr);
/* @internal */
export function PayeePubKey_get_a(this_ptr: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PayeePubKey_get_a(this_ptr);
	return nativeResponseValue;
}
	// void PayeePubKey_set_a(struct LDKPayeePubKey *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function PayeePubKey_set_a(this_ptr: bigint, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PayeePubKey_set_a(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKPayeePubKey PayeePubKey_new(struct LDKPublicKey a_arg);
/* @internal */
export function PayeePubKey_new(a_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PayeePubKey_new(a_arg);
	return nativeResponseValue;
}
	// uint64_t PayeePubKey_clone_ptr(LDKPayeePubKey *NONNULL_PTR arg);
/* @internal */
export function PayeePubKey_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PayeePubKey_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPayeePubKey PayeePubKey_clone(const struct LDKPayeePubKey *NONNULL_PTR orig);
/* @internal */
export function PayeePubKey_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PayeePubKey_clone(orig);
	return nativeResponseValue;
}
	// uint64_t PayeePubKey_hash(const struct LDKPayeePubKey *NONNULL_PTR o);
/* @internal */
export function PayeePubKey_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PayeePubKey_hash(o);
	return nativeResponseValue;
}
	// bool PayeePubKey_eq(const struct LDKPayeePubKey *NONNULL_PTR a, const struct LDKPayeePubKey *NONNULL_PTR b);
/* @internal */
export function PayeePubKey_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PayeePubKey_eq(a, b);
	return nativeResponseValue;
}
	// void ExpiryTime_free(struct LDKExpiryTime this_obj);
/* @internal */
export function ExpiryTime_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_free(this_obj);
	// debug statements here
}
	// uint64_t ExpiryTime_clone_ptr(LDKExpiryTime *NONNULL_PTR arg);
/* @internal */
export function ExpiryTime_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKExpiryTime ExpiryTime_clone(const struct LDKExpiryTime *NONNULL_PTR orig);
/* @internal */
export function ExpiryTime_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_clone(orig);
	return nativeResponseValue;
}
	// uint64_t ExpiryTime_hash(const struct LDKExpiryTime *NONNULL_PTR o);
/* @internal */
export function ExpiryTime_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_hash(o);
	return nativeResponseValue;
}
	// bool ExpiryTime_eq(const struct LDKExpiryTime *NONNULL_PTR a, const struct LDKExpiryTime *NONNULL_PTR b);
/* @internal */
export function ExpiryTime_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_eq(a, b);
	return nativeResponseValue;
}
	// void MinFinalCltvExpiryDelta_free(struct LDKMinFinalCltvExpiryDelta this_obj);
/* @internal */
export function MinFinalCltvExpiryDelta_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MinFinalCltvExpiryDelta_free(this_obj);
	// debug statements here
}
	// uint64_t MinFinalCltvExpiryDelta_get_a(const struct LDKMinFinalCltvExpiryDelta *NONNULL_PTR this_ptr);
/* @internal */
export function MinFinalCltvExpiryDelta_get_a(this_ptr: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MinFinalCltvExpiryDelta_get_a(this_ptr);
	return nativeResponseValue;
}
	// void MinFinalCltvExpiryDelta_set_a(struct LDKMinFinalCltvExpiryDelta *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function MinFinalCltvExpiryDelta_set_a(this_ptr: bigint, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MinFinalCltvExpiryDelta_set_a(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKMinFinalCltvExpiryDelta MinFinalCltvExpiryDelta_new(uint64_t a_arg);
/* @internal */
export function MinFinalCltvExpiryDelta_new(a_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MinFinalCltvExpiryDelta_new(a_arg);
	return nativeResponseValue;
}
	// uint64_t MinFinalCltvExpiryDelta_clone_ptr(LDKMinFinalCltvExpiryDelta *NONNULL_PTR arg);
/* @internal */
export function MinFinalCltvExpiryDelta_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MinFinalCltvExpiryDelta_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKMinFinalCltvExpiryDelta MinFinalCltvExpiryDelta_clone(const struct LDKMinFinalCltvExpiryDelta *NONNULL_PTR orig);
/* @internal */
export function MinFinalCltvExpiryDelta_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MinFinalCltvExpiryDelta_clone(orig);
	return nativeResponseValue;
}
	// uint64_t MinFinalCltvExpiryDelta_hash(const struct LDKMinFinalCltvExpiryDelta *NONNULL_PTR o);
/* @internal */
export function MinFinalCltvExpiryDelta_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MinFinalCltvExpiryDelta_hash(o);
	return nativeResponseValue;
}
	// bool MinFinalCltvExpiryDelta_eq(const struct LDKMinFinalCltvExpiryDelta *NONNULL_PTR a, const struct LDKMinFinalCltvExpiryDelta *NONNULL_PTR b);
/* @internal */
export function MinFinalCltvExpiryDelta_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MinFinalCltvExpiryDelta_eq(a, b);
	return nativeResponseValue;
}
	// void Fallback_free(struct LDKFallback this_ptr);
/* @internal */
export function Fallback_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Fallback_free(this_ptr);
	// debug statements here
}
	// uint64_t Fallback_clone_ptr(LDKFallback *NONNULL_PTR arg);
/* @internal */
export function Fallback_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Fallback_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKFallback Fallback_clone(const struct LDKFallback *NONNULL_PTR orig);
/* @internal */
export function Fallback_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Fallback_clone(orig);
	return nativeResponseValue;
}
	// struct LDKFallback Fallback_seg_wit_program(struct LDKWitnessVersion version, struct LDKCVec_u8Z program);
/* @internal */
export function Fallback_seg_wit_program(version: number, program: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Fallback_seg_wit_program(version, program);
	return nativeResponseValue;
}
	// struct LDKFallback Fallback_pub_key_hash(struct LDKTwentyBytes a);
/* @internal */
export function Fallback_pub_key_hash(a: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Fallback_pub_key_hash(a);
	return nativeResponseValue;
}
	// struct LDKFallback Fallback_script_hash(struct LDKTwentyBytes a);
/* @internal */
export function Fallback_script_hash(a: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Fallback_script_hash(a);
	return nativeResponseValue;
}
	// uint64_t Fallback_hash(const struct LDKFallback *NONNULL_PTR o);
/* @internal */
export function Fallback_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Fallback_hash(o);
	return nativeResponseValue;
}
	// bool Fallback_eq(const struct LDKFallback *NONNULL_PTR a, const struct LDKFallback *NONNULL_PTR b);
/* @internal */
export function Fallback_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Fallback_eq(a, b);
	return nativeResponseValue;
}
	// void Bolt11InvoiceSignature_free(struct LDKBolt11InvoiceSignature this_obj);
/* @internal */
export function Bolt11InvoiceSignature_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceSignature_free(this_obj);
	// debug statements here
}
	// uint64_t Bolt11InvoiceSignature_clone_ptr(LDKBolt11InvoiceSignature *NONNULL_PTR arg);
/* @internal */
export function Bolt11InvoiceSignature_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceSignature_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBolt11InvoiceSignature Bolt11InvoiceSignature_clone(const struct LDKBolt11InvoiceSignature *NONNULL_PTR orig);
/* @internal */
export function Bolt11InvoiceSignature_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceSignature_clone(orig);
	return nativeResponseValue;
}
	// uint64_t Bolt11InvoiceSignature_hash(const struct LDKBolt11InvoiceSignature *NONNULL_PTR o);
/* @internal */
export function Bolt11InvoiceSignature_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceSignature_hash(o);
	return nativeResponseValue;
}
	// bool Bolt11InvoiceSignature_eq(const struct LDKBolt11InvoiceSignature *NONNULL_PTR a, const struct LDKBolt11InvoiceSignature *NONNULL_PTR b);
/* @internal */
export function Bolt11InvoiceSignature_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11InvoiceSignature_eq(a, b);
	return nativeResponseValue;
}
	// void PrivateRoute_free(struct LDKPrivateRoute this_obj);
/* @internal */
export function PrivateRoute_free(this_obj: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrivateRoute_free(this_obj);
	// debug statements here
}
	// uint64_t PrivateRoute_clone_ptr(LDKPrivateRoute *NONNULL_PTR arg);
/* @internal */
export function PrivateRoute_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrivateRoute_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPrivateRoute PrivateRoute_clone(const struct LDKPrivateRoute *NONNULL_PTR orig);
/* @internal */
export function PrivateRoute_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrivateRoute_clone(orig);
	return nativeResponseValue;
}
	// uint64_t PrivateRoute_hash(const struct LDKPrivateRoute *NONNULL_PTR o);
/* @internal */
export function PrivateRoute_hash(o: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrivateRoute_hash(o);
	return nativeResponseValue;
}
	// bool PrivateRoute_eq(const struct LDKPrivateRoute *NONNULL_PTR a, const struct LDKPrivateRoute *NONNULL_PTR b);
/* @internal */
export function PrivateRoute_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrivateRoute_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKC3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ SignedRawBolt11Invoice_into_parts(struct LDKSignedRawBolt11Invoice this_arg);
/* @internal */
export function SignedRawBolt11Invoice_into_parts(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawBolt11Invoice_into_parts(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKRawBolt11Invoice SignedRawBolt11Invoice_raw_invoice(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function SignedRawBolt11Invoice_raw_invoice(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawBolt11Invoice_raw_invoice(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES const uint8_t (*SignedRawBolt11Invoice_signable_hash(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR this_arg))[32];
/* @internal */
export function SignedRawBolt11Invoice_signable_hash(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawBolt11Invoice_signable_hash(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKBolt11InvoiceSignature SignedRawBolt11Invoice_signature(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function SignedRawBolt11Invoice_signature(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawBolt11Invoice_signature(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PayeePubKeyErrorZ SignedRawBolt11Invoice_recover_payee_pub_key(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function SignedRawBolt11Invoice_recover_payee_pub_key(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawBolt11Invoice_recover_payee_pub_key(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool SignedRawBolt11Invoice_check_signature(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function SignedRawBolt11Invoice_check_signature(this_arg: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawBolt11Invoice_check_signature(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes RawBolt11Invoice_signable_hash(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function RawBolt11Invoice_signable_hash(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_signable_hash(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKSha256 RawBolt11Invoice_payment_hash(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function RawBolt11Invoice_payment_hash(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_payment_hash(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKDescription RawBolt11Invoice_description(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function RawBolt11Invoice_description(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_description(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPayeePubKey RawBolt11Invoice_payee_pub_key(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function RawBolt11Invoice_payee_pub_key(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_payee_pub_key(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKSha256 RawBolt11Invoice_description_hash(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function RawBolt11Invoice_description_hash(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_description_hash(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKExpiryTime RawBolt11Invoice_expiry_time(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function RawBolt11Invoice_expiry_time(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_expiry_time(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKMinFinalCltvExpiryDelta RawBolt11Invoice_min_final_cltv_expiry_delta(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function RawBolt11Invoice_min_final_cltv_expiry_delta(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_min_final_cltv_expiry_delta(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_PaymentSecretZ RawBolt11Invoice_payment_secret(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function RawBolt11Invoice_payment_secret(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_payment_secret(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_CVec_u8ZZ RawBolt11Invoice_payment_metadata(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function RawBolt11Invoice_payment_metadata(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_payment_metadata(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKBolt11InvoiceFeatures RawBolt11Invoice_features(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function RawBolt11Invoice_features(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_features(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_PrivateRouteZ RawBolt11Invoice_private_routes(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function RawBolt11Invoice_private_routes(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_private_routes(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_u64Z RawBolt11Invoice_amount_pico_btc(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function RawBolt11Invoice_amount_pico_btc(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_amount_pico_btc(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES enum LDKCurrency RawBolt11Invoice_currency(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function RawBolt11Invoice_currency(this_arg: bigint): Currency {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawBolt11Invoice_currency(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PositiveTimestampCreationErrorZ PositiveTimestamp_from_unix_timestamp(uint64_t unix_seconds);
/* @internal */
export function PositiveTimestamp_from_unix_timestamp(unix_seconds: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PositiveTimestamp_from_unix_timestamp(unix_seconds);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PositiveTimestampCreationErrorZ PositiveTimestamp_from_duration_since_epoch(uint64_t duration);
/* @internal */
export function PositiveTimestamp_from_duration_since_epoch(duration: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PositiveTimestamp_from_duration_since_epoch(duration);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t PositiveTimestamp_as_unix_timestamp(const struct LDKPositiveTimestamp *NONNULL_PTR this_arg);
/* @internal */
export function PositiveTimestamp_as_unix_timestamp(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PositiveTimestamp_as_unix_timestamp(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t PositiveTimestamp_as_duration_since_epoch(const struct LDKPositiveTimestamp *NONNULL_PTR this_arg);
/* @internal */
export function PositiveTimestamp_as_duration_since_epoch(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PositiveTimestamp_as_duration_since_epoch(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes Bolt11Invoice_signable_hash(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11Invoice_signable_hash(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_signable_hash(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKSignedRawBolt11Invoice Bolt11Invoice_into_signed_raw(struct LDKBolt11Invoice this_arg);
/* @internal */
export function Bolt11Invoice_into_signed_raw(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_into_signed_raw(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneBolt11SemanticErrorZ Bolt11Invoice_check_signature(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11Invoice_check_signature(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_check_signature(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ Bolt11Invoice_from_signed(struct LDKSignedRawBolt11Invoice signed_invoice);
/* @internal */
export function Bolt11Invoice_from_signed(signed_invoice: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_from_signed(signed_invoice);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Bolt11Invoice_duration_since_epoch(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11Invoice_duration_since_epoch(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_duration_since_epoch(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES const uint8_t (*Bolt11Invoice_payment_hash(const struct LDKBolt11Invoice *NONNULL_PTR this_arg))[32];
/* @internal */
export function Bolt11Invoice_payment_hash(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_payment_hash(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPublicKey Bolt11Invoice_payee_pub_key(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11Invoice_payee_pub_key(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_payee_pub_key(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES const uint8_t (*Bolt11Invoice_payment_secret(const struct LDKBolt11Invoice *NONNULL_PTR this_arg))[32];
/* @internal */
export function Bolt11Invoice_payment_secret(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_payment_secret(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_CVec_u8ZZ Bolt11Invoice_payment_metadata(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11Invoice_payment_metadata(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_payment_metadata(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKBolt11InvoiceFeatures Bolt11Invoice_features(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11Invoice_features(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_features(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPublicKey Bolt11Invoice_recover_payee_pub_key(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11Invoice_recover_payee_pub_key(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_recover_payee_pub_key(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_DurationZ Bolt11Invoice_expires_at(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11Invoice_expires_at(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_expires_at(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Bolt11Invoice_expiry_time(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11Invoice_expiry_time(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_expiry_time(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Bolt11Invoice_expiration_remaining_from_epoch(const struct LDKBolt11Invoice *NONNULL_PTR this_arg, uint64_t time);
/* @internal */
export function Bolt11Invoice_expiration_remaining_from_epoch(this_arg: bigint, time: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_expiration_remaining_from_epoch(this_arg, time);
	return nativeResponseValue;
}
	// MUST_USE_RES bool Bolt11Invoice_would_expire(const struct LDKBolt11Invoice *NONNULL_PTR this_arg, uint64_t at_time);
/* @internal */
export function Bolt11Invoice_would_expire(this_arg: bigint, at_time: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_would_expire(this_arg, at_time);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Bolt11Invoice_min_final_cltv_expiry_delta(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11Invoice_min_final_cltv_expiry_delta(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_min_final_cltv_expiry_delta(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_AddressZ Bolt11Invoice_fallback_addresses(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11Invoice_fallback_addresses(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_fallback_addresses(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_PrivateRouteZ Bolt11Invoice_private_routes(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11Invoice_private_routes(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_private_routes(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_RouteHintZ Bolt11Invoice_route_hints(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11Invoice_route_hints(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_route_hints(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES enum LDKCurrency Bolt11Invoice_currency(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11Invoice_currency(this_arg: bigint): Currency {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_currency(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_u64Z Bolt11Invoice_amount_milli_satoshis(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);
/* @internal */
export function Bolt11Invoice_amount_milli_satoshis(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_amount_milli_satoshis(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_DescriptionCreationErrorZ Description_new(struct LDKStr description);
/* @internal */
export function Description_new(description: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Description_new(description);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKStr Description_into_inner(struct LDKDescription this_arg);
/* @internal */
export function Description_into_inner(this_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Description_into_inner(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKExpiryTime ExpiryTime_from_seconds(uint64_t seconds);
/* @internal */
export function ExpiryTime_from_seconds(seconds: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_from_seconds(seconds);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKExpiryTime ExpiryTime_from_duration(uint64_t duration);
/* @internal */
export function ExpiryTime_from_duration(duration: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_from_duration(duration);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t ExpiryTime_as_seconds(const struct LDKExpiryTime *NONNULL_PTR this_arg);
/* @internal */
export function ExpiryTime_as_seconds(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_as_seconds(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t ExpiryTime_as_duration(const struct LDKExpiryTime *NONNULL_PTR this_arg);
/* @internal */
export function ExpiryTime_as_duration(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_as_duration(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PrivateRouteCreationErrorZ PrivateRoute_new(struct LDKRouteHint hops);
/* @internal */
export function PrivateRoute_new(hops: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrivateRoute_new(hops);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKRouteHint PrivateRoute_into_inner(struct LDKPrivateRoute this_arg);
/* @internal */
export function PrivateRoute_into_inner(this_arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrivateRoute_into_inner(this_arg);
	return nativeResponseValue;
}
	// enum LDKCreationError CreationError_clone(const enum LDKCreationError *NONNULL_PTR orig);
/* @internal */
export function CreationError_clone(orig: bigint): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CreationError_clone(orig);
	return nativeResponseValue;
}
	// enum LDKCreationError CreationError_description_too_long(void);
/* @internal */
export function CreationError_description_too_long(): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CreationError_description_too_long();
	return nativeResponseValue;
}
	// enum LDKCreationError CreationError_route_too_long(void);
/* @internal */
export function CreationError_route_too_long(): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CreationError_route_too_long();
	return nativeResponseValue;
}
	// enum LDKCreationError CreationError_timestamp_out_of_bounds(void);
/* @internal */
export function CreationError_timestamp_out_of_bounds(): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CreationError_timestamp_out_of_bounds();
	return nativeResponseValue;
}
	// enum LDKCreationError CreationError_invalid_amount(void);
/* @internal */
export function CreationError_invalid_amount(): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CreationError_invalid_amount();
	return nativeResponseValue;
}
	// enum LDKCreationError CreationError_missing_route_hints(void);
/* @internal */
export function CreationError_missing_route_hints(): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CreationError_missing_route_hints();
	return nativeResponseValue;
}
	// enum LDKCreationError CreationError_min_final_cltv_expiry_delta_too_short(void);
/* @internal */
export function CreationError_min_final_cltv_expiry_delta_too_short(): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CreationError_min_final_cltv_expiry_delta_too_short();
	return nativeResponseValue;
}
	// bool CreationError_eq(const enum LDKCreationError *NONNULL_PTR a, const enum LDKCreationError *NONNULL_PTR b);
/* @internal */
export function CreationError_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CreationError_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKStr CreationError_to_str(const enum LDKCreationError *NONNULL_PTR o);
/* @internal */
export function CreationError_to_str(o: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CreationError_to_str(o);
	return nativeResponseValue;
}
	// enum LDKBolt11SemanticError Bolt11SemanticError_clone(const enum LDKBolt11SemanticError *NONNULL_PTR orig);
/* @internal */
export function Bolt11SemanticError_clone(orig: bigint): Bolt11SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11SemanticError_clone(orig);
	return nativeResponseValue;
}
	// enum LDKBolt11SemanticError Bolt11SemanticError_no_payment_hash(void);
/* @internal */
export function Bolt11SemanticError_no_payment_hash(): Bolt11SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11SemanticError_no_payment_hash();
	return nativeResponseValue;
}
	// enum LDKBolt11SemanticError Bolt11SemanticError_multiple_payment_hashes(void);
/* @internal */
export function Bolt11SemanticError_multiple_payment_hashes(): Bolt11SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11SemanticError_multiple_payment_hashes();
	return nativeResponseValue;
}
	// enum LDKBolt11SemanticError Bolt11SemanticError_no_description(void);
/* @internal */
export function Bolt11SemanticError_no_description(): Bolt11SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11SemanticError_no_description();
	return nativeResponseValue;
}
	// enum LDKBolt11SemanticError Bolt11SemanticError_multiple_descriptions(void);
/* @internal */
export function Bolt11SemanticError_multiple_descriptions(): Bolt11SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11SemanticError_multiple_descriptions();
	return nativeResponseValue;
}
	// enum LDKBolt11SemanticError Bolt11SemanticError_no_payment_secret(void);
/* @internal */
export function Bolt11SemanticError_no_payment_secret(): Bolt11SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11SemanticError_no_payment_secret();
	return nativeResponseValue;
}
	// enum LDKBolt11SemanticError Bolt11SemanticError_multiple_payment_secrets(void);
/* @internal */
export function Bolt11SemanticError_multiple_payment_secrets(): Bolt11SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11SemanticError_multiple_payment_secrets();
	return nativeResponseValue;
}
	// enum LDKBolt11SemanticError Bolt11SemanticError_invalid_features(void);
/* @internal */
export function Bolt11SemanticError_invalid_features(): Bolt11SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11SemanticError_invalid_features();
	return nativeResponseValue;
}
	// enum LDKBolt11SemanticError Bolt11SemanticError_invalid_recovery_id(void);
/* @internal */
export function Bolt11SemanticError_invalid_recovery_id(): Bolt11SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11SemanticError_invalid_recovery_id();
	return nativeResponseValue;
}
	// enum LDKBolt11SemanticError Bolt11SemanticError_invalid_signature(void);
/* @internal */
export function Bolt11SemanticError_invalid_signature(): Bolt11SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11SemanticError_invalid_signature();
	return nativeResponseValue;
}
	// enum LDKBolt11SemanticError Bolt11SemanticError_imprecise_amount(void);
/* @internal */
export function Bolt11SemanticError_imprecise_amount(): Bolt11SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11SemanticError_imprecise_amount();
	return nativeResponseValue;
}
	// bool Bolt11SemanticError_eq(const enum LDKBolt11SemanticError *NONNULL_PTR a, const enum LDKBolt11SemanticError *NONNULL_PTR b);
/* @internal */
export function Bolt11SemanticError_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11SemanticError_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKStr Bolt11SemanticError_to_str(const enum LDKBolt11SemanticError *NONNULL_PTR o);
/* @internal */
export function Bolt11SemanticError_to_str(o: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11SemanticError_to_str(o);
	return nativeResponseValue;
}
	// void SignOrCreationError_free(struct LDKSignOrCreationError this_ptr);
/* @internal */
export function SignOrCreationError_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignOrCreationError_free(this_ptr);
	// debug statements here
}
	// uint64_t SignOrCreationError_clone_ptr(LDKSignOrCreationError *NONNULL_PTR arg);
/* @internal */
export function SignOrCreationError_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignOrCreationError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKSignOrCreationError SignOrCreationError_clone(const struct LDKSignOrCreationError *NONNULL_PTR orig);
/* @internal */
export function SignOrCreationError_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignOrCreationError_clone(orig);
	return nativeResponseValue;
}
	// struct LDKSignOrCreationError SignOrCreationError_sign_error(void);
/* @internal */
export function SignOrCreationError_sign_error(): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignOrCreationError_sign_error();
	return nativeResponseValue;
}
	// struct LDKSignOrCreationError SignOrCreationError_creation_error(enum LDKCreationError a);
/* @internal */
export function SignOrCreationError_creation_error(a: CreationError): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignOrCreationError_creation_error(a);
	return nativeResponseValue;
}
	// bool SignOrCreationError_eq(const struct LDKSignOrCreationError *NONNULL_PTR a, const struct LDKSignOrCreationError *NONNULL_PTR b);
/* @internal */
export function SignOrCreationError_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignOrCreationError_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKStr SignOrCreationError_to_str(const struct LDKSignOrCreationError *NONNULL_PTR o);
/* @internal */
export function SignOrCreationError_to_str(o: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignOrCreationError_to_str(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentIdPaymentErrorZ pay_invoice(const struct LDKBolt11Invoice *NONNULL_PTR invoice, struct LDKRetry retry_strategy, const struct LDKChannelManager *NONNULL_PTR channelmanager);
/* @internal */
export function pay_invoice(invoice: bigint, retry_strategy: bigint, channelmanager: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_pay_invoice(invoice, retry_strategy, channelmanager);
	return nativeResponseValue;
}
	// struct LDKCResult_NonePaymentErrorZ pay_invoice_with_id(const struct LDKBolt11Invoice *NONNULL_PTR invoice, struct LDKThirtyTwoBytes payment_id, struct LDKRetry retry_strategy, const struct LDKChannelManager *NONNULL_PTR channelmanager);
/* @internal */
export function pay_invoice_with_id(invoice: bigint, payment_id: number, retry_strategy: bigint, channelmanager: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_pay_invoice_with_id(invoice, payment_id, retry_strategy, channelmanager);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentIdPaymentErrorZ pay_zero_value_invoice(const struct LDKBolt11Invoice *NONNULL_PTR invoice, uint64_t amount_msats, struct LDKRetry retry_strategy, const struct LDKChannelManager *NONNULL_PTR channelmanager);
/* @internal */
export function pay_zero_value_invoice(invoice: bigint, amount_msats: bigint, retry_strategy: bigint, channelmanager: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_pay_zero_value_invoice(invoice, amount_msats, retry_strategy, channelmanager);
	return nativeResponseValue;
}
	// struct LDKCResult_NonePaymentErrorZ pay_zero_value_invoice_with_id(const struct LDKBolt11Invoice *NONNULL_PTR invoice, uint64_t amount_msats, struct LDKThirtyTwoBytes payment_id, struct LDKRetry retry_strategy, const struct LDKChannelManager *NONNULL_PTR channelmanager);
/* @internal */
export function pay_zero_value_invoice_with_id(invoice: bigint, amount_msats: bigint, payment_id: number, retry_strategy: bigint, channelmanager: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_pay_zero_value_invoice_with_id(invoice, amount_msats, payment_id, retry_strategy, channelmanager);
	return nativeResponseValue;
}
	// void PaymentError_free(struct LDKPaymentError this_ptr);
/* @internal */
export function PaymentError_free(this_ptr: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentError_free(this_ptr);
	// debug statements here
}
	// uint64_t PaymentError_clone_ptr(LDKPaymentError *NONNULL_PTR arg);
/* @internal */
export function PaymentError_clone_ptr(arg: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPaymentError PaymentError_clone(const struct LDKPaymentError *NONNULL_PTR orig);
/* @internal */
export function PaymentError_clone(orig: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentError_clone(orig);
	return nativeResponseValue;
}
	// struct LDKPaymentError PaymentError_invoice(struct LDKStr a);
/* @internal */
export function PaymentError_invoice(a: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentError_invoice(a);
	return nativeResponseValue;
}
	// struct LDKPaymentError PaymentError_sending(enum LDKRetryableSendFailure a);
/* @internal */
export function PaymentError_sending(a: RetryableSendFailure): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentError_sending(a);
	return nativeResponseValue;
}
	// bool PaymentError_eq(const struct LDKPaymentError *NONNULL_PTR a, const struct LDKPaymentError *NONNULL_PTR b);
/* @internal */
export function PaymentError_eq(a: bigint, b: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentError_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ create_phantom_invoice(struct LDKCOption_u64Z amt_msat, struct LDKCOption_PaymentHashZ payment_hash, struct LDKStr description, uint32_t invoice_expiry_delta_secs, struct LDKCVec_PhantomRouteHintsZ phantom_route_hints, struct LDKEntropySource entropy_source, struct LDKNodeSigner node_signer, struct LDKLogger logger, enum LDKCurrency network, struct LDKCOption_u16Z min_final_cltv_expiry_delta, uint64_t duration_since_epoch);
/* @internal */
export function create_phantom_invoice(amt_msat: bigint, payment_hash: bigint, description: number, invoice_expiry_delta_secs: number, phantom_route_hints: number, entropy_source: bigint, node_signer: bigint, logger: bigint, network: Currency, min_final_cltv_expiry_delta: bigint, duration_since_epoch: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_create_phantom_invoice(amt_msat, payment_hash, description, invoice_expiry_delta_secs, phantom_route_hints, entropy_source, node_signer, logger, network, min_final_cltv_expiry_delta, duration_since_epoch);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ create_phantom_invoice_with_description_hash(struct LDKCOption_u64Z amt_msat, struct LDKCOption_PaymentHashZ payment_hash, uint32_t invoice_expiry_delta_secs, struct LDKSha256 description_hash, struct LDKCVec_PhantomRouteHintsZ phantom_route_hints, struct LDKEntropySource entropy_source, struct LDKNodeSigner node_signer, struct LDKLogger logger, enum LDKCurrency network, struct LDKCOption_u16Z min_final_cltv_expiry_delta, uint64_t duration_since_epoch);
/* @internal */
export function create_phantom_invoice_with_description_hash(amt_msat: bigint, payment_hash: bigint, invoice_expiry_delta_secs: number, description_hash: bigint, phantom_route_hints: number, entropy_source: bigint, node_signer: bigint, logger: bigint, network: Currency, min_final_cltv_expiry_delta: bigint, duration_since_epoch: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_create_phantom_invoice_with_description_hash(amt_msat, payment_hash, invoice_expiry_delta_secs, description_hash, phantom_route_hints, entropy_source, node_signer, logger, network, min_final_cltv_expiry_delta, duration_since_epoch);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager_with_description_hash_and_duration_since_epoch(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKNodeSigner node_signer, struct LDKLogger logger, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKSha256 description_hash, uint64_t duration_since_epoch, uint32_t invoice_expiry_delta_secs, struct LDKCOption_u16Z min_final_cltv_expiry_delta);
/* @internal */
export function create_invoice_from_channelmanager_with_description_hash_and_duration_since_epoch(channelmanager: bigint, node_signer: bigint, logger: bigint, network: Currency, amt_msat: bigint, description_hash: bigint, duration_since_epoch: bigint, invoice_expiry_delta_secs: number, min_final_cltv_expiry_delta: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_create_invoice_from_channelmanager_with_description_hash_and_duration_since_epoch(channelmanager, node_signer, logger, network, amt_msat, description_hash, duration_since_epoch, invoice_expiry_delta_secs, min_final_cltv_expiry_delta);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager_and_duration_since_epoch(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKNodeSigner node_signer, struct LDKLogger logger, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKStr description, uint64_t duration_since_epoch, uint32_t invoice_expiry_delta_secs, struct LDKCOption_u16Z min_final_cltv_expiry_delta);
/* @internal */
export function create_invoice_from_channelmanager_and_duration_since_epoch(channelmanager: bigint, node_signer: bigint, logger: bigint, network: Currency, amt_msat: bigint, description: number, duration_since_epoch: bigint, invoice_expiry_delta_secs: number, min_final_cltv_expiry_delta: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_create_invoice_from_channelmanager_and_duration_since_epoch(channelmanager, node_signer, logger, network, amt_msat, description, duration_since_epoch, invoice_expiry_delta_secs, min_final_cltv_expiry_delta);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager_and_duration_since_epoch_with_payment_hash(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKNodeSigner node_signer, struct LDKLogger logger, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKStr description, uint64_t duration_since_epoch, uint32_t invoice_expiry_delta_secs, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u16Z min_final_cltv_expiry_delta);
/* @internal */
export function create_invoice_from_channelmanager_and_duration_since_epoch_with_payment_hash(channelmanager: bigint, node_signer: bigint, logger: bigint, network: Currency, amt_msat: bigint, description: number, duration_since_epoch: bigint, invoice_expiry_delta_secs: number, payment_hash: number, min_final_cltv_expiry_delta: bigint): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_create_invoice_from_channelmanager_and_duration_since_epoch_with_payment_hash(channelmanager, node_signer, logger, network, amt_msat, description, duration_since_epoch, invoice_expiry_delta_secs, payment_hash, min_final_cltv_expiry_delta);
	return nativeResponseValue;
}
	// struct LDKCResult_SiPrefixBolt11ParseErrorZ SiPrefix_from_str(struct LDKStr s);
/* @internal */
export function SiPrefix_from_str(s: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_from_str(s);
	return nativeResponseValue;
}
	// struct LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ Bolt11Invoice_from_str(struct LDKStr s);
/* @internal */
export function Bolt11Invoice_from_str(s: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_from_str(s);
	return nativeResponseValue;
}
	// struct LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ SignedRawBolt11Invoice_from_str(struct LDKStr s);
/* @internal */
export function SignedRawBolt11Invoice_from_str(s: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawBolt11Invoice_from_str(s);
	return nativeResponseValue;
}
	// struct LDKStr Bolt11ParseError_to_str(const struct LDKBolt11ParseError *NONNULL_PTR o);
/* @internal */
export function Bolt11ParseError_to_str(o: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11ParseError_to_str(o);
	return nativeResponseValue;
}
	// struct LDKStr ParseOrSemanticError_to_str(const struct LDKParseOrSemanticError *NONNULL_PTR o);
/* @internal */
export function ParseOrSemanticError_to_str(o: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseOrSemanticError_to_str(o);
	return nativeResponseValue;
}
	// struct LDKStr Bolt11Invoice_to_str(const struct LDKBolt11Invoice *NONNULL_PTR o);
/* @internal */
export function Bolt11Invoice_to_str(o: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bolt11Invoice_to_str(o);
	return nativeResponseValue;
}
	// struct LDKStr SignedRawBolt11Invoice_to_str(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR o);
/* @internal */
export function SignedRawBolt11Invoice_to_str(o: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawBolt11Invoice_to_str(o);
	return nativeResponseValue;
}
	// struct LDKStr Currency_to_str(const enum LDKCurrency *NONNULL_PTR o);
/* @internal */
export function Currency_to_str(o: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_to_str(o);
	return nativeResponseValue;
}
	// struct LDKStr SiPrefix_to_str(const enum LDKSiPrefix *NONNULL_PTR o);
/* @internal */
export function SiPrefix_to_str(o: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_to_str(o);
	return nativeResponseValue;
}


js_invoke = function(obj_ptr: number, fn_id: number, arg1: bigint|number, arg2: bigint|number, arg3: bigint|number, arg4: bigint|number, arg5: bigint|number, arg6: bigint|number, arg7: bigint|number, arg8: bigint|number, arg9: bigint|number, arg10: bigint|number) {
	const weak: WeakRef<object>|undefined = js_objs[obj_ptr];
	if (weak == null || weak == undefined) {
		console.error("Got function call on unknown/free'd JS object!");
		throw new Error("Got function call on unknown/free'd JS object!");
	}
	const obj = weak.deref();
	if (obj == null || obj == undefined) {
		console.error("Got function call on GC'd JS object!");
		throw new Error("Got function call on GC'd JS object!");
	}
	var fn;
	switch (fn_id) {
		case 0: fn = Object.getOwnPropertyDescriptor(obj, "get_per_commitment_point"); break;
		case 1: fn = Object.getOwnPropertyDescriptor(obj, "release_commitment_secret"); break;
		case 2: fn = Object.getOwnPropertyDescriptor(obj, "validate_holder_commitment"); break;
		case 3: fn = Object.getOwnPropertyDescriptor(obj, "channel_keys_id"); break;
		case 4: fn = Object.getOwnPropertyDescriptor(obj, "provide_channel_parameters"); break;
		case 5: fn = Object.getOwnPropertyDescriptor(obj, "sign_counterparty_commitment"); break;
		case 6: fn = Object.getOwnPropertyDescriptor(obj, "validate_counterparty_revocation"); break;
		case 7: fn = Object.getOwnPropertyDescriptor(obj, "sign_holder_commitment_and_htlcs"); break;
		case 8: fn = Object.getOwnPropertyDescriptor(obj, "sign_justice_revoked_output"); break;
		case 9: fn = Object.getOwnPropertyDescriptor(obj, "sign_justice_revoked_htlc"); break;
		case 10: fn = Object.getOwnPropertyDescriptor(obj, "sign_holder_htlc_transaction"); break;
		case 11: fn = Object.getOwnPropertyDescriptor(obj, "sign_counterparty_htlc_transaction"); break;
		case 12: fn = Object.getOwnPropertyDescriptor(obj, "sign_closing_transaction"); break;
		case 13: fn = Object.getOwnPropertyDescriptor(obj, "sign_holder_anchor_input"); break;
		case 14: fn = Object.getOwnPropertyDescriptor(obj, "sign_channel_announcement_with_funding_key"); break;
		case 15: fn = Object.getOwnPropertyDescriptor(obj, "write"); break;
		case 16: fn = Object.getOwnPropertyDescriptor(obj, "log"); break;
		case 17: fn = Object.getOwnPropertyDescriptor(obj, "get_utxo"); break;
		case 18: fn = Object.getOwnPropertyDescriptor(obj, "watch_channel"); break;
		case 19: fn = Object.getOwnPropertyDescriptor(obj, "update_channel"); break;
		case 20: fn = Object.getOwnPropertyDescriptor(obj, "release_pending_monitor_events"); break;
		case 21: fn = Object.getOwnPropertyDescriptor(obj, "broadcast_transactions"); break;
		case 22: fn = Object.getOwnPropertyDescriptor(obj, "get_secure_random_bytes"); break;
		case 23: fn = Object.getOwnPropertyDescriptor(obj, "get_inbound_payment_key_material"); break;
		case 24: fn = Object.getOwnPropertyDescriptor(obj, "get_node_id"); break;
		case 25: fn = Object.getOwnPropertyDescriptor(obj, "ecdh"); break;
		case 26: fn = Object.getOwnPropertyDescriptor(obj, "sign_invoice"); break;
		case 27: fn = Object.getOwnPropertyDescriptor(obj, "sign_gossip_message"); break;
		case 28: fn = Object.getOwnPropertyDescriptor(obj, "generate_channel_keys_id"); break;
		case 29: fn = Object.getOwnPropertyDescriptor(obj, "derive_channel_signer"); break;
		case 30: fn = Object.getOwnPropertyDescriptor(obj, "read_chan_signer"); break;
		case 31: fn = Object.getOwnPropertyDescriptor(obj, "get_destination_script"); break;
		case 32: fn = Object.getOwnPropertyDescriptor(obj, "get_shutdown_scriptpubkey"); break;
		case 33: fn = Object.getOwnPropertyDescriptor(obj, "get_est_sat_per_1000_weight"); break;
		case 34: fn = Object.getOwnPropertyDescriptor(obj, "find_route"); break;
		case 35: fn = Object.getOwnPropertyDescriptor(obj, "find_route_with_id"); break;
		case 36: fn = Object.getOwnPropertyDescriptor(obj, "type_id"); break;
		case 37: fn = Object.getOwnPropertyDescriptor(obj, "debug_str"); break;
		case 38: fn = Object.getOwnPropertyDescriptor(obj, "write"); break;
		case 39: fn = Object.getOwnPropertyDescriptor(obj, "tlv_type"); break;
		case 40: fn = Object.getOwnPropertyDescriptor(obj, "write"); break;
		case 41: fn = Object.getOwnPropertyDescriptor(obj, "register_tx"); break;
		case 42: fn = Object.getOwnPropertyDescriptor(obj, "register_output"); break;
		case 43: fn = Object.getOwnPropertyDescriptor(obj, "channel_penalty_msat"); break;
		case 44: fn = Object.getOwnPropertyDescriptor(obj, "payment_path_failed"); break;
		case 45: fn = Object.getOwnPropertyDescriptor(obj, "payment_path_successful"); break;
		case 46: fn = Object.getOwnPropertyDescriptor(obj, "probe_failed"); break;
		case 47: fn = Object.getOwnPropertyDescriptor(obj, "probe_successful"); break;
		case 48: fn = Object.getOwnPropertyDescriptor(obj, "write"); break;
		case 49: fn = Object.getOwnPropertyDescriptor(obj, "lock"); break;
		case 50: fn = Object.getOwnPropertyDescriptor(obj, "write"); break;
		case 51: fn = Object.getOwnPropertyDescriptor(obj, "persist_manager"); break;
		case 52: fn = Object.getOwnPropertyDescriptor(obj, "persist_graph"); break;
		case 53: fn = Object.getOwnPropertyDescriptor(obj, "persist_scorer"); break;
		case 54: fn = Object.getOwnPropertyDescriptor(obj, "call"); break;
		case 55: fn = Object.getOwnPropertyDescriptor(obj, "filtered_block_connected"); break;
		case 56: fn = Object.getOwnPropertyDescriptor(obj, "block_connected"); break;
		case 57: fn = Object.getOwnPropertyDescriptor(obj, "block_disconnected"); break;
		case 58: fn = Object.getOwnPropertyDescriptor(obj, "transactions_confirmed"); break;
		case 59: fn = Object.getOwnPropertyDescriptor(obj, "transaction_unconfirmed"); break;
		case 60: fn = Object.getOwnPropertyDescriptor(obj, "best_block_updated"); break;
		case 61: fn = Object.getOwnPropertyDescriptor(obj, "get_relevant_txids"); break;
		case 62: fn = Object.getOwnPropertyDescriptor(obj, "persist_new_channel"); break;
		case 63: fn = Object.getOwnPropertyDescriptor(obj, "update_persisted_channel"); break;
		case 64: fn = Object.getOwnPropertyDescriptor(obj, "handle_event"); break;
		case 65: fn = Object.getOwnPropertyDescriptor(obj, "process_pending_events"); break;
		case 66: fn = Object.getOwnPropertyDescriptor(obj, "get_and_clear_pending_msg_events"); break;
		case 67: fn = Object.getOwnPropertyDescriptor(obj, "handle_open_channel"); break;
		case 68: fn = Object.getOwnPropertyDescriptor(obj, "handle_open_channel_v2"); break;
		case 69: fn = Object.getOwnPropertyDescriptor(obj, "handle_accept_channel"); break;
		case 70: fn = Object.getOwnPropertyDescriptor(obj, "handle_accept_channel_v2"); break;
		case 71: fn = Object.getOwnPropertyDescriptor(obj, "handle_funding_created"); break;
		case 72: fn = Object.getOwnPropertyDescriptor(obj, "handle_funding_signed"); break;
		case 73: fn = Object.getOwnPropertyDescriptor(obj, "handle_channel_ready"); break;
		case 74: fn = Object.getOwnPropertyDescriptor(obj, "handle_shutdown"); break;
		case 75: fn = Object.getOwnPropertyDescriptor(obj, "handle_closing_signed"); break;
		case 76: fn = Object.getOwnPropertyDescriptor(obj, "handle_tx_add_input"); break;
		case 77: fn = Object.getOwnPropertyDescriptor(obj, "handle_tx_add_output"); break;
		case 78: fn = Object.getOwnPropertyDescriptor(obj, "handle_tx_remove_input"); break;
		case 79: fn = Object.getOwnPropertyDescriptor(obj, "handle_tx_remove_output"); break;
		case 80: fn = Object.getOwnPropertyDescriptor(obj, "handle_tx_complete"); break;
		case 81: fn = Object.getOwnPropertyDescriptor(obj, "handle_tx_signatures"); break;
		case 82: fn = Object.getOwnPropertyDescriptor(obj, "handle_tx_init_rbf"); break;
		case 83: fn = Object.getOwnPropertyDescriptor(obj, "handle_tx_ack_rbf"); break;
		case 84: fn = Object.getOwnPropertyDescriptor(obj, "handle_tx_abort"); break;
		case 85: fn = Object.getOwnPropertyDescriptor(obj, "handle_update_add_htlc"); break;
		case 86: fn = Object.getOwnPropertyDescriptor(obj, "handle_update_fulfill_htlc"); break;
		case 87: fn = Object.getOwnPropertyDescriptor(obj, "handle_update_fail_htlc"); break;
		case 88: fn = Object.getOwnPropertyDescriptor(obj, "handle_update_fail_malformed_htlc"); break;
		case 89: fn = Object.getOwnPropertyDescriptor(obj, "handle_commitment_signed"); break;
		case 90: fn = Object.getOwnPropertyDescriptor(obj, "handle_revoke_and_ack"); break;
		case 91: fn = Object.getOwnPropertyDescriptor(obj, "handle_update_fee"); break;
		case 92: fn = Object.getOwnPropertyDescriptor(obj, "handle_announcement_signatures"); break;
		case 93: fn = Object.getOwnPropertyDescriptor(obj, "peer_disconnected"); break;
		case 94: fn = Object.getOwnPropertyDescriptor(obj, "peer_connected"); break;
		case 95: fn = Object.getOwnPropertyDescriptor(obj, "handle_channel_reestablish"); break;
		case 96: fn = Object.getOwnPropertyDescriptor(obj, "handle_channel_update"); break;
		case 97: fn = Object.getOwnPropertyDescriptor(obj, "handle_error"); break;
		case 98: fn = Object.getOwnPropertyDescriptor(obj, "provided_node_features"); break;
		case 99: fn = Object.getOwnPropertyDescriptor(obj, "provided_init_features"); break;
		case 100: fn = Object.getOwnPropertyDescriptor(obj, "get_genesis_hashes"); break;
		case 101: fn = Object.getOwnPropertyDescriptor(obj, "handle_node_announcement"); break;
		case 102: fn = Object.getOwnPropertyDescriptor(obj, "handle_channel_announcement"); break;
		case 103: fn = Object.getOwnPropertyDescriptor(obj, "handle_channel_update"); break;
		case 104: fn = Object.getOwnPropertyDescriptor(obj, "get_next_channel_announcement"); break;
		case 105: fn = Object.getOwnPropertyDescriptor(obj, "get_next_node_announcement"); break;
		case 106: fn = Object.getOwnPropertyDescriptor(obj, "peer_connected"); break;
		case 107: fn = Object.getOwnPropertyDescriptor(obj, "handle_reply_channel_range"); break;
		case 108: fn = Object.getOwnPropertyDescriptor(obj, "handle_reply_short_channel_ids_end"); break;
		case 109: fn = Object.getOwnPropertyDescriptor(obj, "handle_query_channel_range"); break;
		case 110: fn = Object.getOwnPropertyDescriptor(obj, "handle_query_short_channel_ids"); break;
		case 111: fn = Object.getOwnPropertyDescriptor(obj, "processing_queue_high"); break;
		case 112: fn = Object.getOwnPropertyDescriptor(obj, "provided_node_features"); break;
		case 113: fn = Object.getOwnPropertyDescriptor(obj, "provided_init_features"); break;
		case 114: fn = Object.getOwnPropertyDescriptor(obj, "next_onion_message_for_peer"); break;
		case 115: fn = Object.getOwnPropertyDescriptor(obj, "handle_onion_message"); break;
		case 116: fn = Object.getOwnPropertyDescriptor(obj, "peer_connected"); break;
		case 117: fn = Object.getOwnPropertyDescriptor(obj, "peer_disconnected"); break;
		case 118: fn = Object.getOwnPropertyDescriptor(obj, "provided_node_features"); break;
		case 119: fn = Object.getOwnPropertyDescriptor(obj, "provided_init_features"); break;
		case 120: fn = Object.getOwnPropertyDescriptor(obj, "read"); break;
		case 121: fn = Object.getOwnPropertyDescriptor(obj, "handle_custom_message"); break;
		case 122: fn = Object.getOwnPropertyDescriptor(obj, "get_and_clear_pending_msg"); break;
		case 123: fn = Object.getOwnPropertyDescriptor(obj, "provided_node_features"); break;
		case 124: fn = Object.getOwnPropertyDescriptor(obj, "provided_init_features"); break;
		case 125: fn = Object.getOwnPropertyDescriptor(obj, "handle_message"); break;
		case 126: fn = Object.getOwnPropertyDescriptor(obj, "handle_custom_message"); break;
		case 127: fn = Object.getOwnPropertyDescriptor(obj, "read_custom_message"); break;
		case 128: fn = Object.getOwnPropertyDescriptor(obj, "send_data"); break;
		case 129: fn = Object.getOwnPropertyDescriptor(obj, "disconnect_socket"); break;
		case 130: fn = Object.getOwnPropertyDescriptor(obj, "eq"); break;
		case 131: fn = Object.getOwnPropertyDescriptor(obj, "hash"); break;
		case 132: fn = Object.getOwnPropertyDescriptor(obj, "find_path"); break;
		case 133: fn = Object.getOwnPropertyDescriptor(obj, "select_confirmed_utxos"); break;
		case 134: fn = Object.getOwnPropertyDescriptor(obj, "sign_tx"); break;
		case 135: fn = Object.getOwnPropertyDescriptor(obj, "list_confirmed_utxos"); break;
		case 136: fn = Object.getOwnPropertyDescriptor(obj, "get_change_script"); break;
		case 137: fn = Object.getOwnPropertyDescriptor(obj, "sign_tx"); break;
		default:
			console.error("Got unknown function call with id " + fn_id + " from C!");
			throw new Error("Got unknown function call with id " + fn_id + " from C!");
	}
	if (fn == null || fn == undefined) {
		console.error("Got function call with id " + fn_id + " on incorrect JS object: " + obj);
		throw new Error("Got function call with id " + fn_id + " on incorrect JS object: " + obj);
	}
	var ret;
	try {
		ret = fn.value.bind(obj)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
	} catch (e) {
		console.error("Got an exception calling function with id " + fn_id + "! This is fatal.");
		console.error(e);
		throw e;
	}
	if (ret === undefined || ret === null) return BigInt(0);
	return BigInt(ret);
}